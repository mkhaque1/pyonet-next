"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_splinetool_runtime_build_process_js"],{

/***/ "(app-pages-browser)/./node_modules/@splinetool/runtime/build/process.js":
/*!***********************************************************!*\
  !*** ./node_modules/@splinetool/runtime/build/process.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar Module = (()=>{\n    var _scriptDir = typeof document !== \"undefined\" && document.currentScript ? document.currentScript.src : undefined;\n    return function() {\n        let moduleArg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var Module = moduleArg;\n        var readyPromiseResolve, readyPromiseReject;\n        Module[\"ready\"] = new Promise((resolve, reject)=>{\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = (status, toThrow)=>{\n            throw toThrow;\n        };\n        var ENVIRONMENT_IS_WEB = true;\n        var ENVIRONMENT_IS_WORKER = false;\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n            if (Module[\"locateFile\"]) {\n                return Module[\"locateFile\"](path, scriptDirectory);\n            }\n            return scriptDirectory + path;\n        }\n        var read_, readAsync, readBinary;\n        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) {\n                scriptDirectory = self.location.href;\n            } else if (typeof document != \"undefined\" && document.currentScript) {\n                scriptDirectory = document.currentScript.src;\n            }\n            if (_scriptDir) {\n                scriptDirectory = _scriptDir;\n            }\n            if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n                scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n            } else {\n                scriptDirectory = \"\";\n            }\n            {\n                read_ = (url)=>{\n                    var xhr = new XMLHttpRequest;\n                    xhr.open(\"GET\", url, false);\n                    xhr.send(null);\n                    return xhr.responseText;\n                };\n                if (ENVIRONMENT_IS_WORKER) {\n                    readBinary = (url)=>{\n                        var xhr = new XMLHttpRequest;\n                        xhr.open(\"GET\", url, false);\n                        xhr.responseType = \"arraybuffer\";\n                        xhr.send(null);\n                        return new Uint8Array(xhr.response);\n                    };\n                }\n                readAsync = (url, onload, onerror)=>{\n                    var xhr = new XMLHttpRequest;\n                    xhr.open(\"GET\", url, true);\n                    xhr.responseType = \"arraybuffer\";\n                    xhr.onload = ()=>{\n                        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                            onload(xhr.response);\n                            return;\n                        }\n                        onerror();\n                    };\n                    xhr.onerror = onerror;\n                    xhr.send(null);\n                };\n            }\n        } else {}\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.error.bind(console);\n        Object.assign(Module, moduleOverrides);\n        moduleOverrides = null;\n        if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n        if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n        if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n        var wasmBinary;\n        if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        if (typeof WebAssembly != \"object\") {\n            abort(\"no native wasm support detected\");\n        }\n        var wasmMemory;\n        var ABORT = false;\n        var EXITSTATUS;\n        function assert(condition, text) {\n            if (!condition) {\n                abort(text);\n            }\n        }\n        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n            Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n            Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n            Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n            Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n            Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n            Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n            Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n        }\n        var __ATPRERUN__ = [];\n        var __ATINIT__ = [];\n        var __ATPOSTRUN__ = [];\n        var runtimeInitialized = false;\n        function preRun() {\n            if (Module[\"preRun\"]) {\n                if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [\n                    Module[\"preRun\"]\n                ];\n                while(Module[\"preRun\"].length){\n                    addOnPreRun(Module[\"preRun\"].shift());\n                }\n            }\n            callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n            runtimeInitialized = true;\n            if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n            FS.ignorePermissions = false;\n            TTY.init();\n            callRuntimeCallbacks(__ATINIT__);\n        }\n        function postRun() {\n            if (Module[\"postRun\"]) {\n                if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [\n                    Module[\"postRun\"]\n                ];\n                while(Module[\"postRun\"].length){\n                    addOnPostRun(Module[\"postRun\"].shift());\n                }\n            }\n            callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n            __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n            __ATINIT__.unshift(cb);\n        }\n        function addOnPostRun(cb) {\n            __ATPOSTRUN__.unshift(cb);\n        }\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null;\n        function getUniqueRunDependency(id) {\n            return id;\n        }\n        function addRunDependency(id) {\n            runDependencies++;\n            if (Module[\"monitorRunDependencies\"]) {\n                Module[\"monitorRunDependencies\"](runDependencies);\n            }\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            if (Module[\"monitorRunDependencies\"]) {\n                Module[\"monitorRunDependencies\"](runDependencies);\n            }\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback();\n                }\n            }\n        }\n        function abort(what) {\n            if (Module[\"onAbort\"]) {\n                Module[\"onAbort\"](what);\n            }\n            what = \"Aborted(\" + what + \")\";\n            err(what);\n            ABORT = true;\n            EXITSTATUS = 1;\n            what += \". Build with -sASSERTIONS for more info.\";\n            var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject(e);\n            throw e;\n        }\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        function isDataURI(filename) {\n            return filename.startsWith(dataURIPrefix);\n        }\n        var wasmBinaryFile;\n        wasmBinaryFile = \"process.wasm\";\n        if (!isDataURI(wasmBinaryFile)) {\n            wasmBinaryFile = locateFile(wasmBinaryFile);\n        }\n        function getBinarySync(file) {\n            if (file == wasmBinaryFile && wasmBinary) {\n                return new Uint8Array(wasmBinary);\n            }\n            if (readBinary) {\n                return readBinary(file);\n            }\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function getBinaryPromise(binaryFile) {\n            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n                if (typeof fetch == \"function\") {\n                    return fetch(binaryFile, {\n                        credentials: \"same-origin\"\n                    }).then((response)=>{\n                        if (!response[\"ok\"]) {\n                            throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n                        }\n                        return response[\"arrayBuffer\"]();\n                    }).catch(()=>getBinarySync(binaryFile));\n                }\n            }\n            return Promise.resolve().then(()=>getBinarySync(binaryFile));\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n            return getBinaryPromise(binaryFile).then((binary)=>WebAssembly.instantiate(binary, imports)).then((instance)=>instance).then(receiver, (reason)=>{\n                err(\"failed to asynchronously prepare wasm: \".concat(reason));\n                abort(reason);\n            });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n            if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && typeof fetch == \"function\") {\n                return fetch(binaryFile, {\n                    credentials: \"same-origin\"\n                }).then((response)=>{\n                    var result = WebAssembly.instantiateStreaming(response, imports);\n                    return result.then(callback, function(reason) {\n                        err(\"wasm streaming compile failed: \".concat(reason));\n                        err(\"falling back to ArrayBuffer instantiation\");\n                        return instantiateArrayBuffer(binaryFile, imports, callback);\n                    });\n                });\n            }\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        function createWasm() {\n            var info = {\n                \"a\": wasmImports\n            };\n            function receiveInstance(instance, module) {\n                wasmExports = instance.exports;\n                wasmMemory = wasmExports[\"K\"];\n                updateMemoryViews();\n                wasmTable = wasmExports[\"O\"];\n                addOnInit(wasmExports[\"L\"]);\n                removeRunDependency(\"wasm-instantiate\");\n                return wasmExports;\n            }\n            addRunDependency(\"wasm-instantiate\");\n            function receiveInstantiationResult(result) {\n                receiveInstance(result[\"instance\"]);\n            }\n            if (Module[\"instantiateWasm\"]) {\n                try {\n                    return Module[\"instantiateWasm\"](info, receiveInstance);\n                } catch (e) {\n                    err(\"Module.instantiateWasm callback failed with error: \".concat(e));\n                    readyPromiseReject(e);\n                }\n            }\n            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n            return {};\n        }\n        var tempDouble;\n        var tempI64;\n        var callRuntimeCallbacks = (callbacks)=>{\n            while(callbacks.length > 0){\n                callbacks.shift()(Module);\n            }\n        };\n        function ExceptionInfo(excPtr) {\n            this.excPtr = excPtr;\n            this.ptr = excPtr - 24;\n            this.set_type = function(type) {\n                HEAPU32[this.ptr + 4 >> 2] = type;\n            };\n            this.get_type = function() {\n                return HEAPU32[this.ptr + 4 >> 2];\n            };\n            this.set_destructor = function(destructor) {\n                HEAPU32[this.ptr + 8 >> 2] = destructor;\n            };\n            this.get_destructor = function() {\n                return HEAPU32[this.ptr + 8 >> 2];\n            };\n            this.set_caught = function(caught) {\n                caught = caught ? 1 : 0;\n                HEAP8[this.ptr + 12 >> 0] = caught;\n            };\n            this.get_caught = function() {\n                return HEAP8[this.ptr + 12 >> 0] != 0;\n            };\n            this.set_rethrown = function(rethrown) {\n                rethrown = rethrown ? 1 : 0;\n                HEAP8[this.ptr + 13 >> 0] = rethrown;\n            };\n            this.get_rethrown = function() {\n                return HEAP8[this.ptr + 13 >> 0] != 0;\n            };\n            this.init = function(type, destructor) {\n                this.set_adjusted_ptr(0);\n                this.set_type(type);\n                this.set_destructor(destructor);\n            };\n            this.set_adjusted_ptr = function(adjustedPtr) {\n                HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n            };\n            this.get_adjusted_ptr = function() {\n                return HEAPU32[this.ptr + 16 >> 2];\n            };\n            this.get_exception_ptr = function() {\n                var isPointer = ___cxa_is_pointer_type(this.get_type());\n                if (isPointer) {\n                    return HEAPU32[this.excPtr >> 2];\n                }\n                var adjusted = this.get_adjusted_ptr();\n                if (adjusted !== 0) return adjusted;\n                return this.excPtr;\n            };\n        }\n        var exceptionLast = 0;\n        var uncaughtExceptionCount = 0;\n        var ___cxa_throw = (ptr, type, destructor)=>{\n            var info = new ExceptionInfo(ptr);\n            info.init(type, destructor);\n            exceptionLast = ptr;\n            uncaughtExceptionCount++;\n            throw exceptionLast;\n        };\n        var tupleRegistrations = {};\n        var runDestructors = (destructors)=>{\n            while(destructors.length){\n                var ptr = destructors.pop();\n                var del = destructors.pop();\n                del(ptr);\n            }\n        };\n        function simpleReadValueFromPointer(pointer) {\n            return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n        }\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var InternalError;\n        var throwInternalError = (message)=>{\n            throw new InternalError(message);\n        };\n        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters)=>{\n            myTypes.forEach(function(type) {\n                typeDependencies[type] = dependentTypes;\n            });\n            function onComplete(typeConverters) {\n                var myTypeConverters = getTypeConverters(typeConverters);\n                if (myTypeConverters.length !== myTypes.length) {\n                    throwInternalError(\"Mismatched type converter count\");\n                }\n                for(var i = 0; i < myTypes.length; ++i){\n                    registerType(myTypes[i], myTypeConverters[i]);\n                }\n            }\n            var typeConverters = new Array(dependentTypes.length);\n            var unregisteredTypes = [];\n            var registered = 0;\n            dependentTypes.forEach((dt, i)=>{\n                if (registeredTypes.hasOwnProperty(dt)) {\n                    typeConverters[i] = registeredTypes[dt];\n                } else {\n                    unregisteredTypes.push(dt);\n                    if (!awaitingDependencies.hasOwnProperty(dt)) {\n                        awaitingDependencies[dt] = [];\n                    }\n                    awaitingDependencies[dt].push(()=>{\n                        typeConverters[i] = registeredTypes[dt];\n                        ++registered;\n                        if (registered === unregisteredTypes.length) {\n                            onComplete(typeConverters);\n                        }\n                    });\n                }\n            });\n            if (0 === unregisteredTypes.length) {\n                onComplete(typeConverters);\n            }\n        };\n        var __embind_finalize_value_array = (rawTupleType)=>{\n            var reg = tupleRegistrations[rawTupleType];\n            delete tupleRegistrations[rawTupleType];\n            var elements = reg.elements;\n            var elementsLength = elements.length;\n            var elementTypes = elements.map((elt)=>elt.getterReturnType).concat(elements.map((elt)=>elt.setterArgumentType));\n            var rawConstructor = reg.rawConstructor;\n            var rawDestructor = reg.rawDestructor;\n            whenDependentTypesAreResolved([\n                rawTupleType\n            ], elementTypes, function(elementTypes) {\n                elements.forEach((elt, i)=>{\n                    var getterReturnType = elementTypes[i];\n                    var getter = elt.getter;\n                    var getterContext = elt.getterContext;\n                    var setterArgumentType = elementTypes[i + elementsLength];\n                    var setter = elt.setter;\n                    var setterContext = elt.setterContext;\n                    elt.read = (ptr)=>getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n                    elt.write = (ptr, o)=>{\n                        var destructors = [];\n                        setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n                        runDestructors(destructors);\n                    };\n                });\n                return [\n                    {\n                        name: reg.name,\n                        \"fromWireType\": (ptr)=>{\n                            var rv = new Array(elementsLength);\n                            for(var i = 0; i < elementsLength; ++i){\n                                rv[i] = elements[i].read(ptr);\n                            }\n                            rawDestructor(ptr);\n                            return rv;\n                        },\n                        \"toWireType\": (destructors, o)=>{\n                            if (elementsLength !== o.length) {\n                                throw new TypeError(\"Incorrect number of tuple elements for \".concat(reg.name, \": expected=\").concat(elementsLength, \", actual=\").concat(o.length));\n                            }\n                            var ptr = rawConstructor();\n                            for(var i = 0; i < elementsLength; ++i){\n                                elements[i].write(ptr, o[i]);\n                            }\n                            if (destructors !== null) {\n                                destructors.push(rawDestructor, ptr);\n                            }\n                            return ptr;\n                        },\n                        \"argPackAdvance\": GenericWireTypeSize,\n                        \"readValueFromPointer\": simpleReadValueFromPointer,\n                        destructorFunction: rawDestructor\n                    }\n                ];\n            });\n        };\n        var structRegistrations = {};\n        var __embind_finalize_value_object = (structType)=>{\n            var reg = structRegistrations[structType];\n            delete structRegistrations[structType];\n            var rawConstructor = reg.rawConstructor;\n            var rawDestructor = reg.rawDestructor;\n            var fieldRecords = reg.fields;\n            var fieldTypes = fieldRecords.map((field)=>field.getterReturnType).concat(fieldRecords.map((field)=>field.setterArgumentType));\n            whenDependentTypesAreResolved([\n                structType\n            ], fieldTypes, (fieldTypes)=>{\n                var fields = {};\n                fieldRecords.forEach((field, i)=>{\n                    var fieldName = field.fieldName;\n                    var getterReturnType = fieldTypes[i];\n                    var getter = field.getter;\n                    var getterContext = field.getterContext;\n                    var setterArgumentType = fieldTypes[i + fieldRecords.length];\n                    var setter = field.setter;\n                    var setterContext = field.setterContext;\n                    fields[fieldName] = {\n                        read: (ptr)=>getterReturnType[\"fromWireType\"](getter(getterContext, ptr)),\n                        write: (ptr, o)=>{\n                            var destructors = [];\n                            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n                            runDestructors(destructors);\n                        }\n                    };\n                });\n                return [\n                    {\n                        name: reg.name,\n                        \"fromWireType\": (ptr)=>{\n                            var rv = {};\n                            for(var i in fields){\n                                rv[i] = fields[i].read(ptr);\n                            }\n                            rawDestructor(ptr);\n                            return rv;\n                        },\n                        \"toWireType\": (destructors, o)=>{\n                            for(var fieldName in fields){\n                                if (!(fieldName in o)) {\n                                    throw new TypeError('Missing field: \"'.concat(fieldName, '\"'));\n                                }\n                            }\n                            var ptr = rawConstructor();\n                            for(fieldName in fields){\n                                fields[fieldName].write(ptr, o[fieldName]);\n                            }\n                            if (destructors !== null) {\n                                destructors.push(rawDestructor, ptr);\n                            }\n                            return ptr;\n                        },\n                        \"argPackAdvance\": GenericWireTypeSize,\n                        \"readValueFromPointer\": simpleReadValueFromPointer,\n                        destructorFunction: rawDestructor\n                    }\n                ];\n            });\n        };\n        var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange)=>{};\n        var embind_init_charCodes = ()=>{\n            var codes = new Array(256);\n            for(var i = 0; i < 256; ++i){\n                codes[i] = String.fromCharCode(i);\n            }\n            embind_charCodes = codes;\n        };\n        var embind_charCodes;\n        var readLatin1String = (ptr)=>{\n            var ret = \"\";\n            var c = ptr;\n            while(HEAPU8[c]){\n                ret += embind_charCodes[HEAPU8[c++]];\n            }\n            return ret;\n        };\n        var BindingError;\n        var throwBindingError = (message)=>{\n            throw new BindingError(message);\n        };\n        function sharedRegisterType(rawType, registeredInstance) {\n            let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            var name = registeredInstance.name;\n            if (!rawType) {\n                throwBindingError('type \"'.concat(name, '\" must have a positive integer typeid pointer'));\n            }\n            if (registeredTypes.hasOwnProperty(rawType)) {\n                if (options.ignoreDuplicateRegistrations) {\n                    return;\n                } else {\n                    throwBindingError(\"Cannot register type '\".concat(name, \"' twice\"));\n                }\n            }\n            registeredTypes[rawType] = registeredInstance;\n            delete typeDependencies[rawType];\n            if (awaitingDependencies.hasOwnProperty(rawType)) {\n                var callbacks = awaitingDependencies[rawType];\n                delete awaitingDependencies[rawType];\n                callbacks.forEach((cb)=>cb());\n            }\n        }\n        function registerType(rawType, registeredInstance) {\n            let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (!(\"argPackAdvance\" in registeredInstance)) {\n                throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            }\n            return sharedRegisterType(rawType, registeredInstance, options);\n        }\n        var GenericWireTypeSize = 8;\n        var __embind_register_bool = (rawType, name, trueValue, falseValue)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(wt) {\n                    return !!wt;\n                },\n                \"toWireType\": function(destructors, o) {\n                    return o ? trueValue : falseValue;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": function(pointer) {\n                    return this[\"fromWireType\"](HEAPU8[pointer]);\n                },\n                destructorFunction: null\n            });\n        };\n        var shallowCopyInternalPointer = (o)=>({\n                count: o.count,\n                deleteScheduled: o.deleteScheduled,\n                preservePointerOnDelete: o.preservePointerOnDelete,\n                ptr: o.ptr,\n                ptrType: o.ptrType,\n                smartPtr: o.smartPtr,\n                smartPtrType: o.smartPtrType\n            });\n        var throwInstanceAlreadyDeleted = (obj)=>{\n            function getInstanceTypeName(handle) {\n                return handle.$$.ptrType.registeredClass.name;\n            }\n            throwBindingError(getInstanceTypeName(obj) + \" instance already deleted\");\n        };\n        var finalizationRegistry = false;\n        var detachFinalizer = (handle)=>{};\n        var runDestructor = ($$)=>{\n            if ($$.smartPtr) {\n                $$.smartPtrType.rawDestructor($$.smartPtr);\n            } else {\n                $$.ptrType.registeredClass.rawDestructor($$.ptr);\n            }\n        };\n        var releaseClassHandle = ($$)=>{\n            $$.count.value -= 1;\n            var toDelete = 0 === $$.count.value;\n            if (toDelete) {\n                runDestructor($$);\n            }\n        };\n        var downcastPointer = (ptr, ptrClass, desiredClass)=>{\n            if (ptrClass === desiredClass) {\n                return ptr;\n            }\n            if (undefined === desiredClass.baseClass) {\n                return null;\n            }\n            var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\n            if (rv === null) {\n                return null;\n            }\n            return desiredClass.downcast(rv);\n        };\n        var registeredPointers = {};\n        var getInheritedInstanceCount = ()=>Object.keys(registeredInstances).length;\n        var getLiveInheritedInstances = ()=>{\n            var rv = [];\n            for(var k in registeredInstances){\n                if (registeredInstances.hasOwnProperty(k)) {\n                    rv.push(registeredInstances[k]);\n                }\n            }\n            return rv;\n        };\n        var deletionQueue = [];\n        var flushPendingDeletes = ()=>{\n            while(deletionQueue.length){\n                var obj = deletionQueue.pop();\n                obj.$$.deleteScheduled = false;\n                obj[\"delete\"]();\n            }\n        };\n        var delayFunction;\n        var setDelayFunction = (fn)=>{\n            delayFunction = fn;\n            if (deletionQueue.length && delayFunction) {\n                delayFunction(flushPendingDeletes);\n            }\n        };\n        var init_embind = ()=>{\n            Module[\"getInheritedInstanceCount\"] = getInheritedInstanceCount;\n            Module[\"getLiveInheritedInstances\"] = getLiveInheritedInstances;\n            Module[\"flushPendingDeletes\"] = flushPendingDeletes;\n            Module[\"setDelayFunction\"] = setDelayFunction;\n        };\n        var registeredInstances = {};\n        var getBasestPointer = (class_, ptr)=>{\n            if (ptr === undefined) {\n                throwBindingError(\"ptr should not be undefined\");\n            }\n            while(class_.baseClass){\n                ptr = class_.upcast(ptr);\n                class_ = class_.baseClass;\n            }\n            return ptr;\n        };\n        var getInheritedInstance = (class_, ptr)=>{\n            ptr = getBasestPointer(class_, ptr);\n            return registeredInstances[ptr];\n        };\n        var makeClassHandle = (prototype, record)=>{\n            if (!record.ptrType || !record.ptr) {\n                throwInternalError(\"makeClassHandle requires ptr and ptrType\");\n            }\n            var hasSmartPtrType = !!record.smartPtrType;\n            var hasSmartPtr = !!record.smartPtr;\n            if (hasSmartPtrType !== hasSmartPtr) {\n                throwInternalError(\"Both smartPtrType and smartPtr must be specified\");\n            }\n            record.count = {\n                value: 1\n            };\n            return attachFinalizer(Object.create(prototype, {\n                $$: {\n                    value: record\n                }\n            }));\n        };\n        function RegisteredPointer_fromWireType(ptr) {\n            var rawPointer = this.getPointee(ptr);\n            if (!rawPointer) {\n                this.destructor(ptr);\n                return null;\n            }\n            var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\n            if (undefined !== registeredInstance) {\n                if (0 === registeredInstance.$$.count.value) {\n                    registeredInstance.$$.ptr = rawPointer;\n                    registeredInstance.$$.smartPtr = ptr;\n                    return registeredInstance[\"clone\"]();\n                } else {\n                    var rv = registeredInstance[\"clone\"]();\n                    this.destructor(ptr);\n                    return rv;\n                }\n            }\n            function makeDefaultHandle() {\n                if (this.isSmartPointer) {\n                    return makeClassHandle(this.registeredClass.instancePrototype, {\n                        ptrType: this.pointeeType,\n                        ptr: rawPointer,\n                        smartPtrType: this,\n                        smartPtr: ptr\n                    });\n                } else {\n                    return makeClassHandle(this.registeredClass.instancePrototype, {\n                        ptrType: this,\n                        ptr: ptr\n                    });\n                }\n            }\n            var actualType = this.registeredClass.getActualType(rawPointer);\n            var registeredPointerRecord = registeredPointers[actualType];\n            if (!registeredPointerRecord) {\n                return makeDefaultHandle.call(this);\n            }\n            var toType;\n            if (this.isConst) {\n                toType = registeredPointerRecord.constPointerType;\n            } else {\n                toType = registeredPointerRecord.pointerType;\n            }\n            var dp = downcastPointer(rawPointer, this.registeredClass, toType.registeredClass);\n            if (dp === null) {\n                return makeDefaultHandle.call(this);\n            }\n            if (this.isSmartPointer) {\n                return makeClassHandle(toType.registeredClass.instancePrototype, {\n                    ptrType: toType,\n                    ptr: dp,\n                    smartPtrType: this,\n                    smartPtr: ptr\n                });\n            } else {\n                return makeClassHandle(toType.registeredClass.instancePrototype, {\n                    ptrType: toType,\n                    ptr: dp\n                });\n            }\n        }\n        var attachFinalizer = (handle)=>{\n            if (\"undefined\" === typeof FinalizationRegistry) {\n                attachFinalizer = (handle)=>handle;\n                return handle;\n            }\n            finalizationRegistry = new FinalizationRegistry((info)=>{\n                releaseClassHandle(info.$$);\n            });\n            attachFinalizer = (handle)=>{\n                var $$ = handle.$$;\n                var hasSmartPtr = !!$$.smartPtr;\n                if (hasSmartPtr) {\n                    var info = {\n                        $$: $$\n                    };\n                    finalizationRegistry.register(handle, info, handle);\n                }\n                return handle;\n            };\n            detachFinalizer = (handle)=>finalizationRegistry.unregister(handle);\n            return attachFinalizer(handle);\n        };\n        var init_ClassHandle = ()=>{\n            Object.assign(ClassHandle.prototype, {\n                \"isAliasOf\" (other) {\n                    if (!(this instanceof ClassHandle)) {\n                        return false;\n                    }\n                    if (!(other instanceof ClassHandle)) {\n                        return false;\n                    }\n                    var leftClass = this.$$.ptrType.registeredClass;\n                    var left = this.$$.ptr;\n                    other.$$ = other.$$;\n                    var rightClass = other.$$.ptrType.registeredClass;\n                    var right = other.$$.ptr;\n                    while(leftClass.baseClass){\n                        left = leftClass.upcast(left);\n                        leftClass = leftClass.baseClass;\n                    }\n                    while(rightClass.baseClass){\n                        right = rightClass.upcast(right);\n                        rightClass = rightClass.baseClass;\n                    }\n                    return leftClass === rightClass && left === right;\n                },\n                \"clone\" () {\n                    if (!this.$$.ptr) {\n                        throwInstanceAlreadyDeleted(this);\n                    }\n                    if (this.$$.preservePointerOnDelete) {\n                        this.$$.count.value += 1;\n                        return this;\n                    } else {\n                        var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\n                            $$: {\n                                value: shallowCopyInternalPointer(this.$$)\n                            }\n                        }));\n                        clone.$$.count.value += 1;\n                        clone.$$.deleteScheduled = false;\n                        return clone;\n                    }\n                },\n                \"delete\" () {\n                    if (!this.$$.ptr) {\n                        throwInstanceAlreadyDeleted(this);\n                    }\n                    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n                        throwBindingError(\"Object already scheduled for deletion\");\n                    }\n                    detachFinalizer(this);\n                    releaseClassHandle(this.$$);\n                    if (!this.$$.preservePointerOnDelete) {\n                        this.$$.smartPtr = undefined;\n                        this.$$.ptr = undefined;\n                    }\n                },\n                \"isDeleted\" () {\n                    return !this.$$.ptr;\n                },\n                \"deleteLater\" () {\n                    if (!this.$$.ptr) {\n                        throwInstanceAlreadyDeleted(this);\n                    }\n                    if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\n                        throwBindingError(\"Object already scheduled for deletion\");\n                    }\n                    deletionQueue.push(this);\n                    if (deletionQueue.length === 1 && delayFunction) {\n                        delayFunction(flushPendingDeletes);\n                    }\n                    this.$$.deleteScheduled = true;\n                    return this;\n                }\n            });\n        };\n        function ClassHandle() {}\n        var char_0 = 48;\n        var char_9 = 57;\n        var makeLegalFunctionName = (name)=>{\n            if (undefined === name) {\n                return \"_unknown\";\n            }\n            name = name.replace(/[^a-zA-Z0-9_]/g, \"$\");\n            var f = name.charCodeAt(0);\n            if (f >= char_0 && f <= char_9) {\n                return \"_\".concat(name);\n            }\n            return name;\n        };\n        function createNamedFunction(name, body) {\n            name = makeLegalFunctionName(name);\n            return ({\n                [name]: function() {\n                    return body.apply(this, arguments);\n                }\n            })[name];\n        }\n        var ensureOverloadTable = (proto, methodName, humanName)=>{\n            if (undefined === proto[methodName].overloadTable) {\n                var prevFunc = proto[methodName];\n                proto[methodName] = function() {\n                    if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n                        throwBindingError(\"Function '\".concat(humanName, \"' called with an invalid number of arguments (\").concat(arguments.length, \") - expects one of (\").concat(proto[methodName].overloadTable, \")!\"));\n                    }\n                    return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n                };\n                proto[methodName].overloadTable = [];\n                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n            }\n        };\n        var exposePublicSymbol = (name, value, numArguments)=>{\n            if (Module.hasOwnProperty(name)) {\n                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n                    throwBindingError(\"Cannot register public name '\".concat(name, \"' twice\"));\n                }\n                ensureOverloadTable(Module, name, name);\n                if (Module.hasOwnProperty(numArguments)) {\n                    throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\".concat(numArguments, \")!\"));\n                }\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                if (undefined !== numArguments) {\n                    Module[name].numArguments = numArguments;\n                }\n            }\n        };\n        function RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {\n            this.name = name;\n            this.constructor = constructor;\n            this.instancePrototype = instancePrototype;\n            this.rawDestructor = rawDestructor;\n            this.baseClass = baseClass;\n            this.getActualType = getActualType;\n            this.upcast = upcast;\n            this.downcast = downcast;\n            this.pureVirtualFunctions = [];\n        }\n        var upcastPointer = (ptr, ptrClass, desiredClass)=>{\n            while(ptrClass !== desiredClass){\n                if (!ptrClass.upcast) {\n                    throwBindingError(\"Expected null or instance of \".concat(desiredClass.name, \", got an instance of \").concat(ptrClass.name));\n                }\n                ptr = ptrClass.upcast(ptr);\n                ptrClass = ptrClass.baseClass;\n            }\n            return ptr;\n        };\n        function constNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) {\n                    throwBindingError(\"null is not a valid \".concat(this.name));\n                }\n                return 0;\n            }\n            if (!handle.$$) {\n                throwBindingError('Cannot pass \"'.concat(embindRepr(handle), '\" as a ').concat(this.name));\n            }\n            if (!handle.$$.ptr) {\n                throwBindingError(\"Cannot pass deleted object as a pointer of type \".concat(this.name));\n            }\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        function genericPointerToWireType(destructors, handle) {\n            var ptr;\n            if (handle === null) {\n                if (this.isReference) {\n                    throwBindingError(\"null is not a valid \".concat(this.name));\n                }\n                if (this.isSmartPointer) {\n                    ptr = this.rawConstructor();\n                    if (destructors !== null) {\n                        destructors.push(this.rawDestructor, ptr);\n                    }\n                    return ptr;\n                } else {\n                    return 0;\n                }\n            }\n            if (!handle.$$) {\n                throwBindingError('Cannot pass \"'.concat(embindRepr(handle), '\" as a ').concat(this.name));\n            }\n            if (!handle.$$.ptr) {\n                throwBindingError(\"Cannot pass deleted object as a pointer of type \".concat(this.name));\n            }\n            if (!this.isConst && handle.$$.ptrType.isConst) {\n                throwBindingError(\"Cannot convert argument of type \".concat(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name, \" to parameter type \").concat(this.name));\n            }\n            var handleClass = handle.$$.ptrType.registeredClass;\n            ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            if (this.isSmartPointer) {\n                if (undefined === handle.$$.smartPtr) {\n                    throwBindingError(\"Passing raw pointer to smart pointer is illegal\");\n                }\n                switch(this.sharingPolicy){\n                    case 0:\n                        if (handle.$$.smartPtrType === this) {\n                            ptr = handle.$$.smartPtr;\n                        } else {\n                            throwBindingError(\"Cannot convert argument of type \".concat(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name, \" to parameter type \").concat(this.name));\n                        }\n                        break;\n                    case 1:\n                        ptr = handle.$$.smartPtr;\n                        break;\n                    case 2:\n                        if (handle.$$.smartPtrType === this) {\n                            ptr = handle.$$.smartPtr;\n                        } else {\n                            var clonedHandle = handle[\"clone\"]();\n                            ptr = this.rawShare(ptr, Emval.toHandle(()=>clonedHandle[\"delete\"]()));\n                            if (destructors !== null) {\n                                destructors.push(this.rawDestructor, ptr);\n                            }\n                        }\n                        break;\n                    default:\n                        throwBindingError(\"Unsupporting sharing policy\");\n                }\n            }\n            return ptr;\n        }\n        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\n            if (handle === null) {\n                if (this.isReference) {\n                    throwBindingError(\"null is not a valid \".concat(this.name));\n                }\n                return 0;\n            }\n            if (!handle.$$) {\n                throwBindingError('Cannot pass \"'.concat(embindRepr(handle), '\" as a ').concat(this.name));\n            }\n            if (!handle.$$.ptr) {\n                throwBindingError(\"Cannot pass deleted object as a pointer of type \".concat(this.name));\n            }\n            if (handle.$$.ptrType.isConst) {\n                throwBindingError(\"Cannot convert argument of type \".concat(handle.$$.ptrType.name, \" to parameter type \").concat(this.name));\n            }\n            var handleClass = handle.$$.ptrType.registeredClass;\n            var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\n            return ptr;\n        }\n        function readPointer(pointer) {\n            return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n        }\n        var init_RegisteredPointer = ()=>{\n            Object.assign(RegisteredPointer.prototype, {\n                getPointee (ptr) {\n                    if (this.rawGetPointee) {\n                        ptr = this.rawGetPointee(ptr);\n                    }\n                    return ptr;\n                },\n                destructor (ptr) {\n                    if (this.rawDestructor) {\n                        this.rawDestructor(ptr);\n                    }\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": readPointer,\n                \"deleteObject\" (handle) {\n                    if (handle !== null) {\n                        handle[\"delete\"]();\n                    }\n                },\n                \"fromWireType\": RegisteredPointer_fromWireType\n            });\n        };\n        function RegisteredPointer(name, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {\n            this.name = name;\n            this.registeredClass = registeredClass;\n            this.isReference = isReference;\n            this.isConst = isConst;\n            this.isSmartPointer = isSmartPointer;\n            this.pointeeType = pointeeType;\n            this.sharingPolicy = sharingPolicy;\n            this.rawGetPointee = rawGetPointee;\n            this.rawConstructor = rawConstructor;\n            this.rawShare = rawShare;\n            this.rawDestructor = rawDestructor;\n            if (!isSmartPointer && registeredClass.baseClass === undefined) {\n                if (isConst) {\n                    this[\"toWireType\"] = constNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                } else {\n                    this[\"toWireType\"] = nonConstNoSmartPtrRawPointerToWireType;\n                    this.destructorFunction = null;\n                }\n            } else {\n                this[\"toWireType\"] = genericPointerToWireType;\n            }\n        }\n        var replacePublicSymbol = (name, value, numArguments)=>{\n            if (!Module.hasOwnProperty(name)) {\n                throwInternalError(\"Replacing nonexistant public symbol\");\n            }\n            if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var dynCallLegacy = (sig, ptr, args)=>{\n            var f = Module[\"dynCall_\" + sig];\n            return args && args.length ? f.apply(null, [\n                ptr\n            ].concat(args)) : f.call(null, ptr);\n        };\n        var wasmTableMirror = [];\n        var wasmTable;\n        var getWasmTableEntry = (funcPtr)=>{\n            var func = wasmTableMirror[funcPtr];\n            if (!func) {\n                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            }\n            return func;\n        };\n        var dynCall = (sig, ptr, args)=>{\n            if (sig.includes(\"j\")) {\n                return dynCallLegacy(sig, ptr, args);\n            }\n            var rtn = getWasmTableEntry(ptr).apply(null, args);\n            return rtn;\n        };\n        var getDynCaller = (sig, ptr)=>{\n            var argCache = [];\n            return function() {\n                argCache.length = 0;\n                Object.assign(argCache, arguments);\n                return dynCall(sig, ptr, argCache);\n            };\n        };\n        var embind__requireFunction = (signature, rawFunction)=>{\n            signature = readLatin1String(signature);\n            function makeDynCaller() {\n                if (signature.includes(\"j\")) {\n                    return getDynCaller(signature, rawFunction);\n                }\n                return getWasmTableEntry(rawFunction);\n            }\n            var fp = makeDynCaller();\n            if (typeof fp != \"function\") {\n                throwBindingError(\"unknown function pointer with signature \".concat(signature, \": \").concat(rawFunction));\n            }\n            return fp;\n        };\n        var extendError = (baseErrorType, errorName)=>{\n            var errorClass = createNamedFunction(errorName, function(message) {\n                this.name = errorName;\n                this.message = message;\n                var stack = new Error(message).stack;\n                if (stack !== undefined) {\n                    this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n                }\n            });\n            errorClass.prototype = Object.create(baseErrorType.prototype);\n            errorClass.prototype.constructor = errorClass;\n            errorClass.prototype.toString = function() {\n                if (this.message === undefined) {\n                    return this.name;\n                } else {\n                    return \"\".concat(this.name, \": \").concat(this.message);\n                }\n            };\n            return errorClass;\n        };\n        var UnboundTypeError;\n        var getTypeName = (type)=>{\n            var ptr = ___getTypeName(type);\n            var rv = readLatin1String(ptr);\n            _free(ptr);\n            return rv;\n        };\n        var throwUnboundTypeError = (message, types)=>{\n            var unboundTypes = [];\n            var seen = {};\n            function visit(type) {\n                if (seen[type]) {\n                    return;\n                }\n                if (registeredTypes[type]) {\n                    return;\n                }\n                if (typeDependencies[type]) {\n                    typeDependencies[type].forEach(visit);\n                    return;\n                }\n                unboundTypes.push(type);\n                seen[type] = true;\n            }\n            types.forEach(visit);\n            throw new UnboundTypeError(\"\".concat(message, \": \") + unboundTypes.map(getTypeName).join([\n                \", \"\n            ]));\n        };\n        var __embind_register_class = (rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name, destructorSignature, rawDestructor)=>{\n            name = readLatin1String(name);\n            getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\n            if (upcast) {\n                upcast = embind__requireFunction(upcastSignature, upcast);\n            }\n            if (downcast) {\n                downcast = embind__requireFunction(downcastSignature, downcast);\n            }\n            rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\n            var legalFunctionName = makeLegalFunctionName(name);\n            exposePublicSymbol(legalFunctionName, function() {\n                throwUnboundTypeError(\"Cannot construct \".concat(name, \" due to unbound types\"), [\n                    baseClassRawType\n                ]);\n            });\n            whenDependentTypesAreResolved([\n                rawType,\n                rawPointerType,\n                rawConstPointerType\n            ], baseClassRawType ? [\n                baseClassRawType\n            ] : [], function(base) {\n                base = base[0];\n                var baseClass;\n                var basePrototype;\n                if (baseClassRawType) {\n                    baseClass = base.registeredClass;\n                    basePrototype = baseClass.instancePrototype;\n                } else {\n                    basePrototype = ClassHandle.prototype;\n                }\n                var constructor = createNamedFunction(legalFunctionName, function() {\n                    if (Object.getPrototypeOf(this) !== instancePrototype) {\n                        throw new BindingError(\"Use 'new' to construct \" + name);\n                    }\n                    if (undefined === registeredClass.constructor_body) {\n                        throw new BindingError(name + \" has no accessible constructor\");\n                    }\n                    var body = registeredClass.constructor_body[arguments.length];\n                    if (undefined === body) {\n                        throw new BindingError(\"Tried to invoke ctor of \".concat(name, \" with invalid number of parameters (\").concat(arguments.length, \") - expected (\").concat(Object.keys(registeredClass.constructor_body).toString(), \") parameters instead!\"));\n                    }\n                    return body.apply(this, arguments);\n                });\n                var instancePrototype = Object.create(basePrototype, {\n                    constructor: {\n                        value: constructor\n                    }\n                });\n                constructor.prototype = instancePrototype;\n                var registeredClass = new RegisteredClass(name, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast);\n                if (registeredClass.baseClass) {\n                    if (registeredClass.baseClass.__derivedClasses === undefined) {\n                        registeredClass.baseClass.__derivedClasses = [];\n                    }\n                    registeredClass.baseClass.__derivedClasses.push(registeredClass);\n                }\n                var referenceConverter = new RegisteredPointer(name, registeredClass, true, false, false);\n                var pointerConverter = new RegisteredPointer(name + \"*\", registeredClass, false, false, false);\n                var constPointerConverter = new RegisteredPointer(name + \" const*\", registeredClass, false, true, false);\n                registeredPointers[rawType] = {\n                    pointerType: pointerConverter,\n                    constPointerType: constPointerConverter\n                };\n                replacePublicSymbol(legalFunctionName, constructor);\n                return [\n                    referenceConverter,\n                    pointerConverter,\n                    constPointerConverter\n                ];\n            });\n        };\n        var heap32VectorToArray = (count, firstElement)=>{\n            var array = [];\n            for(var i = 0; i < count; i++){\n                array.push(HEAPU32[firstElement + i * 4 >> 2]);\n            }\n            return array;\n        };\n        function newFunc(constructor, argumentList) {\n            if (!(constructor instanceof Function)) {\n                throw new TypeError(\"new_ called with constructor type \".concat(typeof constructor, \" which is not a function\"));\n            }\n            var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n            dummy.prototype = constructor.prototype;\n            var obj = new dummy;\n            var r = constructor.apply(obj, argumentList);\n            return r instanceof Object ? r : obj;\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n            var argCount = argTypes.length;\n            if (argCount < 2) {\n                throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n            }\n            var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n            var needsDestructorStack = false;\n            for(var i = 1; i < argTypes.length; ++i){\n                if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n                    needsDestructorStack = true;\n                    break;\n                }\n            }\n            var returns = argTypes[0].name !== \"void\";\n            var argsList = \"\";\n            var argsListWired = \"\";\n            for(var i = 0; i < argCount - 2; ++i){\n                argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n                argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n            }\n            var invokerFnBody = \"\\n        return function \".concat(makeLegalFunctionName(humanName), \"(\").concat(argsList, \") {\\n        if (arguments.length !== \").concat(argCount - 2, \") {\\n          throwBindingError('function \").concat(humanName, \" called with ' + arguments.length + ' arguments, expected \").concat(argCount - 2, \"');\\n        }\");\n            if (needsDestructorStack) {\n                invokerFnBody += \"var destructors = [];\\n\";\n            }\n            var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n            var args1 = [\n                \"throwBindingError\",\n                \"invoker\",\n                \"fn\",\n                \"runDestructors\",\n                \"retType\",\n                \"classParam\"\n            ];\n            var args2 = [\n                throwBindingError,\n                cppInvokerFunc,\n                cppTargetFunc,\n                runDestructors,\n                argTypes[0],\n                argTypes[1]\n            ];\n            if (isClassMethodFunc) {\n                invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n            }\n            for(var i = 0; i < argCount - 2; ++i){\n                invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n                args1.push(\"argType\" + i);\n                args2.push(argTypes[i + 2]);\n            }\n            if (isClassMethodFunc) {\n                argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n            }\n            invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n            if (needsDestructorStack) {\n                invokerFnBody += \"runDestructors(destructors);\\n\";\n            } else {\n                for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){\n                    var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n                    if (argTypes[i].destructorFunction !== null) {\n                        invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n                        args1.push(paramName + \"_dtor\");\n                        args2.push(argTypes[i].destructorFunction);\n                    }\n                }\n            }\n            if (returns) {\n                invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n            } else {}\n            invokerFnBody += \"}\\n\";\n            args1.push(invokerFnBody);\n            return newFunc(Function, args1).apply(null, args2);\n        }\n        var __embind_register_class_constructor = (rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor)=>{\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            invoker = embind__requireFunction(invokerSignature, invoker);\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], function(classType) {\n                classType = classType[0];\n                var humanName = \"constructor \".concat(classType.name);\n                if (undefined === classType.registeredClass.constructor_body) {\n                    classType.registeredClass.constructor_body = [];\n                }\n                if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\n                    throw new BindingError(\"Cannot register multiple constructors with identical number of parameters (\".concat(argCount - 1, \") for class '\").concat(classType.name, \"'! Overload resolution is currently only performed using the parameter count, not actual type info!\"));\n                }\n                classType.registeredClass.constructor_body[argCount - 1] = ()=>{\n                    throwUnboundTypeError(\"Cannot construct \".concat(classType.name, \" due to unbound types\"), rawArgTypes);\n                };\n                whenDependentTypesAreResolved([], rawArgTypes, (argTypes)=>{\n                    argTypes.splice(1, 0, null);\n                    classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\n                    return [];\n                });\n                return [];\n            });\n        };\n        var __embind_register_class_function = (rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync)=>{\n            var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            methodName = readLatin1String(methodName);\n            rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\n            whenDependentTypesAreResolved([], [\n                rawClassType\n            ], function(classType) {\n                classType = classType[0];\n                var humanName = \"\".concat(classType.name, \".\").concat(methodName);\n                if (methodName.startsWith(\"@@\")) {\n                    methodName = Symbol[methodName.substring(2)];\n                }\n                if (isPureVirtual) {\n                    classType.registeredClass.pureVirtualFunctions.push(methodName);\n                }\n                function unboundTypesHandler() {\n                    throwUnboundTypeError(\"Cannot call \".concat(humanName, \" due to unbound types\"), rawArgTypes);\n                }\n                var proto = classType.registeredClass.instancePrototype;\n                var method = proto[methodName];\n                if (undefined === method || undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {\n                    unboundTypesHandler.argCount = argCount - 2;\n                    unboundTypesHandler.className = classType.name;\n                    proto[methodName] = unboundTypesHandler;\n                } else {\n                    ensureOverloadTable(proto, methodName, humanName);\n                    proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\n                }\n                whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {\n                    var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\n                    if (undefined === proto[methodName].overloadTable) {\n                        memberFunction.argCount = argCount - 2;\n                        proto[methodName] = memberFunction;\n                    } else {\n                        proto[methodName].overloadTable[argCount - 2] = memberFunction;\n                    }\n                    return [];\n                });\n                return [];\n            });\n        };\n        var validateThis = (this_, classType, humanName)=>{\n            if (!(this_ instanceof Object)) {\n                throwBindingError(\"\".concat(humanName, ' with invalid \"this\": ').concat(this_));\n            }\n            if (!(this_ instanceof classType.registeredClass.constructor)) {\n                throwBindingError(\"\".concat(humanName, ' incompatible with \"this\" of type ').concat(this_.constructor.name));\n            }\n            if (!this_.$$.ptr) {\n                throwBindingError(\"cannot call emscripten binding method \".concat(humanName, \" on deleted object\"));\n            }\n            return upcastPointer(this_.$$.ptr, this_.$$.ptrType.registeredClass, classType.registeredClass);\n        };\n        var __embind_register_class_property = (classType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext)=>{\n            fieldName = readLatin1String(fieldName);\n            getter = embind__requireFunction(getterSignature, getter);\n            whenDependentTypesAreResolved([], [\n                classType\n            ], function(classType) {\n                classType = classType[0];\n                var humanName = \"\".concat(classType.name, \".\").concat(fieldName);\n                var desc = {\n                    get () {\n                        throwUnboundTypeError(\"Cannot access \".concat(humanName, \" due to unbound types\"), [\n                            getterReturnType,\n                            setterArgumentType\n                        ]);\n                    },\n                    enumerable: true,\n                    configurable: true\n                };\n                if (setter) {\n                    desc.set = ()=>throwUnboundTypeError(\"Cannot access \".concat(humanName, \" due to unbound types\"), [\n                            getterReturnType,\n                            setterArgumentType\n                        ]);\n                } else {\n                    desc.set = (v)=>throwBindingError(humanName + \" is a read-only property\");\n                }\n                Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n                whenDependentTypesAreResolved([], setter ? [\n                    getterReturnType,\n                    setterArgumentType\n                ] : [\n                    getterReturnType\n                ], function(types) {\n                    var getterReturnType = types[0];\n                    var desc = {\n                        get () {\n                            var ptr = validateThis(this, classType, humanName + \" getter\");\n                            return getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n                        },\n                        enumerable: true\n                    };\n                    if (setter) {\n                        setter = embind__requireFunction(setterSignature, setter);\n                        var setterArgumentType = types[1];\n                        desc.set = function(v) {\n                            var ptr = validateThis(this, classType, humanName + \" setter\");\n                            var destructors = [];\n                            setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, v));\n                            runDestructors(destructors);\n                        };\n                    }\n                    Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);\n                    return [];\n                });\n                return [];\n            });\n        };\n        function handleAllocatorInit() {\n            Object.assign(HandleAllocator.prototype, {\n                get (id) {\n                    return this.allocated[id];\n                },\n                has (id) {\n                    return this.allocated[id] !== undefined;\n                },\n                allocate (handle) {\n                    var id = this.freelist.pop() || this.allocated.length;\n                    this.allocated[id] = handle;\n                    return id;\n                },\n                free (id) {\n                    this.allocated[id] = undefined;\n                    this.freelist.push(id);\n                }\n            });\n        }\n        function HandleAllocator() {\n            this.allocated = [\n                undefined\n            ];\n            this.freelist = [];\n        }\n        var emval_handles = new HandleAllocator;\n        var __emval_decref = (handle)=>{\n            if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\n                emval_handles.free(handle);\n            }\n        };\n        var count_emval_handles = ()=>{\n            var count = 0;\n            for(var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i){\n                if (emval_handles.allocated[i] !== undefined) {\n                    ++count;\n                }\n            }\n            return count;\n        };\n        var init_emval = ()=>{\n            emval_handles.allocated.push({\n                value: undefined\n            }, {\n                value: null\n            }, {\n                value: true\n            }, {\n                value: false\n            });\n            emval_handles.reserved = emval_handles.allocated.length;\n            Module[\"count_emval_handles\"] = count_emval_handles;\n        };\n        var Emval = {\n            toValue: (handle)=>{\n                if (!handle) {\n                    throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n                }\n                return emval_handles.get(handle).value;\n            },\n            toHandle: (value)=>{\n                switch(value){\n                    case undefined:\n                        return 1;\n                    case null:\n                        return 2;\n                    case true:\n                        return 3;\n                    case false:\n                        return 4;\n                    default:\n                        {\n                            return emval_handles.allocate({\n                                refcount: 1,\n                                value: value\n                            });\n                        }\n                }\n            }\n        };\n        var __embind_register_emval = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (handle)=>{\n                    var rv = Emval.toValue(handle);\n                    __emval_decref(handle);\n                    return rv;\n                },\n                \"toWireType\": (destructors, value)=>Emval.toHandle(value),\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction: null\n            });\n        };\n        var enumReadValueFromPointer = (name, width, signed)=>{\n            switch(width){\n                case 1:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](HEAP8[pointer >> 0]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](HEAPU8[pointer >> 0]);\n                    };\n                case 2:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](HEAP16[pointer >> 1]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](HEAPU16[pointer >> 1]);\n                    };\n                case 4:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n                    };\n                default:\n                    throw new TypeError(\"invalid integer width (\".concat(width, \"): \").concat(name));\n            }\n        };\n        var __embind_register_enum = (rawType, name, size, isSigned)=>{\n            name = readLatin1String(name);\n            function ctor() {}\n            ctor.values = {};\n            registerType(rawType, {\n                name: name,\n                constructor: ctor,\n                \"fromWireType\": function(c) {\n                    return this.constructor.values[c];\n                },\n                \"toWireType\": (destructors, c)=>c.value,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": enumReadValueFromPointer(name, size, isSigned),\n                destructorFunction: null\n            });\n            exposePublicSymbol(name, ctor);\n        };\n        var requireRegisteredType = (rawType, humanName)=>{\n            var impl = registeredTypes[rawType];\n            if (undefined === impl) {\n                throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n            }\n            return impl;\n        };\n        var __embind_register_enum_value = (rawEnumType, name, enumValue)=>{\n            var enumType = requireRegisteredType(rawEnumType, \"enum\");\n            name = readLatin1String(name);\n            var Enum = enumType.constructor;\n            var Value = Object.create(enumType.constructor.prototype, {\n                value: {\n                    value: enumValue\n                },\n                constructor: {\n                    value: createNamedFunction(\"\".concat(enumType.name, \"_\").concat(name), function() {})\n                }\n            });\n            Enum.values[enumValue] = Value;\n            Enum[name] = Value;\n        };\n        var embindRepr = (v)=>{\n            if (v === null) {\n                return \"null\";\n            }\n            var t = typeof v;\n            if (t === \"object\" || t === \"array\" || t === \"function\") {\n                return v.toString();\n            } else {\n                return \"\" + v;\n            }\n        };\n        var floatReadValueFromPointer = (name, width)=>{\n            switch(width){\n                case 4:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n                    };\n                case 8:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n                    };\n                default:\n                    throw new TypeError(\"invalid float width (\".concat(width, \"): \").concat(name));\n            }\n        };\n        var __embind_register_float = (rawType, name, size)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>value,\n                \"toWireType\": (destructors, value)=>value,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": floatReadValueFromPointer(name, size),\n                destructorFunction: null\n            });\n        };\n        var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync)=>{\n            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            name = readLatin1String(name);\n            rawInvoker = embind__requireFunction(signature, rawInvoker);\n            exposePublicSymbol(name, function() {\n                throwUnboundTypeError(\"Cannot call \".concat(name, \" due to unbound types\"), argTypes);\n            }, argCount - 1);\n            whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n                var invokerArgsArray = [\n                    argTypes[0],\n                    null\n                ].concat(argTypes.slice(1));\n                replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n                return [];\n            });\n        };\n        var integerReadValueFromPointer = (name, width, signed)=>{\n            switch(width){\n                case 1:\n                    return signed ? (pointer)=>HEAP8[pointer >> 0] : (pointer)=>HEAPU8[pointer >> 0];\n                case 2:\n                    return signed ? (pointer)=>HEAP16[pointer >> 1] : (pointer)=>HEAPU16[pointer >> 1];\n                case 4:\n                    return signed ? (pointer)=>HEAP32[pointer >> 2] : (pointer)=>HEAPU32[pointer >> 2];\n                default:\n                    throw new TypeError(\"invalid integer width (\".concat(width, \"): \").concat(name));\n            }\n        };\n        var __embind_register_integer = (primitiveType, name, size, minRange, maxRange)=>{\n            name = readLatin1String(name);\n            if (maxRange === -1) {\n                maxRange = 4294967295;\n            }\n            var fromWireType = (value)=>value;\n            if (minRange === 0) {\n                var bitshift = 32 - 8 * size;\n                fromWireType = (value)=>value << bitshift >>> bitshift;\n            }\n            var isUnsignedType = name.includes(\"unsigned\");\n            var checkAssertions = (value, toTypeName)=>{};\n            var toWireType;\n            if (isUnsignedType) {\n                toWireType = function(destructors, value) {\n                    checkAssertions(value, this.name);\n                    return value >>> 0;\n                };\n            } else {\n                toWireType = function(destructors, value) {\n                    checkAssertions(value, this.name);\n                    return value;\n                };\n            }\n            registerType(primitiveType, {\n                name: name,\n                \"fromWireType\": fromWireType,\n                \"toWireType\": toWireType,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": integerReadValueFromPointer(name, size, minRange !== 0),\n                destructorFunction: null\n            });\n        };\n        var __embind_register_memory_view = (rawType, dataTypeIndex, name)=>{\n            var typeMapping = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array\n            ];\n            var TA = typeMapping[dataTypeIndex];\n            function decodeMemoryView(handle) {\n                var size = HEAPU32[handle >> 2];\n                var data = HEAPU32[handle + 4 >> 2];\n                return new TA(HEAP8.buffer, data, size);\n            }\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": decodeMemoryView,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": decodeMemoryView\n            }, {\n                ignoreDuplicateRegistrations: true\n            });\n        };\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{\n            if (!(maxBytesToWrite > 0)) return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1;\n            for(var i = 0; i < str.length; ++i){\n                var u = str.charCodeAt(i);\n                if (u >= 55296 && u <= 57343) {\n                    var u1 = str.charCodeAt(++i);\n                    u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n                }\n                if (u <= 127) {\n                    if (outIdx >= endIdx) break;\n                    heap[outIdx++] = u;\n                } else if (u <= 2047) {\n                    if (outIdx + 1 >= endIdx) break;\n                    heap[outIdx++] = 192 | u >> 6;\n                    heap[outIdx++] = 128 | u & 63;\n                } else if (u <= 65535) {\n                    if (outIdx + 2 >= endIdx) break;\n                    heap[outIdx++] = 224 | u >> 12;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                } else {\n                    if (outIdx + 3 >= endIdx) break;\n                    heap[outIdx++] = 240 | u >> 18;\n                    heap[outIdx++] = 128 | u >> 12 & 63;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                }\n            }\n            heap[outIdx] = 0;\n            return outIdx - startIdx;\n        };\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n        var lengthBytesUTF8 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var c = str.charCodeAt(i);\n                if (c <= 127) {\n                    len++;\n                } else if (c <= 2047) {\n                    len += 2;\n                } else if (c >= 55296 && c <= 57343) {\n                    len += 4;\n                    ++i;\n                } else {\n                    len += 3;\n                }\n            }\n            return len;\n        };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead)=>{\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n                return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n            }\n            var str = \"\";\n            while(idx < endPtr){\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 128)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 224) == 192) {\n                    str += String.fromCharCode((u0 & 31) << 6 | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 240) == 224) {\n                    u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n                } else {\n                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n                }\n                if (u0 < 65536) {\n                    str += String.fromCharCode(u0);\n                } else {\n                    var ch = u0 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                }\n            }\n            return str;\n        };\n        var UTF8ToString = (ptr, maxBytesToRead)=>ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n        var __embind_register_std_string = (rawType, name)=>{\n            name = readLatin1String(name);\n            var stdStringIsUTF8 = name === \"std::string\";\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\" (value) {\n                    var length = HEAPU32[value >> 2];\n                    var payload = value + 4;\n                    var str;\n                    if (stdStringIsUTF8) {\n                        var decodeStartPtr = payload;\n                        for(var i = 0; i <= length; ++i){\n                            var currentBytePtr = payload + i;\n                            if (i == length || HEAPU8[currentBytePtr] == 0) {\n                                var maxRead = currentBytePtr - decodeStartPtr;\n                                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                                if (str === undefined) {\n                                    str = stringSegment;\n                                } else {\n                                    str += String.fromCharCode(0);\n                                    str += stringSegment;\n                                }\n                                decodeStartPtr = currentBytePtr + 1;\n                            }\n                        }\n                    } else {\n                        var a = new Array(length);\n                        for(var i = 0; i < length; ++i){\n                            a[i] = String.fromCharCode(HEAPU8[payload + i]);\n                        }\n                        str = a.join(\"\");\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\" (destructors, value) {\n                    if (value instanceof ArrayBuffer) {\n                        value = new Uint8Array(value);\n                    }\n                    var length;\n                    var valueIsOfTypeString = typeof value == \"string\";\n                    if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n                        throwBindingError(\"Cannot pass non-string to std::string\");\n                    }\n                    if (stdStringIsUTF8 && valueIsOfTypeString) {\n                        length = lengthBytesUTF8(value);\n                    } else {\n                        length = value.length;\n                    }\n                    var base = _malloc(4 + length + 1);\n                    var ptr = base + 4;\n                    HEAPU32[base >> 2] = length;\n                    if (stdStringIsUTF8 && valueIsOfTypeString) {\n                        stringToUTF8(value, ptr, length + 1);\n                    } else {\n                        if (valueIsOfTypeString) {\n                            for(var i = 0; i < length; ++i){\n                                var charCode = value.charCodeAt(i);\n                                if (charCode > 255) {\n                                    _free(ptr);\n                                    throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                                }\n                                HEAPU8[ptr + i] = charCode;\n                            }\n                        } else {\n                            for(var i = 0; i < length; ++i){\n                                HEAPU8[ptr + i] = value[i];\n                            }\n                        }\n                    }\n                    if (destructors !== null) {\n                        destructors.push(_free, base);\n                    }\n                    return base;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n        var UTF16ToString = (ptr, maxBytesToRead)=>{\n            var endPtr = ptr;\n            var idx = endPtr >> 1;\n            var maxIdx = idx + maxBytesToRead / 2;\n            while(!(idx >= maxIdx) && HEAPU16[idx])++idx;\n            endPtr = idx << 1;\n            if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n            var str = \"\";\n            for(var i = 0; !(i >= maxBytesToRead / 2); ++i){\n                var codeUnit = HEAP16[ptr + i * 2 >> 1];\n                if (codeUnit == 0) break;\n                str += String.fromCharCode(codeUnit);\n            }\n            return str;\n        };\n        var stringToUTF16 = (str, outPtr, maxBytesToWrite)=>{\n            if (maxBytesToWrite === undefined) {\n                maxBytesToWrite = 2147483647;\n            }\n            if (maxBytesToWrite < 2) return 0;\n            maxBytesToWrite -= 2;\n            var startPtr = outPtr;\n            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n            for(var i = 0; i < numCharsToWrite; ++i){\n                var codeUnit = str.charCodeAt(i);\n                HEAP16[outPtr >> 1] = codeUnit;\n                outPtr += 2;\n            }\n            HEAP16[outPtr >> 1] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF16 = (str)=>str.length * 2;\n        var UTF32ToString = (ptr, maxBytesToRead)=>{\n            var i = 0;\n            var str = \"\";\n            while(!(i >= maxBytesToRead / 4)){\n                var utf32 = HEAP32[ptr + i * 4 >> 2];\n                if (utf32 == 0) break;\n                ++i;\n                if (utf32 >= 65536) {\n                    var ch = utf32 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                } else {\n                    str += String.fromCharCode(utf32);\n                }\n            }\n            return str;\n        };\n        var stringToUTF32 = (str, outPtr, maxBytesToWrite)=>{\n            if (maxBytesToWrite === undefined) {\n                maxBytesToWrite = 2147483647;\n            }\n            if (maxBytesToWrite < 4) return 0;\n            var startPtr = outPtr;\n            var endPtr = startPtr + maxBytesToWrite - 4;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) {\n                    var trailSurrogate = str.charCodeAt(++i);\n                    codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n                }\n                HEAP32[outPtr >> 2] = codeUnit;\n                outPtr += 4;\n                if (outPtr + 4 > endPtr) break;\n            }\n            HEAP32[outPtr >> 2] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF32 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n                len += 4;\n            }\n            return len;\n        };\n        var __embind_register_std_wstring = (rawType, charSize, name)=>{\n            name = readLatin1String(name);\n            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n            if (charSize === 2) {\n                decodeString = UTF16ToString;\n                encodeString = stringToUTF16;\n                lengthBytesUTF = lengthBytesUTF16;\n                getHeap = ()=>HEAPU16;\n                shift = 1;\n            } else if (charSize === 4) {\n                decodeString = UTF32ToString;\n                encodeString = stringToUTF32;\n                lengthBytesUTF = lengthBytesUTF32;\n                getHeap = ()=>HEAPU32;\n                shift = 2;\n            }\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>{\n                    var length = HEAPU32[value >> 2];\n                    var HEAP = getHeap();\n                    var str;\n                    var decodeStartPtr = value + 4;\n                    for(var i = 0; i <= length; ++i){\n                        var currentBytePtr = value + 4 + i * charSize;\n                        if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n                            var maxReadBytes = currentBytePtr - decodeStartPtr;\n                            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                            if (str === undefined) {\n                                str = stringSegment;\n                            } else {\n                                str += String.fromCharCode(0);\n                                str += stringSegment;\n                            }\n                            decodeStartPtr = currentBytePtr + charSize;\n                        }\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\": (destructors, value)=>{\n                    if (!(typeof value == \"string\")) {\n                        throwBindingError(\"Cannot pass non-string to C++ string type \".concat(name));\n                    }\n                    var length = lengthBytesUTF(value);\n                    var ptr = _malloc(4 + length + charSize);\n                    HEAPU32[ptr >> 2] = length >> shift;\n                    encodeString(value, ptr + 4, length + charSize);\n                    if (destructors !== null) {\n                        destructors.push(_free, ptr);\n                    }\n                    return ptr;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var __embind_register_value_array = (rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor)=>{\n            tupleRegistrations[rawType] = {\n                name: readLatin1String(name),\n                rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n                rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n                elements: []\n            };\n        };\n        var __embind_register_value_array_element = (rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext)=>{\n            tupleRegistrations[rawTupleType].elements.push({\n                getterReturnType: getterReturnType,\n                getter: embind__requireFunction(getterSignature, getter),\n                getterContext: getterContext,\n                setterArgumentType: setterArgumentType,\n                setter: embind__requireFunction(setterSignature, setter),\n                setterContext: setterContext\n            });\n        };\n        var __embind_register_value_object = (rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor)=>{\n            structRegistrations[rawType] = {\n                name: readLatin1String(name),\n                rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n                rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n                fields: []\n            };\n        };\n        var __embind_register_value_object_field = (structType, fieldName, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext)=>{\n            structRegistrations[structType].fields.push({\n                fieldName: readLatin1String(fieldName),\n                getterReturnType: getterReturnType,\n                getter: embind__requireFunction(getterSignature, getter),\n                getterContext: getterContext,\n                setterArgumentType: setterArgumentType,\n                setter: embind__requireFunction(setterSignature, setter),\n                setterContext: setterContext\n            });\n        };\n        var __embind_register_void = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                isVoid: true,\n                name: name,\n                \"argPackAdvance\": 0,\n                \"fromWireType\": ()=>undefined,\n                \"toWireType\": (destructors, o)=>undefined\n            });\n        };\n        var __emval_incref = (handle)=>{\n            if (handle > 4) {\n                emval_handles.get(handle).refcount += 1;\n            }\n        };\n        var __emval_take_value = (type, arg)=>{\n            type = requireRegisteredType(type, \"_emval_take_value\");\n            var v = type[\"readValueFromPointer\"](arg);\n            return Emval.toHandle(v);\n        };\n        var _abort = ()=>{\n            abort(\"\");\n        };\n        var _emscripten_memcpy_js = (dest, src, num)=>HEAPU8.copyWithin(dest, src, src + num);\n        var getHeapMax = ()=>2147483648;\n        var growMemory = (size)=>{\n            var b = wasmMemory.buffer;\n            var pages = (size - b.byteLength + 65535) / 65536;\n            try {\n                wasmMemory.grow(pages);\n                updateMemoryViews();\n                return 1;\n            } catch (e) {}\n        };\n        var _emscripten_resize_heap = (requestedSize)=>{\n            var oldSize = HEAPU8.length;\n            requestedSize >>>= 0;\n            var maxHeapSize = getHeapMax();\n            if (requestedSize > maxHeapSize) {\n                return false;\n            }\n            var alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;\n            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){\n                var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n                var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n                var replacement = growMemory(newSize);\n                if (replacement) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        var ENV = {};\n        var getExecutableName = ()=>thisProgram || \"./this.program\";\n        var getEnvStrings = ()=>{\n            if (!getEnvStrings.strings) {\n                var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n                var env = {\n                    \"USER\": \"web_user\",\n                    \"LOGNAME\": \"web_user\",\n                    \"PATH\": \"/\",\n                    \"PWD\": \"/\",\n                    \"HOME\": \"/home/web_user\",\n                    \"LANG\": lang,\n                    \"_\": getExecutableName()\n                };\n                for(var x in ENV){\n                    if (ENV[x] === undefined) delete env[x];\n                    else env[x] = ENV[x];\n                }\n                var strings = [];\n                for(var x in env){\n                    strings.push(\"\".concat(x, \"=\").concat(env[x]));\n                }\n                getEnvStrings.strings = strings;\n            }\n            return getEnvStrings.strings;\n        };\n        var stringToAscii = (str, buffer)=>{\n            for(var i = 0; i < str.length; ++i){\n                HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n            }\n            HEAP8[buffer >> 0] = 0;\n        };\n        var PATH = {\n            isAbs: (path)=>path.charAt(0) === \"/\",\n            splitPath: (filename)=>{\n                var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n                return splitPathRe.exec(filename).slice(1);\n            },\n            normalizeArray: (parts, allowAboveRoot)=>{\n                var up = 0;\n                for(var i = parts.length - 1; i >= 0; i--){\n                    var last = parts[i];\n                    if (last === \".\") {\n                        parts.splice(i, 1);\n                    } else if (last === \"..\") {\n                        parts.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        parts.splice(i, 1);\n                        up--;\n                    }\n                }\n                if (allowAboveRoot) {\n                    for(; up; up--){\n                        parts.unshift(\"..\");\n                    }\n                }\n                return parts;\n            },\n            normalize: (path)=>{\n                var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === \"/\";\n                path = PATH.normalizeArray(path.split(\"/\").filter((p)=>!!p), !isAbsolute).join(\"/\");\n                if (!path && !isAbsolute) {\n                    path = \".\";\n                }\n                if (path && trailingSlash) {\n                    path += \"/\";\n                }\n                return (isAbsolute ? \"/\" : \"\") + path;\n            },\n            dirname: (path)=>{\n                var result = PATH.splitPath(path), root = result[0], dir = result[1];\n                if (!root && !dir) {\n                    return \".\";\n                }\n                if (dir) {\n                    dir = dir.substr(0, dir.length - 1);\n                }\n                return root + dir;\n            },\n            basename: (path)=>{\n                if (path === \"/\") return \"/\";\n                path = PATH.normalize(path);\n                path = path.replace(/\\/$/, \"\");\n                var lastSlash = path.lastIndexOf(\"/\");\n                if (lastSlash === -1) return path;\n                return path.substr(lastSlash + 1);\n            },\n            join: function() {\n                var paths = Array.prototype.slice.call(arguments);\n                return PATH.normalize(paths.join(\"/\"));\n            },\n            join2: (l, r)=>PATH.normalize(l + \"/\" + r)\n        };\n        var initRandomFill = ()=>{\n            if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") {\n                return (view)=>crypto.getRandomValues(view);\n            } else abort(\"initRandomDevice\");\n        };\n        var randomFill = (view)=>(randomFill = initRandomFill())(view);\n        var PATH_FS = {\n            resolve: function() {\n                var resolvedPath = \"\", resolvedAbsolute = false;\n                for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n                    var path = i >= 0 ? arguments[i] : FS.cwd();\n                    if (typeof path != \"string\") {\n                        throw new TypeError(\"Arguments to path.resolve must be strings\");\n                    } else if (!path) {\n                        return \"\";\n                    }\n                    resolvedPath = path + \"/\" + resolvedPath;\n                    resolvedAbsolute = PATH.isAbs(path);\n                }\n                resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter((p)=>!!p), !resolvedAbsolute).join(\"/\");\n                return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n            },\n            relative: (from, to)=>{\n                from = PATH_FS.resolve(from).substr(1);\n                to = PATH_FS.resolve(to).substr(1);\n                function trim(arr) {\n                    var start = 0;\n                    for(; start < arr.length; start++){\n                        if (arr[start] !== \"\") break;\n                    }\n                    var end = arr.length - 1;\n                    for(; end >= 0; end--){\n                        if (arr[end] !== \"\") break;\n                    }\n                    if (start > end) return [];\n                    return arr.slice(start, end - start + 1);\n                }\n                var fromParts = trim(from.split(\"/\"));\n                var toParts = trim(to.split(\"/\"));\n                var length = Math.min(fromParts.length, toParts.length);\n                var samePartsLength = length;\n                for(var i = 0; i < length; i++){\n                    if (fromParts[i] !== toParts[i]) {\n                        samePartsLength = i;\n                        break;\n                    }\n                }\n                var outputParts = [];\n                for(var i = samePartsLength; i < fromParts.length; i++){\n                    outputParts.push(\"..\");\n                }\n                outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                return outputParts.join(\"/\");\n            }\n        };\n        var FS_stdin_getChar_buffer = [];\n        function intArrayFromString(stringy, dontAddNull, length) {\n            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n            var u8array = new Array(len);\n            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n            if (dontAddNull) u8array.length = numBytesWritten;\n            return u8array;\n        }\n        var FS_stdin_getChar = ()=>{\n            if (!FS_stdin_getChar_buffer.length) {\n                var result = null;\n                if ( true && typeof window.prompt == \"function\") {\n                    result = window.prompt(\"Input: \");\n                    if (result !== null) {\n                        result += \"\\n\";\n                    }\n                } else if (typeof readline == \"function\") {\n                    result = readline();\n                    if (result !== null) {\n                        result += \"\\n\";\n                    }\n                }\n                if (!result) {\n                    return null;\n                }\n                FS_stdin_getChar_buffer = intArrayFromString(result, true);\n            }\n            return FS_stdin_getChar_buffer.shift();\n        };\n        var TTY = {\n            ttys: [],\n            init () {},\n            shutdown () {},\n            register (dev, ops) {\n                TTY.ttys[dev] = {\n                    input: [],\n                    output: [],\n                    ops: ops\n                };\n                FS.registerDevice(dev, TTY.stream_ops);\n            },\n            stream_ops: {\n                open (stream) {\n                    var tty = TTY.ttys[stream.node.rdev];\n                    if (!tty) {\n                        throw new FS.ErrnoError(43);\n                    }\n                    stream.tty = tty;\n                    stream.seekable = false;\n                },\n                close (stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                fsync (stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                read (stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.get_char) {\n                        throw new FS.ErrnoError(60);\n                    }\n                    var bytesRead = 0;\n                    for(var i = 0; i < length; i++){\n                        var result;\n                        try {\n                            result = stream.tty.ops.get_char(stream.tty);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (result === undefined && bytesRead === 0) {\n                            throw new FS.ErrnoError(6);\n                        }\n                        if (result === null || result === undefined) break;\n                        bytesRead++;\n                        buffer[offset + i] = result;\n                    }\n                    if (bytesRead) {\n                        stream.node.timestamp = Date.now();\n                    }\n                    return bytesRead;\n                },\n                write (stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.put_char) {\n                        throw new FS.ErrnoError(60);\n                    }\n                    try {\n                        for(var i = 0; i < length; i++){\n                            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n                        }\n                    } catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (length) {\n                        stream.node.timestamp = Date.now();\n                    }\n                    return i;\n                }\n            },\n            default_tty_ops: {\n                get_char (tty) {\n                    return FS_stdin_getChar();\n                },\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else {\n                        if (val != 0) tty.output.push(val);\n                    }\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                },\n                ioctl_tcgets (tty) {\n                    return {\n                        c_iflag: 25856,\n                        c_oflag: 5,\n                        c_cflag: 191,\n                        c_lflag: 35387,\n                        c_cc: [\n                            3,\n                            28,\n                            127,\n                            21,\n                            4,\n                            0,\n                            1,\n                            0,\n                            17,\n                            19,\n                            26,\n                            0,\n                            18,\n                            15,\n                            23,\n                            22,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ]\n                    };\n                },\n                ioctl_tcsets (tty, optional_actions, data) {\n                    return 0;\n                },\n                ioctl_tiocgwinsz (tty) {\n                    return [\n                        24,\n                        80\n                    ];\n                }\n            },\n            default_tty1_ops: {\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else {\n                        if (val != 0) tty.output.push(val);\n                    }\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                }\n            }\n        };\n        var mmapAlloc = (size)=>{\n            abort();\n        };\n        var MEMFS = {\n            ops_table: null,\n            mount (mount) {\n                return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n            },\n            createNode (parent, name, mode, dev) {\n                if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (!MEMFS.ops_table) {\n                    MEMFS.ops_table = {\n                        dir: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr,\n                                lookup: MEMFS.node_ops.lookup,\n                                mknod: MEMFS.node_ops.mknod,\n                                rename: MEMFS.node_ops.rename,\n                                unlink: MEMFS.node_ops.unlink,\n                                rmdir: MEMFS.node_ops.rmdir,\n                                readdir: MEMFS.node_ops.readdir,\n                                symlink: MEMFS.node_ops.symlink\n                            },\n                            stream: {\n                                llseek: MEMFS.stream_ops.llseek\n                            }\n                        },\n                        file: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr\n                            },\n                            stream: {\n                                llseek: MEMFS.stream_ops.llseek,\n                                read: MEMFS.stream_ops.read,\n                                write: MEMFS.stream_ops.write,\n                                allocate: MEMFS.stream_ops.allocate,\n                                mmap: MEMFS.stream_ops.mmap,\n                                msync: MEMFS.stream_ops.msync\n                            }\n                        },\n                        link: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr,\n                                readlink: MEMFS.node_ops.readlink\n                            },\n                            stream: {}\n                        },\n                        chrdev: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr\n                            },\n                            stream: FS.chrdev_stream_ops\n                        }\n                    };\n                }\n                var node = FS.createNode(parent, name, mode, dev);\n                if (FS.isDir(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.dir.node;\n                    node.stream_ops = MEMFS.ops_table.dir.stream;\n                    node.contents = {};\n                } else if (FS.isFile(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.file.node;\n                    node.stream_ops = MEMFS.ops_table.file.stream;\n                    node.usedBytes = 0;\n                    node.contents = null;\n                } else if (FS.isLink(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.link.node;\n                    node.stream_ops = MEMFS.ops_table.link.stream;\n                } else if (FS.isChrdev(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.chrdev.node;\n                    node.stream_ops = MEMFS.ops_table.chrdev.stream;\n                }\n                node.timestamp = Date.now();\n                if (parent) {\n                    parent.contents[name] = node;\n                    parent.timestamp = node.timestamp;\n                }\n                return node;\n            },\n            getFileDataAsTypedArray (node) {\n                if (!node.contents) return new Uint8Array(0);\n                if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n                return new Uint8Array(node.contents);\n            },\n            expandFileStorage (node, newCapacity) {\n                var prevCapacity = node.contents ? node.contents.length : 0;\n                if (prevCapacity >= newCapacity) return;\n                var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n                newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n                if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n                var oldContents = node.contents;\n                node.contents = new Uint8Array(newCapacity);\n                if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n            },\n            resizeFileStorage (node, newSize) {\n                if (node.usedBytes == newSize) return;\n                if (newSize == 0) {\n                    node.contents = null;\n                    node.usedBytes = 0;\n                } else {\n                    var oldContents = node.contents;\n                    node.contents = new Uint8Array(newSize);\n                    if (oldContents) {\n                        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n                    }\n                    node.usedBytes = newSize;\n                }\n            },\n            node_ops: {\n                getattr (node) {\n                    var attr = {};\n                    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n                    attr.ino = node.id;\n                    attr.mode = node.mode;\n                    attr.nlink = 1;\n                    attr.uid = 0;\n                    attr.gid = 0;\n                    attr.rdev = node.rdev;\n                    if (FS.isDir(node.mode)) {\n                        attr.size = 4096;\n                    } else if (FS.isFile(node.mode)) {\n                        attr.size = node.usedBytes;\n                    } else if (FS.isLink(node.mode)) {\n                        attr.size = node.link.length;\n                    } else {\n                        attr.size = 0;\n                    }\n                    attr.atime = new Date(node.timestamp);\n                    attr.mtime = new Date(node.timestamp);\n                    attr.ctime = new Date(node.timestamp);\n                    attr.blksize = 4096;\n                    attr.blocks = Math.ceil(attr.size / attr.blksize);\n                    return attr;\n                },\n                setattr (node, attr) {\n                    if (attr.mode !== undefined) {\n                        node.mode = attr.mode;\n                    }\n                    if (attr.timestamp !== undefined) {\n                        node.timestamp = attr.timestamp;\n                    }\n                    if (attr.size !== undefined) {\n                        MEMFS.resizeFileStorage(node, attr.size);\n                    }\n                },\n                lookup (parent, name) {\n                    throw FS.genericErrors[44];\n                },\n                mknod (parent, name, mode, dev) {\n                    return MEMFS.createNode(parent, name, mode, dev);\n                },\n                rename (old_node, new_dir, new_name) {\n                    if (FS.isDir(old_node.mode)) {\n                        var new_node;\n                        try {\n                            new_node = FS.lookupNode(new_dir, new_name);\n                        } catch (e) {}\n                        if (new_node) {\n                            for(var i in new_node.contents){\n                                throw new FS.ErrnoError(55);\n                            }\n                        }\n                    }\n                    delete old_node.parent.contents[old_node.name];\n                    old_node.parent.timestamp = Date.now();\n                    old_node.name = new_name;\n                    new_dir.contents[new_name] = old_node;\n                    new_dir.timestamp = old_node.parent.timestamp;\n                    old_node.parent = new_dir;\n                },\n                unlink (parent, name) {\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                rmdir (parent, name) {\n                    var node = FS.lookupNode(parent, name);\n                    for(var i in node.contents){\n                        throw new FS.ErrnoError(55);\n                    }\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                readdir (node) {\n                    var entries = [\n                        \".\",\n                        \"..\"\n                    ];\n                    for(var key in node.contents){\n                        if (!node.contents.hasOwnProperty(key)) {\n                            continue;\n                        }\n                        entries.push(key);\n                    }\n                    return entries;\n                },\n                symlink (parent, newname, oldpath) {\n                    var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n                    node.link = oldpath;\n                    return node;\n                },\n                readlink (node) {\n                    if (!FS.isLink(node.mode)) {\n                        throw new FS.ErrnoError(28);\n                    }\n                    return node.link;\n                }\n            },\n            stream_ops: {\n                read (stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= stream.node.usedBytes) return 0;\n                    var size = Math.min(stream.node.usedBytes - position, length);\n                    if (size > 8 && contents.subarray) {\n                        buffer.set(contents.subarray(position, position + size), offset);\n                    } else {\n                        for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    }\n                    return size;\n                },\n                write (stream, buffer, offset, length, position, canOwn) {\n                    if (buffer.buffer === HEAP8.buffer) {\n                        canOwn = false;\n                    }\n                    if (!length) return 0;\n                    var node = stream.node;\n                    node.timestamp = Date.now();\n                    if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n                        if (canOwn) {\n                            node.contents = buffer.subarray(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (node.usedBytes === 0 && position === 0) {\n                            node.contents = buffer.slice(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (position + length <= node.usedBytes) {\n                            node.contents.set(buffer.subarray(offset, offset + length), position);\n                            return length;\n                        }\n                    }\n                    MEMFS.expandFileStorage(node, position + length);\n                    if (node.contents.subarray && buffer.subarray) {\n                        node.contents.set(buffer.subarray(offset, offset + length), position);\n                    } else {\n                        for(var i = 0; i < length; i++){\n                            node.contents[position + i] = buffer[offset + i];\n                        }\n                    }\n                    node.usedBytes = Math.max(node.usedBytes, position + length);\n                    return length;\n                },\n                llseek (stream, offset, whence) {\n                    var position = offset;\n                    if (whence === 1) {\n                        position += stream.position;\n                    } else if (whence === 2) {\n                        if (FS.isFile(stream.node.mode)) {\n                            position += stream.node.usedBytes;\n                        }\n                    }\n                    if (position < 0) {\n                        throw new FS.ErrnoError(28);\n                    }\n                    return position;\n                },\n                allocate (stream, offset, length) {\n                    MEMFS.expandFileStorage(stream.node, offset + length);\n                    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n                },\n                mmap (stream, length, position, prot, flags) {\n                    if (!FS.isFile(stream.node.mode)) {\n                        throw new FS.ErrnoError(43);\n                    }\n                    var ptr;\n                    var allocated;\n                    var contents = stream.node.contents;\n                    if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n                        allocated = false;\n                        ptr = contents.byteOffset;\n                    } else {\n                        if (position > 0 || position + length < contents.length) {\n                            if (contents.subarray) {\n                                contents = contents.subarray(position, position + length);\n                            } else {\n                                contents = Array.prototype.slice.call(contents, position, position + length);\n                            }\n                        }\n                        allocated = true;\n                        ptr = mmapAlloc(length);\n                        if (!ptr) {\n                            throw new FS.ErrnoError(48);\n                        }\n                        HEAP8.set(contents, ptr);\n                    }\n                    return {\n                        ptr: ptr,\n                        allocated: allocated\n                    };\n                },\n                msync (stream, buffer, offset, length, mmapFlags) {\n                    MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n                    return 0;\n                }\n            }\n        };\n        var asyncLoad = (url, onload, onerror, noRunDep)=>{\n            var dep = !noRunDep ? getUniqueRunDependency(\"al \".concat(url)) : \"\";\n            readAsync(url, (arrayBuffer)=>{\n                assert(arrayBuffer, 'Loading data file \"'.concat(url, '\" failed (no arrayBuffer).'));\n                onload(new Uint8Array(arrayBuffer));\n                if (dep) removeRunDependency(dep);\n            }, (event)=>{\n                if (onerror) {\n                    onerror();\n                } else {\n                    throw 'Loading data file \"'.concat(url, '\" failed.');\n                }\n            });\n            if (dep) addRunDependency(dep);\n        };\n        var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn)=>FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n        var preloadPlugins = Module[\"preloadPlugins\"] || [];\n        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror)=>{\n            if (typeof Browser != \"undefined\") Browser.init();\n            var handled = false;\n            preloadPlugins.forEach((plugin)=>{\n                if (handled) return;\n                if (plugin[\"canHandle\"](fullname)) {\n                    plugin[\"handle\"](byteArray, fullname, finish, onerror);\n                    handled = true;\n                }\n            });\n            return handled;\n        };\n        var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish)=>{\n            var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n            var dep = getUniqueRunDependency(\"cp \".concat(fullname));\n            function processData(byteArray) {\n                function finish(byteArray) {\n                    if (preFinish) preFinish();\n                    if (!dontCreateFile) {\n                        FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n                    }\n                    if (onload) onload();\n                    removeRunDependency(dep);\n                }\n                if (FS_handledByPreloadPlugin(byteArray, fullname, finish, ()=>{\n                    if (onerror) onerror();\n                    removeRunDependency(dep);\n                })) {\n                    return;\n                }\n                finish(byteArray);\n            }\n            addRunDependency(dep);\n            if (typeof url == \"string\") {\n                asyncLoad(url, (byteArray)=>processData(byteArray), onerror);\n            } else {\n                processData(url);\n            }\n        };\n        var FS_modeStringToFlags = (str)=>{\n            var flagModes = {\n                \"r\": 0,\n                \"r+\": 2,\n                \"w\": 512 | 64 | 1,\n                \"w+\": 512 | 64 | 2,\n                \"a\": 1024 | 64 | 1,\n                \"a+\": 1024 | 64 | 2\n            };\n            var flags = flagModes[str];\n            if (typeof flags == \"undefined\") {\n                throw new Error(\"Unknown file open mode: \".concat(str));\n            }\n            return flags;\n        };\n        var FS_getMode = (canRead, canWrite)=>{\n            var mode = 0;\n            if (canRead) mode |= 292 | 73;\n            if (canWrite) mode |= 146;\n            return mode;\n        };\n        var FS = {\n            root: null,\n            mounts: [],\n            devices: {},\n            streams: [],\n            nextInode: 1,\n            nameTable: null,\n            currentPath: \"/\",\n            initialized: false,\n            ignorePermissions: true,\n            ErrnoError: null,\n            genericErrors: {},\n            filesystems: null,\n            syncFSRequests: 0,\n            lookupPath (path) {\n                let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                path = PATH_FS.resolve(path);\n                if (!path) return {\n                    path: \"\",\n                    node: null\n                };\n                var defaults = {\n                    follow_mount: true,\n                    recurse_count: 0\n                };\n                opts = Object.assign(defaults, opts);\n                if (opts.recurse_count > 8) {\n                    throw new FS.ErrnoError(32);\n                }\n                var parts = path.split(\"/\").filter((p)=>!!p);\n                var current = FS.root;\n                var current_path = \"/\";\n                for(var i = 0; i < parts.length; i++){\n                    var islast = i === parts.length - 1;\n                    if (islast && opts.parent) {\n                        break;\n                    }\n                    current = FS.lookupNode(current, parts[i]);\n                    current_path = PATH.join2(current_path, parts[i]);\n                    if (FS.isMountpoint(current)) {\n                        if (!islast || islast && opts.follow_mount) {\n                            current = current.mounted.root;\n                        }\n                    }\n                    if (!islast || opts.follow) {\n                        var count = 0;\n                        while(FS.isLink(current.mode)){\n                            var link = FS.readlink(current_path);\n                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n                            var lookup = FS.lookupPath(current_path, {\n                                recurse_count: opts.recurse_count + 1\n                            });\n                            current = lookup.node;\n                            if (count++ > 40) {\n                                throw new FS.ErrnoError(32);\n                            }\n                        }\n                    }\n                }\n                return {\n                    path: current_path,\n                    node: current\n                };\n            },\n            getPath (node) {\n                var path;\n                while(true){\n                    if (FS.isRoot(node)) {\n                        var mount = node.mount.mountpoint;\n                        if (!path) return mount;\n                        return mount[mount.length - 1] !== \"/\" ? \"\".concat(mount, \"/\").concat(path) : mount + path;\n                    }\n                    path = path ? \"\".concat(node.name, \"/\").concat(path) : node.name;\n                    node = node.parent;\n                }\n            },\n            hashName (parentid, name) {\n                var hash = 0;\n                for(var i = 0; i < name.length; i++){\n                    hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n                }\n                return (parentid + hash >>> 0) % FS.nameTable.length;\n            },\n            hashAddNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                node.name_next = FS.nameTable[hash];\n                FS.nameTable[hash] = node;\n            },\n            hashRemoveNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                if (FS.nameTable[hash] === node) {\n                    FS.nameTable[hash] = node.name_next;\n                } else {\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        if (current.name_next === node) {\n                            current.name_next = node.name_next;\n                            break;\n                        }\n                        current = current.name_next;\n                    }\n                }\n            },\n            lookupNode (parent, name) {\n                var errCode = FS.mayLookup(parent);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode, parent);\n                }\n                var hash = FS.hashName(parent.id, name);\n                for(var node = FS.nameTable[hash]; node; node = node.name_next){\n                    var nodeName = node.name;\n                    if (node.parent.id === parent.id && nodeName === name) {\n                        return node;\n                    }\n                }\n                return FS.lookup(parent, name);\n            },\n            createNode (parent, name, mode, rdev) {\n                var node = new FS.FSNode(parent, name, mode, rdev);\n                FS.hashAddNode(node);\n                return node;\n            },\n            destroyNode (node) {\n                FS.hashRemoveNode(node);\n            },\n            isRoot (node) {\n                return node === node.parent;\n            },\n            isMountpoint (node) {\n                return !!node.mounted;\n            },\n            isFile (mode) {\n                return (mode & 61440) === 32768;\n            },\n            isDir (mode) {\n                return (mode & 61440) === 16384;\n            },\n            isLink (mode) {\n                return (mode & 61440) === 40960;\n            },\n            isChrdev (mode) {\n                return (mode & 61440) === 8192;\n            },\n            isBlkdev (mode) {\n                return (mode & 61440) === 24576;\n            },\n            isFIFO (mode) {\n                return (mode & 61440) === 4096;\n            },\n            isSocket (mode) {\n                return (mode & 49152) === 49152;\n            },\n            flagsToPermissionString (flag) {\n                var perms = [\n                    \"r\",\n                    \"w\",\n                    \"rw\"\n                ][flag & 3];\n                if (flag & 512) {\n                    perms += \"w\";\n                }\n                return perms;\n            },\n            nodePermissions (node, perms) {\n                if (FS.ignorePermissions) {\n                    return 0;\n                }\n                if (perms.includes(\"r\") && !(node.mode & 292)) {\n                    return 2;\n                } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n                    return 2;\n                } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n                    return 2;\n                }\n                return 0;\n            },\n            mayLookup (dir) {\n                var errCode = FS.nodePermissions(dir, \"x\");\n                if (errCode) return errCode;\n                if (!dir.node_ops.lookup) return 2;\n                return 0;\n            },\n            mayCreate (dir, name) {\n                try {\n                    var node = FS.lookupNode(dir, name);\n                    return 20;\n                } catch (e) {}\n                return FS.nodePermissions(dir, \"wx\");\n            },\n            mayDelete (dir, name, isdir) {\n                var node;\n                try {\n                    node = FS.lookupNode(dir, name);\n                } catch (e) {\n                    return e.errno;\n                }\n                var errCode = FS.nodePermissions(dir, \"wx\");\n                if (errCode) {\n                    return errCode;\n                }\n                if (isdir) {\n                    if (!FS.isDir(node.mode)) {\n                        return 54;\n                    }\n                    if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n                        return 10;\n                    }\n                } else {\n                    if (FS.isDir(node.mode)) {\n                        return 31;\n                    }\n                }\n                return 0;\n            },\n            mayOpen (node, flags) {\n                if (!node) {\n                    return 44;\n                }\n                if (FS.isLink(node.mode)) {\n                    return 32;\n                } else if (FS.isDir(node.mode)) {\n                    if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n                        return 31;\n                    }\n                }\n                return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n            },\n            MAX_OPEN_FDS: 4096,\n            nextfd () {\n                for(var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++){\n                    if (!FS.streams[fd]) {\n                        return fd;\n                    }\n                }\n                throw new FS.ErrnoError(33);\n            },\n            getStreamChecked (fd) {\n                var stream = FS.getStream(fd);\n                if (!stream) {\n                    throw new FS.ErrnoError(8);\n                }\n                return stream;\n            },\n            getStream: (fd)=>FS.streams[fd],\n            createStream (stream) {\n                let fd = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;\n                if (!FS.FSStream) {\n                    FS.FSStream = function() {\n                        this.shared = {};\n                    };\n                    FS.FSStream.prototype = {};\n                    Object.defineProperties(FS.FSStream.prototype, {\n                        object: {\n                            get () {\n                                return this.node;\n                            },\n                            set (val) {\n                                this.node = val;\n                            }\n                        },\n                        isRead: {\n                            get () {\n                                return (this.flags & 2097155) !== 1;\n                            }\n                        },\n                        isWrite: {\n                            get () {\n                                return (this.flags & 2097155) !== 0;\n                            }\n                        },\n                        isAppend: {\n                            get () {\n                                return this.flags & 1024;\n                            }\n                        },\n                        flags: {\n                            get () {\n                                return this.shared.flags;\n                            },\n                            set (val) {\n                                this.shared.flags = val;\n                            }\n                        },\n                        position: {\n                            get () {\n                                return this.shared.position;\n                            },\n                            set (val) {\n                                this.shared.position = val;\n                            }\n                        }\n                    });\n                }\n                stream = Object.assign(new FS.FSStream, stream);\n                if (fd == -1) {\n                    fd = FS.nextfd();\n                }\n                stream.fd = fd;\n                FS.streams[fd] = stream;\n                return stream;\n            },\n            closeStream (fd) {\n                FS.streams[fd] = null;\n            },\n            chrdev_stream_ops: {\n                open (stream) {\n                    var device = FS.getDevice(stream.node.rdev);\n                    stream.stream_ops = device.stream_ops;\n                    if (stream.stream_ops.open) {\n                        stream.stream_ops.open(stream);\n                    }\n                },\n                llseek () {\n                    throw new FS.ErrnoError(70);\n                }\n            },\n            major: (dev)=>dev >> 8,\n            minor: (dev)=>dev & 255,\n            makedev: (ma, mi)=>ma << 8 | mi,\n            registerDevice (dev, ops) {\n                FS.devices[dev] = {\n                    stream_ops: ops\n                };\n            },\n            getDevice: (dev)=>FS.devices[dev],\n            getMounts (mount) {\n                var mounts = [];\n                var check = [\n                    mount\n                ];\n                while(check.length){\n                    var m = check.pop();\n                    mounts.push(m);\n                    check.push.apply(check, m.mounts);\n                }\n                return mounts;\n            },\n            syncfs (populate, callback) {\n                if (typeof populate == \"function\") {\n                    callback = populate;\n                    populate = false;\n                }\n                FS.syncFSRequests++;\n                if (FS.syncFSRequests > 1) {\n                    err(\"warning: \".concat(FS.syncFSRequests, \" FS.syncfs operations in flight at once, probably just doing extra work\"));\n                }\n                var mounts = FS.getMounts(FS.root.mount);\n                var completed = 0;\n                function doCallback(errCode) {\n                    FS.syncFSRequests--;\n                    return callback(errCode);\n                }\n                function done(errCode) {\n                    if (errCode) {\n                        if (!done.errored) {\n                            done.errored = true;\n                            return doCallback(errCode);\n                        }\n                        return;\n                    }\n                    if (++completed >= mounts.length) {\n                        doCallback(null);\n                    }\n                }\n                mounts.forEach((mount)=>{\n                    if (!mount.type.syncfs) {\n                        return done(null);\n                    }\n                    mount.type.syncfs(mount, populate, done);\n                });\n            },\n            mount (type, opts, mountpoint) {\n                var root = mountpoint === \"/\";\n                var pseudo = !mountpoint;\n                var node;\n                if (root && FS.root) {\n                    throw new FS.ErrnoError(10);\n                } else if (!root && !pseudo) {\n                    var lookup = FS.lookupPath(mountpoint, {\n                        follow_mount: false\n                    });\n                    mountpoint = lookup.path;\n                    node = lookup.node;\n                    if (FS.isMountpoint(node)) {\n                        throw new FS.ErrnoError(10);\n                    }\n                    if (!FS.isDir(node.mode)) {\n                        throw new FS.ErrnoError(54);\n                    }\n                }\n                var mount = {\n                    type: type,\n                    opts: opts,\n                    mountpoint: mountpoint,\n                    mounts: []\n                };\n                var mountRoot = type.mount(mount);\n                mountRoot.mount = mount;\n                mount.root = mountRoot;\n                if (root) {\n                    FS.root = mountRoot;\n                } else if (node) {\n                    node.mounted = mount;\n                    if (node.mount) {\n                        node.mount.mounts.push(mount);\n                    }\n                }\n                return mountRoot;\n            },\n            unmount (mountpoint) {\n                var lookup = FS.lookupPath(mountpoint, {\n                    follow_mount: false\n                });\n                if (!FS.isMountpoint(lookup.node)) {\n                    throw new FS.ErrnoError(28);\n                }\n                var node = lookup.node;\n                var mount = node.mounted;\n                var mounts = FS.getMounts(mount);\n                Object.keys(FS.nameTable).forEach((hash)=>{\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        var next = current.name_next;\n                        if (mounts.includes(current.mount)) {\n                            FS.destroyNode(current);\n                        }\n                        current = next;\n                    }\n                });\n                node.mounted = null;\n                var idx = node.mount.mounts.indexOf(mount);\n                node.mount.mounts.splice(idx, 1);\n            },\n            lookup (parent, name) {\n                return parent.node_ops.lookup(parent, name);\n            },\n            mknod (path, mode, dev) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                if (!name || name === \".\" || name === \"..\") {\n                    throw new FS.ErrnoError(28);\n                }\n                var errCode = FS.mayCreate(parent, name);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.mknod) {\n                    throw new FS.ErrnoError(63);\n                }\n                return parent.node_ops.mknod(parent, name, mode, dev);\n            },\n            create (path, mode) {\n                mode = mode !== undefined ? mode : 438;\n                mode &= 4095;\n                mode |= 32768;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdir (path, mode) {\n                mode = mode !== undefined ? mode : 511;\n                mode &= 511 | 512;\n                mode |= 16384;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdirTree (path, mode) {\n                var dirs = path.split(\"/\");\n                var d = \"\";\n                for(var i = 0; i < dirs.length; ++i){\n                    if (!dirs[i]) continue;\n                    d += \"/\" + dirs[i];\n                    try {\n                        FS.mkdir(d, mode);\n                    } catch (e) {\n                        if (e.errno != 20) throw e;\n                    }\n                }\n            },\n            mkdev (path, mode, dev) {\n                if (typeof dev == \"undefined\") {\n                    dev = mode;\n                    mode = 438;\n                }\n                mode |= 8192;\n                return FS.mknod(path, mode, dev);\n            },\n            symlink (oldpath, newpath) {\n                if (!PATH_FS.resolve(oldpath)) {\n                    throw new FS.ErrnoError(44);\n                }\n                var lookup = FS.lookupPath(newpath, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) {\n                    throw new FS.ErrnoError(44);\n                }\n                var newname = PATH.basename(newpath);\n                var errCode = FS.mayCreate(parent, newname);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.symlink) {\n                    throw new FS.ErrnoError(63);\n                }\n                return parent.node_ops.symlink(parent, newname, oldpath);\n            },\n            rename (old_path, new_path) {\n                var old_dirname = PATH.dirname(old_path);\n                var new_dirname = PATH.dirname(new_path);\n                var old_name = PATH.basename(old_path);\n                var new_name = PATH.basename(new_path);\n                var lookup, old_dir, new_dir;\n                lookup = FS.lookupPath(old_path, {\n                    parent: true\n                });\n                old_dir = lookup.node;\n                lookup = FS.lookupPath(new_path, {\n                    parent: true\n                });\n                new_dir = lookup.node;\n                if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n                if (old_dir.mount !== new_dir.mount) {\n                    throw new FS.ErrnoError(75);\n                }\n                var old_node = FS.lookupNode(old_dir, old_name);\n                var relative = PATH_FS.relative(old_path, new_dirname);\n                if (relative.charAt(0) !== \".\") {\n                    throw new FS.ErrnoError(28);\n                }\n                relative = PATH_FS.relative(new_path, old_dirname);\n                if (relative.charAt(0) !== \".\") {\n                    throw new FS.ErrnoError(55);\n                }\n                var new_node;\n                try {\n                    new_node = FS.lookupNode(new_dir, new_name);\n                } catch (e) {}\n                if (old_node === new_node) {\n                    return;\n                }\n                var isdir = FS.isDir(old_node.mode);\n                var errCode = FS.mayDelete(old_dir, old_name, isdir);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!old_dir.node_ops.rename) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                if (new_dir !== old_dir) {\n                    errCode = FS.nodePermissions(old_dir, \"w\");\n                    if (errCode) {\n                        throw new FS.ErrnoError(errCode);\n                    }\n                }\n                FS.hashRemoveNode(old_node);\n                try {\n                    old_dir.node_ops.rename(old_node, new_dir, new_name);\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.hashAddNode(old_node);\n                }\n            },\n            rmdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, true);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.rmdir) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                parent.node_ops.rmdir(parent, name);\n                FS.destroyNode(node);\n            },\n            readdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                if (!node.node_ops.readdir) {\n                    throw new FS.ErrnoError(54);\n                }\n                return node.node_ops.readdir(node);\n            },\n            unlink (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) {\n                    throw new FS.ErrnoError(44);\n                }\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, false);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.unlink) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                parent.node_ops.unlink(parent, name);\n                FS.destroyNode(node);\n            },\n            readlink (path) {\n                var lookup = FS.lookupPath(path);\n                var link = lookup.node;\n                if (!link) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!link.node_ops.readlink) {\n                    throw new FS.ErrnoError(28);\n                }\n                return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n            },\n            stat (path, dontFollow) {\n                var lookup = FS.lookupPath(path, {\n                    follow: !dontFollow\n                });\n                var node = lookup.node;\n                if (!node) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!node.node_ops.getattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                return node.node_ops.getattr(node);\n            },\n            lstat (path) {\n                return FS.stat(path, true);\n            },\n            chmod (path, mode, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                node.node_ops.setattr(node, {\n                    mode: mode & 4095 | node.mode & ~4095,\n                    timestamp: Date.now()\n                });\n            },\n            lchmod (path, mode) {\n                FS.chmod(path, mode, true);\n            },\n            fchmod (fd, mode) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chmod(stream.node, mode);\n            },\n            chown (path, uid, gid, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                node.node_ops.setattr(node, {\n                    timestamp: Date.now()\n                });\n            },\n            lchown (path, uid, gid) {\n                FS.chown(path, uid, gid, true);\n            },\n            fchown (fd, uid, gid) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chown(stream.node, uid, gid);\n            },\n            truncate (path, len) {\n                if (len < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: true\n                    });\n                    node = lookup.node;\n                } else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isDir(node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!FS.isFile(node.mode)) {\n                    throw new FS.ErrnoError(28);\n                }\n                var errCode = FS.nodePermissions(node, \"w\");\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                node.node_ops.setattr(node, {\n                    size: len,\n                    timestamp: Date.now()\n                });\n            },\n            ftruncate (fd, len) {\n                var stream = FS.getStreamChecked(fd);\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                FS.truncate(stream.node, len);\n            },\n            utime (path, atime, mtime) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                node.node_ops.setattr(node, {\n                    timestamp: Math.max(atime, mtime)\n                });\n            },\n            open (path, flags, mode) {\n                if (path === \"\") {\n                    throw new FS.ErrnoError(44);\n                }\n                flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\n                mode = typeof mode == \"undefined\" ? 438 : mode;\n                if (flags & 64) {\n                    mode = mode & 4095 | 32768;\n                } else {\n                    mode = 0;\n                }\n                var node;\n                if (typeof path == \"object\") {\n                    node = path;\n                } else {\n                    path = PATH.normalize(path);\n                    try {\n                        var lookup = FS.lookupPath(path, {\n                            follow: !(flags & 131072)\n                        });\n                        node = lookup.node;\n                    } catch (e) {}\n                }\n                var created = false;\n                if (flags & 64) {\n                    if (node) {\n                        if (flags & 128) {\n                            throw new FS.ErrnoError(20);\n                        }\n                    } else {\n                        node = FS.mknod(path, mode, 0);\n                        created = true;\n                    }\n                }\n                if (!node) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (FS.isChrdev(node.mode)) {\n                    flags &= ~512;\n                }\n                if (flags & 65536 && !FS.isDir(node.mode)) {\n                    throw new FS.ErrnoError(54);\n                }\n                if (!created) {\n                    var errCode = FS.mayOpen(node, flags);\n                    if (errCode) {\n                        throw new FS.ErrnoError(errCode);\n                    }\n                }\n                if (flags & 512 && !created) {\n                    FS.truncate(node, 0);\n                }\n                flags &= ~(128 | 512 | 131072);\n                var stream = FS.createStream({\n                    node: node,\n                    path: FS.getPath(node),\n                    flags: flags,\n                    seekable: true,\n                    position: 0,\n                    stream_ops: node.stream_ops,\n                    ungotten: [],\n                    error: false\n                });\n                if (stream.stream_ops.open) {\n                    stream.stream_ops.open(stream);\n                }\n                if (Module[\"logReadFiles\"] && !(flags & 1)) {\n                    if (!FS.readFiles) FS.readFiles = {};\n                    if (!(path in FS.readFiles)) {\n                        FS.readFiles[path] = 1;\n                    }\n                }\n                return stream;\n            },\n            close (stream) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (stream.getdents) stream.getdents = null;\n                try {\n                    if (stream.stream_ops.close) {\n                        stream.stream_ops.close(stream);\n                    }\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.closeStream(stream.fd);\n                }\n                stream.fd = null;\n            },\n            isClosed (stream) {\n                return stream.fd === null;\n            },\n            llseek (stream, offset, whence) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (!stream.seekable || !stream.stream_ops.llseek) {\n                    throw new FS.ErrnoError(70);\n                }\n                if (whence != 0 && whence != 1 && whence != 2) {\n                    throw new FS.ErrnoError(28);\n                }\n                stream.position = stream.stream_ops.llseek(stream, offset, whence);\n                stream.ungotten = [];\n                return stream.position;\n            },\n            read (stream, buffer, offset, length, position) {\n                if (length < 0 || position < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if ((stream.flags & 2097155) === 1) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!stream.stream_ops.read) {\n                    throw new FS.ErrnoError(28);\n                }\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) {\n                    position = stream.position;\n                } else if (!stream.seekable) {\n                    throw new FS.ErrnoError(70);\n                }\n                var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n                if (!seeking) stream.position += bytesRead;\n                return bytesRead;\n            },\n            write (stream, buffer, offset, length, position, canOwn) {\n                if (length < 0 || position < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!stream.stream_ops.write) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (stream.seekable && stream.flags & 1024) {\n                    FS.llseek(stream, 0, 2);\n                }\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) {\n                    position = stream.position;\n                } else if (!stream.seekable) {\n                    throw new FS.ErrnoError(70);\n                }\n                var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n                if (!seeking) stream.position += bytesWritten;\n                return bytesWritten;\n            },\n            allocate (stream, offset, length) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (offset < 0 || length <= 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(43);\n                }\n                if (!stream.stream_ops.allocate) {\n                    throw new FS.ErrnoError(138);\n                }\n                stream.stream_ops.allocate(stream, offset, length);\n            },\n            mmap (stream, length, position, prot, flags) {\n                if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n                    throw new FS.ErrnoError(2);\n                }\n                if ((stream.flags & 2097155) === 1) {\n                    throw new FS.ErrnoError(2);\n                }\n                if (!stream.stream_ops.mmap) {\n                    throw new FS.ErrnoError(43);\n                }\n                return stream.stream_ops.mmap(stream, length, position, prot, flags);\n            },\n            msync (stream, buffer, offset, length, mmapFlags) {\n                if (!stream.stream_ops.msync) {\n                    return 0;\n                }\n                return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n            },\n            munmap: (stream)=>0,\n            ioctl (stream, cmd, arg) {\n                if (!stream.stream_ops.ioctl) {\n                    throw new FS.ErrnoError(59);\n                }\n                return stream.stream_ops.ioctl(stream, cmd, arg);\n            },\n            readFile (path) {\n                let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                opts.flags = opts.flags || 0;\n                opts.encoding = opts.encoding || \"binary\";\n                if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n                    throw new Error('Invalid encoding type \"'.concat(opts.encoding, '\"'));\n                }\n                var ret;\n                var stream = FS.open(path, opts.flags);\n                var stat = FS.stat(path);\n                var length = stat.size;\n                var buf = new Uint8Array(length);\n                FS.read(stream, buf, 0, length, 0);\n                if (opts.encoding === \"utf8\") {\n                    ret = UTF8ArrayToString(buf, 0);\n                } else if (opts.encoding === \"binary\") {\n                    ret = buf;\n                }\n                FS.close(stream);\n                return ret;\n            },\n            writeFile (path, data) {\n                let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                opts.flags = opts.flags || 577;\n                var stream = FS.open(path, opts.flags, opts.mode);\n                if (typeof data == \"string\") {\n                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n                } else if (ArrayBuffer.isView(data)) {\n                    FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n                } else {\n                    throw new Error(\"Unsupported data type\");\n                }\n                FS.close(stream);\n            },\n            cwd: ()=>FS.currentPath,\n            chdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                if (lookup.node === null) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!FS.isDir(lookup.node.mode)) {\n                    throw new FS.ErrnoError(54);\n                }\n                var errCode = FS.nodePermissions(lookup.node, \"x\");\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                FS.currentPath = lookup.path;\n            },\n            createDefaultDirectories () {\n                FS.mkdir(\"/tmp\");\n                FS.mkdir(\"/home\");\n                FS.mkdir(\"/home/web_user\");\n            },\n            createDefaultDevices () {\n                FS.mkdir(\"/dev\");\n                FS.registerDevice(FS.makedev(1, 3), {\n                    read: ()=>0,\n                    write: (stream, buffer, offset, length, pos)=>length\n                });\n                FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n                TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n                TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n                FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n                FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n                var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n                var randomByte = ()=>{\n                    if (randomLeft === 0) {\n                        randomLeft = randomFill(randomBuffer).byteLength;\n                    }\n                    return randomBuffer[--randomLeft];\n                };\n                FS.createDevice(\"/dev\", \"random\", randomByte);\n                FS.createDevice(\"/dev\", \"urandom\", randomByte);\n                FS.mkdir(\"/dev/shm\");\n                FS.mkdir(\"/dev/shm/tmp\");\n            },\n            createSpecialDirectories () {\n                FS.mkdir(\"/proc\");\n                var proc_self = FS.mkdir(\"/proc/self\");\n                FS.mkdir(\"/proc/self/fd\");\n                FS.mount({\n                    mount () {\n                        var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n                        node.node_ops = {\n                            lookup (parent, name) {\n                                var fd = +name;\n                                var stream = FS.getStreamChecked(fd);\n                                var ret = {\n                                    parent: null,\n                                    mount: {\n                                        mountpoint: \"fake\"\n                                    },\n                                    node_ops: {\n                                        readlink: ()=>stream.path\n                                    }\n                                };\n                                ret.parent = ret;\n                                return ret;\n                            }\n                        };\n                        return node;\n                    }\n                }, {}, \"/proc/self/fd\");\n            },\n            createStandardStreams () {\n                if (Module[\"stdin\"]) {\n                    FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n                } else {\n                    FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n                }\n                if (Module[\"stdout\"]) {\n                    FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n                } else {\n                    FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n                }\n                if (Module[\"stderr\"]) {\n                    FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n                } else {\n                    FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n                }\n                var stdin = FS.open(\"/dev/stdin\", 0);\n                var stdout = FS.open(\"/dev/stdout\", 1);\n                var stderr = FS.open(\"/dev/stderr\", 1);\n            },\n            ensureErrnoError () {\n                if (FS.ErrnoError) return;\n                FS.ErrnoError = function ErrnoError(errno, node) {\n                    this.name = \"ErrnoError\";\n                    this.node = node;\n                    this.setErrno = function(errno) {\n                        this.errno = errno;\n                    };\n                    this.setErrno(errno);\n                    this.message = \"FS error\";\n                };\n                FS.ErrnoError.prototype = new Error;\n                FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n                [\n                    44\n                ].forEach((code)=>{\n                    FS.genericErrors[code] = new FS.ErrnoError(code);\n                    FS.genericErrors[code].stack = \"<generic error, no stack>\";\n                });\n            },\n            staticInit () {\n                FS.ensureErrnoError();\n                FS.nameTable = new Array(4096);\n                FS.mount(MEMFS, {}, \"/\");\n                FS.createDefaultDirectories();\n                FS.createDefaultDevices();\n                FS.createSpecialDirectories();\n                FS.filesystems = {\n                    \"MEMFS\": MEMFS\n                };\n            },\n            init (input, output, error) {\n                FS.init.initialized = true;\n                FS.ensureErrnoError();\n                Module[\"stdin\"] = input || Module[\"stdin\"];\n                Module[\"stdout\"] = output || Module[\"stdout\"];\n                Module[\"stderr\"] = error || Module[\"stderr\"];\n                FS.createStandardStreams();\n            },\n            quit () {\n                FS.init.initialized = false;\n                for(var i = 0; i < FS.streams.length; i++){\n                    var stream = FS.streams[i];\n                    if (!stream) {\n                        continue;\n                    }\n                    FS.close(stream);\n                }\n            },\n            findObject (path, dontResolveLastLink) {\n                var ret = FS.analyzePath(path, dontResolveLastLink);\n                if (!ret.exists) {\n                    return null;\n                }\n                return ret.object;\n            },\n            analyzePath (path, dontResolveLastLink) {\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    path = lookup.path;\n                } catch (e) {}\n                var ret = {\n                    isRoot: false,\n                    exists: false,\n                    error: 0,\n                    name: null,\n                    path: null,\n                    object: null,\n                    parentExists: false,\n                    parentPath: null,\n                    parentObject: null\n                };\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        parent: true\n                    });\n                    ret.parentExists = true;\n                    ret.parentPath = lookup.path;\n                    ret.parentObject = lookup.node;\n                    ret.name = PATH.basename(path);\n                    lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    ret.exists = true;\n                    ret.path = lookup.path;\n                    ret.object = lookup.node;\n                    ret.name = lookup.node.name;\n                    ret.isRoot = lookup.path === \"/\";\n                } catch (e) {\n                    ret.error = e.errno;\n                }\n                return ret;\n            },\n            createPath (parent, path, canRead, canWrite) {\n                parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                var parts = path.split(\"/\").reverse();\n                while(parts.length){\n                    var part = parts.pop();\n                    if (!part) continue;\n                    var current = PATH.join2(parent, part);\n                    try {\n                        FS.mkdir(current);\n                    } catch (e) {}\n                    parent = current;\n                }\n                return current;\n            },\n            createFile (parent, name, properties, canRead, canWrite) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(canRead, canWrite);\n                return FS.create(path, mode);\n            },\n            createDataFile (parent, name, data, canRead, canWrite, canOwn) {\n                var path = name;\n                if (parent) {\n                    parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                    path = name ? PATH.join2(parent, name) : parent;\n                }\n                var mode = FS_getMode(canRead, canWrite);\n                var node = FS.create(path, mode);\n                if (data) {\n                    if (typeof data == \"string\") {\n                        var arr = new Array(data.length);\n                        for(var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i);\n                        data = arr;\n                    }\n                    FS.chmod(node, mode | 146);\n                    var stream = FS.open(node, 577);\n                    FS.write(stream, data, 0, data.length, 0, canOwn);\n                    FS.close(stream);\n                    FS.chmod(node, mode);\n                }\n                return node;\n            },\n            createDevice (parent, name, input, output) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(!!input, !!output);\n                if (!FS.createDevice.major) FS.createDevice.major = 64;\n                var dev = FS.makedev(FS.createDevice.major++, 0);\n                FS.registerDevice(dev, {\n                    open (stream) {\n                        stream.seekable = false;\n                    },\n                    close (stream) {\n                        if (output && output.buffer && output.buffer.length) {\n                            output(10);\n                        }\n                    },\n                    read (stream, buffer, offset, length, pos) {\n                        var bytesRead = 0;\n                        for(var i = 0; i < length; i++){\n                            var result;\n                            try {\n                                result = input();\n                            } catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                            if (result === undefined && bytesRead === 0) {\n                                throw new FS.ErrnoError(6);\n                            }\n                            if (result === null || result === undefined) break;\n                            bytesRead++;\n                            buffer[offset + i] = result;\n                        }\n                        if (bytesRead) {\n                            stream.node.timestamp = Date.now();\n                        }\n                        return bytesRead;\n                    },\n                    write (stream, buffer, offset, length, pos) {\n                        for(var i = 0; i < length; i++){\n                            try {\n                                output(buffer[offset + i]);\n                            } catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                        }\n                        if (length) {\n                            stream.node.timestamp = Date.now();\n                        }\n                        return i;\n                    }\n                });\n                return FS.mkdev(path, mode, dev);\n            },\n            forceLoadFile (obj) {\n                if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n                if (typeof XMLHttpRequest != \"undefined\") {\n                    throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n                } else if (read_) {\n                    try {\n                        obj.contents = intArrayFromString(read_(obj.url), true);\n                        obj.usedBytes = obj.contents.length;\n                    } catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                } else {\n                    throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n                }\n            },\n            createLazyFile (parent, name, url, canRead, canWrite) {\n                function LazyUint8Array() {\n                    this.lengthKnown = false;\n                    this.chunks = [];\n                }\n                LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n                    if (idx > this.length - 1 || idx < 0) {\n                        return undefined;\n                    }\n                    var chunkOffset = idx % this.chunkSize;\n                    var chunkNum = idx / this.chunkSize | 0;\n                    return this.getter(chunkNum)[chunkOffset];\n                };\n                LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n                    this.getter = getter;\n                };\n                LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n                    var xhr = new XMLHttpRequest;\n                    xhr.open(\"HEAD\", url, false);\n                    xhr.send(null);\n                    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                    var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n                    var header;\n                    var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n                    var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n                    var chunkSize = 1024 * 1024;\n                    if (!hasByteServing) chunkSize = datalength;\n                    var doXHR = (from, to)=>{\n                        if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n                        if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n                        var xhr = new XMLHttpRequest;\n                        xhr.open(\"GET\", url, false);\n                        if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n                        xhr.responseType = \"arraybuffer\";\n                        if (xhr.overrideMimeType) {\n                            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n                        }\n                        xhr.send(null);\n                        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                        if (xhr.response !== undefined) {\n                            return new Uint8Array(xhr.response || []);\n                        }\n                        return intArrayFromString(xhr.responseText || \"\", true);\n                    };\n                    var lazyArray = this;\n                    lazyArray.setDataGetter((chunkNum)=>{\n                        var start = chunkNum * chunkSize;\n                        var end = (chunkNum + 1) * chunkSize - 1;\n                        end = Math.min(end, datalength - 1);\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\n                            lazyArray.chunks[chunkNum] = doXHR(start, end);\n                        }\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\n                        return lazyArray.chunks[chunkNum];\n                    });\n                    if (usesGzip || !datalength) {\n                        chunkSize = datalength = 1;\n                        datalength = this.getter(0).length;\n                        chunkSize = datalength;\n                        out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n                    }\n                    this._length = datalength;\n                    this._chunkSize = chunkSize;\n                    this.lengthKnown = true;\n                };\n                if (typeof XMLHttpRequest != \"undefined\") {\n                    if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n                    var lazyArray = new LazyUint8Array;\n                    Object.defineProperties(lazyArray, {\n                        length: {\n                            get: function() {\n                                if (!this.lengthKnown) {\n                                    this.cacheLength();\n                                }\n                                return this._length;\n                            }\n                        },\n                        chunkSize: {\n                            get: function() {\n                                if (!this.lengthKnown) {\n                                    this.cacheLength();\n                                }\n                                return this._chunkSize;\n                            }\n                        }\n                    });\n                    var properties = {\n                        isDevice: false,\n                        contents: lazyArray\n                    };\n                } else {\n                    var properties = {\n                        isDevice: false,\n                        url: url\n                    };\n                }\n                var node = FS.createFile(parent, name, properties, canRead, canWrite);\n                if (properties.contents) {\n                    node.contents = properties.contents;\n                } else if (properties.url) {\n                    node.contents = null;\n                    node.url = properties.url;\n                }\n                Object.defineProperties(node, {\n                    usedBytes: {\n                        get: function() {\n                            return this.contents.length;\n                        }\n                    }\n                });\n                var stream_ops = {};\n                var keys = Object.keys(node.stream_ops);\n                keys.forEach((key)=>{\n                    var fn = node.stream_ops[key];\n                    stream_ops[key] = function forceLoadLazyFile() {\n                        FS.forceLoadFile(node);\n                        return fn.apply(null, arguments);\n                    };\n                });\n                function writeChunks(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= contents.length) return 0;\n                    var size = Math.min(contents.length - position, length);\n                    if (contents.slice) {\n                        for(var i = 0; i < size; i++){\n                            buffer[offset + i] = contents[position + i];\n                        }\n                    } else {\n                        for(var i = 0; i < size; i++){\n                            buffer[offset + i] = contents.get(position + i);\n                        }\n                    }\n                    return size;\n                }\n                stream_ops.read = (stream, buffer, offset, length, position)=>{\n                    FS.forceLoadFile(node);\n                    return writeChunks(stream, buffer, offset, length, position);\n                };\n                stream_ops.mmap = (stream, length, position, prot, flags)=>{\n                    FS.forceLoadFile(node);\n                    var ptr = mmapAlloc(length);\n                    if (!ptr) {\n                        throw new FS.ErrnoError(48);\n                    }\n                    writeChunks(stream, HEAP8, ptr, length, position);\n                    return {\n                        ptr: ptr,\n                        allocated: true\n                    };\n                };\n                node.stream_ops = stream_ops;\n                return node;\n            }\n        };\n        var SYSCALLS = {\n            DEFAULT_POLLMASK: 5,\n            calculateAt (dirfd, path, allowEmpty) {\n                if (PATH.isAbs(path)) {\n                    return path;\n                }\n                var dir;\n                if (dirfd === -100) {\n                    dir = FS.cwd();\n                } else {\n                    var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n                    dir = dirstream.path;\n                }\n                if (path.length == 0) {\n                    if (!allowEmpty) {\n                        throw new FS.ErrnoError(44);\n                    }\n                    return dir;\n                }\n                return PATH.join2(dir, path);\n            },\n            doStat (func, path, buf) {\n                try {\n                    var stat = func(path);\n                } catch (e) {\n                    if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n                        return -54;\n                    }\n                    throw e;\n                }\n                HEAP32[buf >> 2] = stat.dev;\n                HEAP32[buf + 4 >> 2] = stat.mode;\n                HEAPU32[buf + 8 >> 2] = stat.nlink;\n                HEAP32[buf + 12 >> 2] = stat.uid;\n                HEAP32[buf + 16 >> 2] = stat.gid;\n                HEAP32[buf + 20 >> 2] = stat.rdev;\n                tempI64 = [\n                    stat.size >>> 0,\n                    (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];\n                HEAP32[buf + 32 >> 2] = 4096;\n                HEAP32[buf + 36 >> 2] = stat.blocks;\n                var atime = stat.atime.getTime();\n                var mtime = stat.mtime.getTime();\n                var ctime = stat.ctime.getTime();\n                tempI64 = [\n                    Math.floor(atime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n                HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;\n                tempI64 = [\n                    Math.floor(mtime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];\n                HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;\n                tempI64 = [\n                    Math.floor(ctime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];\n                HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;\n                tempI64 = [\n                    stat.ino >>> 0,\n                    (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];\n                return 0;\n            },\n            doMsync (addr, stream, len, flags, offset) {\n                if (!FS.isFile(stream.node.mode)) {\n                    throw new FS.ErrnoError(43);\n                }\n                if (flags & 2) {\n                    return 0;\n                }\n                var buffer = HEAPU8.slice(addr, addr + len);\n                FS.msync(stream, buffer, offset, len, flags);\n            },\n            varargs: undefined,\n            get () {\n                var ret = HEAP32[+SYSCALLS.varargs >> 2];\n                SYSCALLS.varargs += 4;\n                return ret;\n            },\n            getp () {\n                return SYSCALLS.get();\n            },\n            getStr (ptr) {\n                var ret = UTF8ToString(ptr);\n                return ret;\n            },\n            getStreamFromFD (fd) {\n                var stream = FS.getStreamChecked(fd);\n                return stream;\n            }\n        };\n        var _environ_get = (__environ, environ_buf)=>{\n            var bufSize = 0;\n            getEnvStrings().forEach((string, i)=>{\n                var ptr = environ_buf + bufSize;\n                HEAPU32[__environ + i * 4 >> 2] = ptr;\n                stringToAscii(string, ptr);\n                bufSize += string.length + 1;\n            });\n            return 0;\n        };\n        var _environ_sizes_get = (penviron_count, penviron_buf_size)=>{\n            var strings = getEnvStrings();\n            HEAPU32[penviron_count >> 2] = strings.length;\n            var bufSize = 0;\n            strings.forEach((string)=>bufSize += string.length + 1);\n            HEAPU32[penviron_buf_size >> 2] = bufSize;\n            return 0;\n        };\n        function _fd_close(fd) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.close(stream);\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var doReadv = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = HEAPU32[iov >> 2];\n                var len = HEAPU32[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.read(stream, HEAP8, ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (curr < len) break;\n                if (typeof offset !== \"undefined\") {\n                    offset += curr;\n                }\n            }\n            return ret;\n        };\n        function _fd_read(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doReadv(stream, iov, iovcnt);\n                HEAPU32[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var convertI32PairToI53Checked = (lo, hi)=>hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n            var offset = convertI32PairToI53Checked(offset_low, offset_high);\n            try {\n                if (isNaN(offset)) return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.llseek(stream, offset, whence);\n                tempI64 = [\n                    stream.position >>> 0,\n                    (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n                if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var doWritev = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = HEAPU32[iov >> 2];\n                var len = HEAPU32[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.write(stream, HEAP8, ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (typeof offset !== \"undefined\") {\n                    offset += curr;\n                }\n            }\n            return ret;\n        };\n        function _fd_write(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doWritev(stream, iov, iovcnt);\n                HEAPU32[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var isLeapYear = (year)=>year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        var arraySum = (array, index)=>{\n            var sum = 0;\n            for(var i = 0; i <= index; sum += array[i++]){}\n            return sum;\n        };\n        var MONTH_DAYS_LEAP = [\n            31,\n            29,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var MONTH_DAYS_REGULAR = [\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var addDays = (date, days)=>{\n            var newDate = new Date(date.getTime());\n            while(days > 0){\n                var leap = isLeapYear(newDate.getFullYear());\n                var currentMonth = newDate.getMonth();\n                var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n                if (days > daysInCurrentMonth - newDate.getDate()) {\n                    days -= daysInCurrentMonth - newDate.getDate() + 1;\n                    newDate.setDate(1);\n                    if (currentMonth < 11) {\n                        newDate.setMonth(currentMonth + 1);\n                    } else {\n                        newDate.setMonth(0);\n                        newDate.setFullYear(newDate.getFullYear() + 1);\n                    }\n                } else {\n                    newDate.setDate(newDate.getDate() + days);\n                    return newDate;\n                }\n            }\n            return newDate;\n        };\n        var writeArrayToMemory = (array, buffer)=>{\n            HEAP8.set(array, buffer);\n        };\n        var _strftime = (s, maxsize, format, tm)=>{\n            var tm_zone = HEAPU32[tm + 40 >> 2];\n            var date = {\n                tm_sec: HEAP32[tm >> 2],\n                tm_min: HEAP32[tm + 4 >> 2],\n                tm_hour: HEAP32[tm + 8 >> 2],\n                tm_mday: HEAP32[tm + 12 >> 2],\n                tm_mon: HEAP32[tm + 16 >> 2],\n                tm_year: HEAP32[tm + 20 >> 2],\n                tm_wday: HEAP32[tm + 24 >> 2],\n                tm_yday: HEAP32[tm + 28 >> 2],\n                tm_isdst: HEAP32[tm + 32 >> 2],\n                tm_gmtoff: HEAP32[tm + 36 >> 2],\n                tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n            };\n            var pattern = UTF8ToString(format);\n            var EXPANSION_RULES_1 = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n            };\n            for(var rule in EXPANSION_RULES_1){\n                pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n            }\n            var WEEKDAYS = [\n                \"Sunday\",\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\"\n            ];\n            var MONTHS = [\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\"\n            ];\n            function leadingSomething(value, digits, character) {\n                var str = typeof value == \"number\" ? value.toString() : value || \"\";\n                while(str.length < digits){\n                    str = character[0] + str;\n                }\n                return str;\n            }\n            function leadingNulls(value, digits) {\n                return leadingSomething(value, digits, \"0\");\n            }\n            function compareByDay(date1, date2) {\n                function sgn(value) {\n                    return value < 0 ? -1 : value > 0 ? 1 : 0;\n                }\n                var compare;\n                if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n                    if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n                        compare = sgn(date1.getDate() - date2.getDate());\n                    }\n                }\n                return compare;\n            }\n            function getFirstWeekStartDate(janFourth) {\n                switch(janFourth.getDay()){\n                    case 0:\n                        return new Date(janFourth.getFullYear() - 1, 11, 29);\n                    case 1:\n                        return janFourth;\n                    case 2:\n                        return new Date(janFourth.getFullYear(), 0, 3);\n                    case 3:\n                        return new Date(janFourth.getFullYear(), 0, 2);\n                    case 4:\n                        return new Date(janFourth.getFullYear(), 0, 1);\n                    case 5:\n                        return new Date(janFourth.getFullYear() - 1, 11, 31);\n                    case 6:\n                        return new Date(janFourth.getFullYear() - 1, 11, 30);\n                }\n            }\n            function getWeekBasedYear(date) {\n                var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n                var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n                var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n                var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n                var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n                if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n                    if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n                        return thisDate.getFullYear() + 1;\n                    }\n                    return thisDate.getFullYear();\n                }\n                return thisDate.getFullYear() - 1;\n            }\n            var EXPANSION_RULES_2 = {\n                \"%a\": (date)=>WEEKDAYS[date.tm_wday].substring(0, 3),\n                \"%A\": (date)=>WEEKDAYS[date.tm_wday],\n                \"%b\": (date)=>MONTHS[date.tm_mon].substring(0, 3),\n                \"%B\": (date)=>MONTHS[date.tm_mon],\n                \"%C\": (date)=>{\n                    var year = date.tm_year + 1900;\n                    return leadingNulls(year / 100 | 0, 2);\n                },\n                \"%d\": (date)=>leadingNulls(date.tm_mday, 2),\n                \"%e\": (date)=>leadingSomething(date.tm_mday, 2, \" \"),\n                \"%g\": (date)=>getWeekBasedYear(date).toString().substring(2),\n                \"%G\": (date)=>getWeekBasedYear(date),\n                \"%H\": (date)=>leadingNulls(date.tm_hour, 2),\n                \"%I\": (date)=>{\n                    var twelveHour = date.tm_hour;\n                    if (twelveHour == 0) twelveHour = 12;\n                    else if (twelveHour > 12) twelveHour -= 12;\n                    return leadingNulls(twelveHour, 2);\n                },\n                \"%j\": (date)=>leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3),\n                \"%m\": (date)=>leadingNulls(date.tm_mon + 1, 2),\n                \"%M\": (date)=>leadingNulls(date.tm_min, 2),\n                \"%n\": ()=>\"\\n\",\n                \"%p\": (date)=>{\n                    if (date.tm_hour >= 0 && date.tm_hour < 12) {\n                        return \"AM\";\n                    }\n                    return \"PM\";\n                },\n                \"%S\": (date)=>leadingNulls(date.tm_sec, 2),\n                \"%t\": ()=>\"\t\",\n                \"%u\": (date)=>date.tm_wday || 7,\n                \"%U\": (date)=>{\n                    var days = date.tm_yday + 7 - date.tm_wday;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%V\": (date)=>{\n                    var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);\n                    if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n                        val++;\n                    }\n                    if (!val) {\n                        val = 52;\n                        var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n                        if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) {\n                            val++;\n                        }\n                    } else if (val == 53) {\n                        var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n                        if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1;\n                    }\n                    return leadingNulls(val, 2);\n                },\n                \"%w\": (date)=>date.tm_wday,\n                \"%W\": (date)=>{\n                    var days = date.tm_yday + 7 - (date.tm_wday + 6) % 7;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%y\": (date)=>(date.tm_year + 1900).toString().substring(2),\n                \"%Y\": (date)=>date.tm_year + 1900,\n                \"%z\": (date)=>{\n                    var off = date.tm_gmtoff;\n                    var ahead = off >= 0;\n                    off = Math.abs(off) / 60;\n                    off = off / 60 * 100 + off % 60;\n                    return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n                },\n                \"%Z\": (date)=>date.tm_zone,\n                \"%%\": ()=>\"%\"\n            };\n            pattern = pattern.replace(/%%/g, \"\\x00\\x00\");\n            for(var rule in EXPANSION_RULES_2){\n                if (pattern.includes(rule)) {\n                    pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n                }\n            }\n            pattern = pattern.replace(/\\0\\0/g, \"%\");\n            var bytes = intArrayFromString(pattern, false);\n            if (bytes.length > maxsize) {\n                return 0;\n            }\n            writeArrayToMemory(bytes, s);\n            return bytes.length - 1;\n        };\n        var _strftime_l = (s, maxsize, format, tm, loc)=>_strftime(s, maxsize, format, tm);\n        var getCFunc = (ident)=>{\n            var func = Module[\"_\" + ident];\n            return func;\n        };\n        var stringToUTF8OnStack = (str)=>{\n            var size = lengthBytesUTF8(str) + 1;\n            var ret = stackAlloc(size);\n            stringToUTF8(str, ret, size);\n            return ret;\n        };\n        var ccall = (ident, returnType, argTypes, args, opts)=>{\n            var toC = {\n                \"string\": (str)=>{\n                    var ret = 0;\n                    if (str !== null && str !== undefined && str !== 0) {\n                        ret = stringToUTF8OnStack(str);\n                    }\n                    return ret;\n                },\n                \"array\": (arr)=>{\n                    var ret = stackAlloc(arr.length);\n                    writeArrayToMemory(arr, ret);\n                    return ret;\n                }\n            };\n            function convertReturnValue(ret) {\n                if (returnType === \"string\") {\n                    return UTF8ToString(ret);\n                }\n                if (returnType === \"boolean\") return Boolean(ret);\n                return ret;\n            }\n            var func = getCFunc(ident);\n            var cArgs = [];\n            var stack = 0;\n            if (args) {\n                for(var i = 0; i < args.length; i++){\n                    var converter = toC[argTypes[i]];\n                    if (converter) {\n                        if (stack === 0) stack = stackSave();\n                        cArgs[i] = converter(args[i]);\n                    } else {\n                        cArgs[i] = args[i];\n                    }\n                }\n            }\n            var ret = func.apply(null, cArgs);\n            function onDone(ret) {\n                if (stack !== 0) stackRestore(stack);\n                return convertReturnValue(ret);\n            }\n            ret = onDone(ret);\n            return ret;\n        };\n        InternalError = Module[\"InternalError\"] = class InternalError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"InternalError\";\n            }\n        };\n        embind_init_charCodes();\n        BindingError = Module[\"BindingError\"] = class BindingError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"BindingError\";\n            }\n        };\n        init_ClassHandle();\n        init_embind();\n        init_RegisteredPointer();\n        UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n        handleAllocatorInit();\n        init_emval();\n        var FSNode = function(parent, name, mode, rdev) {\n            if (!parent) {\n                parent = this;\n            }\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n        };\n        var readMode = 292 | 73;\n        var writeMode = 146;\n        Object.defineProperties(FSNode.prototype, {\n            read: {\n                get: function() {\n                    return (this.mode & readMode) === readMode;\n                },\n                set: function(val) {\n                    val ? this.mode |= readMode : this.mode &= ~readMode;\n                }\n            },\n            write: {\n                get: function() {\n                    return (this.mode & writeMode) === writeMode;\n                },\n                set: function(val) {\n                    val ? this.mode |= writeMode : this.mode &= ~writeMode;\n                }\n            },\n            isFolder: {\n                get: function() {\n                    return FS.isDir(this.mode);\n                }\n            },\n            isDevice: {\n                get: function() {\n                    return FS.isChrdev(this.mode);\n                }\n            }\n        });\n        FS.FSNode = FSNode;\n        FS.createPreloadedFile = FS_createPreloadedFile;\n        FS.staticInit();\n        var wasmImports = {\n            d: ___cxa_throw,\n            n: __embind_finalize_value_array,\n            l: __embind_finalize_value_object,\n            w: __embind_register_bigint,\n            G: __embind_register_bool,\n            h: __embind_register_class,\n            g: __embind_register_class_constructor,\n            c: __embind_register_class_function,\n            q: __embind_register_class_property,\n            F: __embind_register_emval,\n            p: __embind_register_enum,\n            i: __embind_register_enum_value,\n            t: __embind_register_float,\n            a: __embind_register_function,\n            j: __embind_register_integer,\n            e: __embind_register_memory_view,\n            u: __embind_register_std_string,\n            r: __embind_register_std_wstring,\n            o: __embind_register_value_array,\n            b: __embind_register_value_array_element,\n            m: __embind_register_value_object,\n            f: __embind_register_value_object_field,\n            H: __embind_register_void,\n            I: __emval_decref,\n            J: __emval_incref,\n            k: __emval_take_value,\n            s: _abort,\n            E: _emscripten_memcpy_js,\n            y: _emscripten_resize_heap,\n            z: _environ_get,\n            A: _environ_sizes_get,\n            B: _fd_close,\n            D: _fd_read,\n            v: _fd_seek,\n            C: _fd_write,\n            x: _strftime_l\n        };\n        var wasmExports = createWasm();\n        var ___wasm_call_ctors = ()=>(___wasm_call_ctors = wasmExports[\"L\"])();\n        var _malloc = Module[\"_malloc\"] = (a0)=>(_malloc = Module[\"_malloc\"] = wasmExports[\"M\"])(a0);\n        var _free = Module[\"_free\"] = (a0)=>(_free = Module[\"_free\"] = wasmExports[\"N\"])(a0);\n        var ___getTypeName = (a0)=>(___getTypeName = wasmExports[\"P\"])(a0);\n        var __embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = ()=>(__embind_initialize_bindings = Module[\"__embind_initialize_bindings\"] = wasmExports[\"Q\"])();\n        var ___errno_location = ()=>(___errno_location = wasmExports[\"__errno_location\"])();\n        var stackSave = ()=>(stackSave = wasmExports[\"R\"])();\n        var stackRestore = (a0)=>(stackRestore = wasmExports[\"S\"])(a0);\n        var stackAlloc = (a0)=>(stackAlloc = wasmExports[\"T\"])(a0);\n        var ___cxa_increment_exception_refcount = (a0)=>(___cxa_increment_exception_refcount = wasmExports[\"__cxa_increment_exception_refcount\"])(a0);\n        var ___cxa_is_pointer_type = (a0)=>(___cxa_is_pointer_type = wasmExports[\"U\"])(a0);\n        var dynCall_jiji = Module[\"dynCall_jiji\"] = (a0, a1, a2, a3, a4)=>(dynCall_jiji = Module[\"dynCall_jiji\"] = wasmExports[\"V\"])(a0, a1, a2, a3, a4);\n        var dynCall_viijii = Module[\"dynCall_viijii\"] = (a0, a1, a2, a3, a4, a5, a6)=>(dynCall_viijii = Module[\"dynCall_viijii\"] = wasmExports[\"W\"])(a0, a1, a2, a3, a4, a5, a6);\n        var dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = (a0, a1, a2, a3, a4, a5, a6)=>(dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = wasmExports[\"X\"])(a0, a1, a2, a3, a4, a5, a6);\n        var dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8)=>(dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = wasmExports[\"Y\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n        var dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)=>(dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = wasmExports[\"Z\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n        Module[\"ccall\"] = ccall;\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n            if (!calledRun) run();\n            if (!calledRun) dependenciesFulfilled = runCaller;\n        };\n        function run() {\n            if (runDependencies > 0) {\n                return;\n            }\n            preRun();\n            if (runDependencies > 0) {\n                return;\n            }\n            function doRun() {\n                if (calledRun) return;\n                calledRun = true;\n                Module[\"calledRun\"] = true;\n                if (ABORT) return;\n                initRuntime();\n                readyPromiseResolve(Module);\n                if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n                postRun();\n            }\n            if (Module[\"setStatus\"]) {\n                Module[\"setStatus\"](\"Running...\");\n                setTimeout(function() {\n                    setTimeout(function() {\n                        Module[\"setStatus\"](\"\");\n                    }, 1);\n                    doRun();\n                }, 1);\n            } else {\n                doRun();\n            }\n        }\n        if (Module[\"preInit\"]) {\n            if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [\n                Module[\"preInit\"]\n            ];\n            while(Module[\"preInit\"].length > 0){\n                Module[\"preInit\"].pop()();\n            }\n        }\n        run();\n        return moduleArg.ready;\n    };\n})();\n/* harmony default export */ __webpack_exports__[\"default\"] = (Module);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3BsaW5ldG9vbC9ydW50aW1lL2J1aWxkL3Byb2Nlc3MuanMiLCJtYXBwaW5ncyI6IjtBQUNBLElBQUlBLFNBQVMsQ0FBQztJQUNaLElBQUlDLGFBQWEsT0FBT0MsYUFBYSxlQUFlQSxTQUFTQyxhQUFhLEdBQUdELFNBQVNDLGFBQWEsQ0FBQ0MsR0FBRyxHQUFHQztJQUUxRyxPQUNGO1lBQVNDLFlBQUFBLGlFQUFZLENBQUM7UUFFdEIsSUFBSU4sU0FBT007UUFBVSxJQUFJQyxxQkFBb0JDO1FBQW1CUixNQUFNLENBQUMsUUFBUSxHQUFDLElBQUlTLFFBQVEsQ0FBQ0MsU0FBUUM7WUFBVUosc0JBQW9CRztZQUFRRixxQkFBbUJHO1FBQU07UUFBRyxJQUFJQyxrQkFBZ0JDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUVkO1FBQVEsSUFBSWUsYUFBVyxFQUFFO1FBQUMsSUFBSUMsY0FBWTtRQUFpQixJQUFJQyxRQUFNLENBQUNDLFFBQU9DO1lBQVcsTUFBTUE7UUFBTztRQUFFLElBQUlDLHFCQUFtQjtRQUFLLElBQUlDLHdCQUFzQjtRQUFNLElBQUlDLGtCQUFnQjtRQUFHLFNBQVNDLFdBQVdDLElBQUk7WUFBRSxJQUFHeEIsTUFBTSxDQUFDLGFBQWEsRUFBQztnQkFBQyxPQUFPQSxNQUFNLENBQUMsYUFBYSxDQUFDd0IsTUFBS0Y7WUFBZ0I7WUFBQyxPQUFPQSxrQkFBZ0JFO1FBQUk7UUFBQyxJQUFJQyxPQUFNQyxXQUFVQztRQUFXLElBQUdQLHNCQUFvQkMsdUJBQXNCO1lBQUMsSUFBR0EsdUJBQXNCO2dCQUFDQyxrQkFBZ0JNLEtBQUtDLFFBQVEsQ0FBQ0MsSUFBSTtZQUFBLE9BQU0sSUFBRyxPQUFPNUIsWUFBVSxlQUFhQSxTQUFTQyxhQUFhLEVBQUM7Z0JBQUNtQixrQkFBZ0JwQixTQUFTQyxhQUFhLENBQUNDLEdBQUc7WUFBQTtZQUFDLElBQUdILFlBQVc7Z0JBQUNxQixrQkFBZ0JyQjtZQUFV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TSxHQUFDLEVBQUU7Z0JBQUNyRixNQUFNLENBQUMsVUFBVSxDQUFDK0ssR0FBRztZQUFJO1FBQUM7UUFBQ205QjtRQUd2dS9HLE9BQU81bkMsVUFBVStuQyxLQUFLO0lBQ3hCO0FBR0E7QUFDQSwrREFBZXJvQyxNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3BsaW5ldG9vbC9ydW50aW1lL2J1aWxkL3Byb2Nlc3MuanM/MGUwYiJdLCJzb3VyY2VzQ29udGVudCI6WyJcbnZhciBNb2R1bGUgPSAoKCkgPT4ge1xuICB2YXIgX3NjcmlwdERpciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuY3VycmVudFNjcmlwdCA/IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjIDogdW5kZWZpbmVkO1xuICBcbiAgcmV0dXJuIChcbmZ1bmN0aW9uKG1vZHVsZUFyZyA9IHt9KSB7XG5cbnZhciBNb2R1bGU9bW9kdWxlQXJnO3ZhciByZWFkeVByb21pc2VSZXNvbHZlLHJlYWR5UHJvbWlzZVJlamVjdDtNb2R1bGVbXCJyZWFkeVwiXT1uZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpPT57cmVhZHlQcm9taXNlUmVzb2x2ZT1yZXNvbHZlO3JlYWR5UHJvbWlzZVJlamVjdD1yZWplY3R9KTt2YXIgbW9kdWxlT3ZlcnJpZGVzPU9iamVjdC5hc3NpZ24oe30sTW9kdWxlKTt2YXIgYXJndW1lbnRzXz1bXTt2YXIgdGhpc1Byb2dyYW09XCIuL3RoaXMucHJvZ3JhbVwiO3ZhciBxdWl0Xz0oc3RhdHVzLHRvVGhyb3cpPT57dGhyb3cgdG9UaHJvd307dmFyIEVOVklST05NRU5UX0lTX1dFQj10cnVlO3ZhciBFTlZJUk9OTUVOVF9JU19XT1JLRVI9ZmFsc2U7dmFyIHNjcmlwdERpcmVjdG9yeT1cIlwiO2Z1bmN0aW9uIGxvY2F0ZUZpbGUocGF0aCl7aWYoTW9kdWxlW1wibG9jYXRlRmlsZVwiXSl7cmV0dXJuIE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0ocGF0aCxzY3JpcHREaXJlY3RvcnkpfXJldHVybiBzY3JpcHREaXJlY3RvcnkrcGF0aH12YXIgcmVhZF8scmVhZEFzeW5jLHJlYWRCaW5hcnk7aWYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpe2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7c2NyaXB0RGlyZWN0b3J5PXNlbGYubG9jYXRpb24uaHJlZn1lbHNlIGlmKHR5cGVvZiBkb2N1bWVudCE9XCJ1bmRlZmluZWRcIiYmZG9jdW1lbnQuY3VycmVudFNjcmlwdCl7c2NyaXB0RGlyZWN0b3J5PWRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjfWlmKF9zY3JpcHREaXIpe3NjcmlwdERpcmVjdG9yeT1fc2NyaXB0RGlyfWlmKHNjcmlwdERpcmVjdG9yeS5pbmRleE9mKFwiYmxvYjpcIikhPT0wKXtzY3JpcHREaXJlY3Rvcnk9c2NyaXB0RGlyZWN0b3J5LnN1YnN0cigwLHNjcmlwdERpcmVjdG9yeS5yZXBsYWNlKC9bPyNdLiovLFwiXCIpLmxhc3RJbmRleE9mKFwiL1wiKSsxKX1lbHNle3NjcmlwdERpcmVjdG9yeT1cIlwifXtyZWFkXz11cmw9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnNlbmQobnVsbCk7cmV0dXJuIHhoci5yZXNwb25zZVRleHR9O2lmKEVOVklST05NRU5UX0lTX1dPUktFUil7cmVhZEJpbmFyeT11cmw9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7eGhyLnNlbmQobnVsbCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSl9fXJlYWRBc3luYz0odXJsLG9ubG9hZCxvbmVycm9yKT0+e3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiR0VUXCIsdXJsLHRydWUpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5vbmxvYWQ9KCk9PntpZih4aHIuc3RhdHVzPT0yMDB8fHhoci5zdGF0dXM9PTAmJnhoci5yZXNwb25zZSl7b25sb2FkKHhoci5yZXNwb25zZSk7cmV0dXJufW9uZXJyb3IoKX07eGhyLm9uZXJyb3I9b25lcnJvcjt4aHIuc2VuZChudWxsKX19fWVsc2V7fXZhciBvdXQ9TW9kdWxlW1wicHJpbnRcIl18fGNvbnNvbGUubG9nLmJpbmQoY29uc29sZSk7dmFyIGVycj1Nb2R1bGVbXCJwcmludEVyclwiXXx8Y29uc29sZS5lcnJvci5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oTW9kdWxlLG1vZHVsZU92ZXJyaWRlcyk7bW9kdWxlT3ZlcnJpZGVzPW51bGw7aWYoTW9kdWxlW1wiYXJndW1lbnRzXCJdKWFyZ3VtZW50c189TW9kdWxlW1wiYXJndW1lbnRzXCJdO2lmKE1vZHVsZVtcInRoaXNQcm9ncmFtXCJdKXRoaXNQcm9ncmFtPU1vZHVsZVtcInRoaXNQcm9ncmFtXCJdO2lmKE1vZHVsZVtcInF1aXRcIl0pcXVpdF89TW9kdWxlW1wicXVpdFwiXTt2YXIgd2FzbUJpbmFyeTtpZihNb2R1bGVbXCJ3YXNtQmluYXJ5XCJdKXdhc21CaW5hcnk9TW9kdWxlW1wid2FzbUJpbmFyeVwiXTt2YXIgbm9FeGl0UnVudGltZT1Nb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdfHx0cnVlO2lmKHR5cGVvZiBXZWJBc3NlbWJseSE9XCJvYmplY3RcIil7YWJvcnQoXCJubyBuYXRpdmUgd2FzbSBzdXBwb3J0IGRldGVjdGVkXCIpfXZhciB3YXNtTWVtb3J5O3ZhciBBQk9SVD1mYWxzZTt2YXIgRVhJVFNUQVRVUztmdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLHRleHQpe2lmKCFjb25kaXRpb24pe2Fib3J0KHRleHQpfX12YXIgSEVBUDgsSEVBUFU4LEhFQVAxNixIRUFQVTE2LEhFQVAzMixIRUFQVTMyLEhFQVBGMzIsSEVBUEY2NDtmdW5jdGlvbiB1cGRhdGVNZW1vcnlWaWV3cygpe3ZhciBiPXdhc21NZW1vcnkuYnVmZmVyO01vZHVsZVtcIkhFQVA4XCJdPUhFQVA4PW5ldyBJbnQ4QXJyYXkoYik7TW9kdWxlW1wiSEVBUDE2XCJdPUhFQVAxNj1uZXcgSW50MTZBcnJheShiKTtNb2R1bGVbXCJIRUFQVThcIl09SEVBUFU4PW5ldyBVaW50OEFycmF5KGIpO01vZHVsZVtcIkhFQVBVMTZcIl09SEVBUFUxNj1uZXcgVWludDE2QXJyYXkoYik7TW9kdWxlW1wiSEVBUDMyXCJdPUhFQVAzMj1uZXcgSW50MzJBcnJheShiKTtNb2R1bGVbXCJIRUFQVTMyXCJdPUhFQVBVMzI9bmV3IFVpbnQzMkFycmF5KGIpO01vZHVsZVtcIkhFQVBGMzJcIl09SEVBUEYzMj1uZXcgRmxvYXQzMkFycmF5KGIpO01vZHVsZVtcIkhFQVBGNjRcIl09SEVBUEY2ND1uZXcgRmxvYXQ2NEFycmF5KGIpfXZhciBfX0FUUFJFUlVOX189W107dmFyIF9fQVRJTklUX189W107dmFyIF9fQVRQT1NUUlVOX189W107dmFyIHJ1bnRpbWVJbml0aWFsaXplZD1mYWxzZTtmdW5jdGlvbiBwcmVSdW4oKXtpZihNb2R1bGVbXCJwcmVSdW5cIl0pe2lmKHR5cGVvZiBNb2R1bGVbXCJwcmVSdW5cIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwcmVSdW5cIl09W01vZHVsZVtcInByZVJ1blwiXV07d2hpbGUoTW9kdWxlW1wicHJlUnVuXCJdLmxlbmd0aCl7YWRkT25QcmVSdW4oTW9kdWxlW1wicHJlUnVuXCJdLnNoaWZ0KCkpfX1jYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUUFJFUlVOX18pfWZ1bmN0aW9uIGluaXRSdW50aW1lKCl7cnVudGltZUluaXRpYWxpemVkPXRydWU7aWYoIU1vZHVsZVtcIm5vRlNJbml0XCJdJiYhRlMuaW5pdC5pbml0aWFsaXplZClGUy5pbml0KCk7RlMuaWdub3JlUGVybWlzc2lvbnM9ZmFsc2U7VFRZLmluaXQoKTtjYWxsUnVudGltZUNhbGxiYWNrcyhfX0FUSU5JVF9fKX1mdW5jdGlvbiBwb3N0UnVuKCl7aWYoTW9kdWxlW1wicG9zdFJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInBvc3RSdW5cIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwb3N0UnVuXCJdPVtNb2R1bGVbXCJwb3N0UnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwb3N0UnVuXCJdLmxlbmd0aCl7YWRkT25Qb3N0UnVuKE1vZHVsZVtcInBvc3RSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQT1NUUlVOX18pfWZ1bmN0aW9uIGFkZE9uUHJlUnVuKGNiKXtfX0FUUFJFUlVOX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Jbml0KGNiKXtfX0FUSU5JVF9fLnVuc2hpZnQoY2IpfWZ1bmN0aW9uIGFkZE9uUG9zdFJ1bihjYil7X19BVFBPU1RSVU5fXy51bnNoaWZ0KGNiKX12YXIgcnVuRGVwZW5kZW5jaWVzPTA7dmFyIHJ1bkRlcGVuZGVuY3lXYXRjaGVyPW51bGw7dmFyIGRlcGVuZGVuY2llc0Z1bGZpbGxlZD1udWxsO2Z1bmN0aW9uIGdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koaWQpe3JldHVybiBpZH1mdW5jdGlvbiBhZGRSdW5EZXBlbmRlbmN5KGlkKXtydW5EZXBlbmRlbmNpZXMrKztpZihNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKXtNb2R1bGVbXCJtb25pdG9yUnVuRGVwZW5kZW5jaWVzXCJdKHJ1bkRlcGVuZGVuY2llcyl9fWZ1bmN0aW9uIHJlbW92ZVJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcy0tO2lmKE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0pe01vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKX1pZihydW5EZXBlbmRlbmNpZXM9PTApe2lmKHJ1bkRlcGVuZGVuY3lXYXRjaGVyIT09bnVsbCl7Y2xlYXJJbnRlcnZhbChydW5EZXBlbmRlbmN5V2F0Y2hlcik7cnVuRGVwZW5kZW5jeVdhdGNoZXI9bnVsbH1pZihkZXBlbmRlbmNpZXNGdWxmaWxsZWQpe3ZhciBjYWxsYmFjaz1kZXBlbmRlbmNpZXNGdWxmaWxsZWQ7ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7Y2FsbGJhY2soKX19fWZ1bmN0aW9uIGFib3J0KHdoYXQpe2lmKE1vZHVsZVtcIm9uQWJvcnRcIl0pe01vZHVsZVtcIm9uQWJvcnRcIl0od2hhdCl9d2hhdD1cIkFib3J0ZWQoXCIrd2hhdCtcIilcIjtlcnIod2hhdCk7QUJPUlQ9dHJ1ZTtFWElUU1RBVFVTPTE7d2hhdCs9XCIuIEJ1aWxkIHdpdGggLXNBU1NFUlRJT05TIGZvciBtb3JlIGluZm8uXCI7dmFyIGU9bmV3IFdlYkFzc2VtYmx5LlJ1bnRpbWVFcnJvcih3aGF0KTtyZWFkeVByb21pc2VSZWplY3QoZSk7dGhyb3cgZX12YXIgZGF0YVVSSVByZWZpeD1cImRhdGE6YXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtO2Jhc2U2NCxcIjtmdW5jdGlvbiBpc0RhdGFVUkkoZmlsZW5hbWUpe3JldHVybiBmaWxlbmFtZS5zdGFydHNXaXRoKGRhdGFVUklQcmVmaXgpfXZhciB3YXNtQmluYXJ5RmlsZTt3YXNtQmluYXJ5RmlsZT1cInByb2Nlc3Mud2FzbVwiO2lmKCFpc0RhdGFVUkkod2FzbUJpbmFyeUZpbGUpKXt3YXNtQmluYXJ5RmlsZT1sb2NhdGVGaWxlKHdhc21CaW5hcnlGaWxlKX1mdW5jdGlvbiBnZXRCaW5hcnlTeW5jKGZpbGUpe2lmKGZpbGU9PXdhc21CaW5hcnlGaWxlJiZ3YXNtQmluYXJ5KXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2FzbUJpbmFyeSl9aWYocmVhZEJpbmFyeSl7cmV0dXJuIHJlYWRCaW5hcnkoZmlsZSl9dGhyb3dcImJvdGggYXN5bmMgYW5kIHN5bmMgZmV0Y2hpbmcgb2YgdGhlIHdhc20gZmFpbGVkXCJ9ZnVuY3Rpb24gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKXtpZighd2FzbUJpbmFyeSYmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKSl7aWYodHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmZXRjaChiaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHJlc3BvbnNlPT57aWYoIXJlc3BvbnNlW1wib2tcIl0pe3Rocm93XCJmYWlsZWQgdG8gbG9hZCB3YXNtIGJpbmFyeSBmaWxlIGF0ICdcIitiaW5hcnlGaWxlK1wiJ1wifXJldHVybiByZXNwb25zZVtcImFycmF5QnVmZmVyXCJdKCl9KS5jYXRjaCgoKT0+Z2V0QmluYXJ5U3luYyhiaW5hcnlGaWxlKSl9fXJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpPT5nZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxyZWNlaXZlcil7cmV0dXJuIGdldEJpbmFyeVByb21pc2UoYmluYXJ5RmlsZSkudGhlbihiaW5hcnk9PldlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGJpbmFyeSxpbXBvcnRzKSkudGhlbihpbnN0YW5jZT0+aW5zdGFuY2UpLnRoZW4ocmVjZWl2ZXIscmVhc29uPT57ZXJyKGBmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAke3JlYXNvbn1gKTthYm9ydChyZWFzb24pfSl9ZnVuY3Rpb24gaW5zdGFudGlhdGVBc3luYyhiaW5hcnksYmluYXJ5RmlsZSxpbXBvcnRzLGNhbGxiYWNrKXtpZighYmluYXJ5JiZ0eXBlb2YgV2ViQXNzZW1ibHkuaW5zdGFudGlhdGVTdHJlYW1pbmc9PVwiZnVuY3Rpb25cIiYmIWlzRGF0YVVSSShiaW5hcnlGaWxlKSYmdHlwZW9mIGZldGNoPT1cImZ1bmN0aW9uXCIpe3JldHVybiBmZXRjaChiaW5hcnlGaWxlLHtjcmVkZW50aWFsczpcInNhbWUtb3JpZ2luXCJ9KS50aGVuKHJlc3BvbnNlPT57dmFyIHJlc3VsdD1XZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhyZXNwb25zZSxpbXBvcnRzKTtyZXR1cm4gcmVzdWx0LnRoZW4oY2FsbGJhY2ssZnVuY3Rpb24ocmVhc29uKXtlcnIoYHdhc20gc3RyZWFtaW5nIGNvbXBpbGUgZmFpbGVkOiAke3JlYXNvbn1gKTtlcnIoXCJmYWxsaW5nIGJhY2sgdG8gQXJyYXlCdWZmZXIgaW5zdGFudGlhdGlvblwiKTtyZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spfSl9KX1yZXR1cm4gaW5zdGFudGlhdGVBcnJheUJ1ZmZlcihiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spfWZ1bmN0aW9uIGNyZWF0ZVdhc20oKXt2YXIgaW5mbz17XCJhXCI6d2FzbUltcG9ydHN9O2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW5jZShpbnN0YW5jZSxtb2R1bGUpe3dhc21FeHBvcnRzPWluc3RhbmNlLmV4cG9ydHM7d2FzbU1lbW9yeT13YXNtRXhwb3J0c1tcIktcIl07dXBkYXRlTWVtb3J5Vmlld3MoKTt3YXNtVGFibGU9d2FzbUV4cG9ydHNbXCJPXCJdO2FkZE9uSW5pdCh3YXNtRXhwb3J0c1tcIkxcIl0pO3JlbW92ZVJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO3JldHVybiB3YXNtRXhwb3J0c31hZGRSdW5EZXBlbmRlbmN5KFwid2FzbS1pbnN0YW50aWF0ZVwiKTtmdW5jdGlvbiByZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdChyZXN1bHQpe3JlY2VpdmVJbnN0YW5jZShyZXN1bHRbXCJpbnN0YW5jZVwiXSl9aWYoTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKXt0cnl7cmV0dXJuIE1vZHVsZVtcImluc3RhbnRpYXRlV2FzbVwiXShpbmZvLHJlY2VpdmVJbnN0YW5jZSl9Y2F0Y2goZSl7ZXJyKGBNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAke2V9YCk7cmVhZHlQcm9taXNlUmVqZWN0KGUpfX1pbnN0YW50aWF0ZUFzeW5jKHdhc21CaW5hcnksd2FzbUJpbmFyeUZpbGUsaW5mbyxyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCkuY2F0Y2gocmVhZHlQcm9taXNlUmVqZWN0KTtyZXR1cm57fX12YXIgdGVtcERvdWJsZTt2YXIgdGVtcEk2NDt2YXIgY2FsbFJ1bnRpbWVDYWxsYmFja3M9Y2FsbGJhY2tzPT57d2hpbGUoY2FsbGJhY2tzLmxlbmd0aD4wKXtjYWxsYmFja3Muc2hpZnQoKShNb2R1bGUpfX07ZnVuY3Rpb24gRXhjZXB0aW9uSW5mbyhleGNQdHIpe3RoaXMuZXhjUHRyPWV4Y1B0cjt0aGlzLnB0cj1leGNQdHItMjQ7dGhpcy5zZXRfdHlwZT1mdW5jdGlvbih0eXBlKXtIRUFQVTMyW3RoaXMucHRyKzQ+PjJdPXR5cGV9O3RoaXMuZ2V0X3R5cGU9ZnVuY3Rpb24oKXtyZXR1cm4gSEVBUFUzMlt0aGlzLnB0cis0Pj4yXX07dGhpcy5zZXRfZGVzdHJ1Y3Rvcj1mdW5jdGlvbihkZXN0cnVjdG9yKXtIRUFQVTMyW3RoaXMucHRyKzg+PjJdPWRlc3RydWN0b3J9O3RoaXMuZ2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gSEVBUFUzMlt0aGlzLnB0cis4Pj4yXX07dGhpcy5zZXRfY2F1Z2h0PWZ1bmN0aW9uKGNhdWdodCl7Y2F1Z2h0PWNhdWdodD8xOjA7SEVBUDhbdGhpcy5wdHIrMTI+PjBdPWNhdWdodH07dGhpcy5nZXRfY2F1Z2h0PWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVA4W3RoaXMucHRyKzEyPj4wXSE9MH07dGhpcy5zZXRfcmV0aHJvd249ZnVuY3Rpb24ocmV0aHJvd24pe3JldGhyb3duPXJldGhyb3duPzE6MDtIRUFQOFt0aGlzLnB0cisxMz4+MF09cmV0aHJvd259O3RoaXMuZ2V0X3JldGhyb3duPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVA4W3RoaXMucHRyKzEzPj4wXSE9MH07dGhpcy5pbml0PWZ1bmN0aW9uKHR5cGUsZGVzdHJ1Y3Rvcil7dGhpcy5zZXRfYWRqdXN0ZWRfcHRyKDApO3RoaXMuc2V0X3R5cGUodHlwZSk7dGhpcy5zZXRfZGVzdHJ1Y3RvcihkZXN0cnVjdG9yKX07dGhpcy5zZXRfYWRqdXN0ZWRfcHRyPWZ1bmN0aW9uKGFkanVzdGVkUHRyKXtIRUFQVTMyW3RoaXMucHRyKzE2Pj4yXT1hZGp1c3RlZFB0cn07dGhpcy5nZXRfYWRqdXN0ZWRfcHRyPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIrMTY+PjJdfTt0aGlzLmdldF9leGNlcHRpb25fcHRyPWZ1bmN0aW9uKCl7dmFyIGlzUG9pbnRlcj1fX19jeGFfaXNfcG9pbnRlcl90eXBlKHRoaXMuZ2V0X3R5cGUoKSk7aWYoaXNQb2ludGVyKXtyZXR1cm4gSEVBUFUzMlt0aGlzLmV4Y1B0cj4+Ml19dmFyIGFkanVzdGVkPXRoaXMuZ2V0X2FkanVzdGVkX3B0cigpO2lmKGFkanVzdGVkIT09MClyZXR1cm4gYWRqdXN0ZWQ7cmV0dXJuIHRoaXMuZXhjUHRyfX12YXIgZXhjZXB0aW9uTGFzdD0wO3ZhciB1bmNhdWdodEV4Y2VwdGlvbkNvdW50PTA7dmFyIF9fX2N4YV90aHJvdz0ocHRyLHR5cGUsZGVzdHJ1Y3Rvcik9Pnt2YXIgaW5mbz1uZXcgRXhjZXB0aW9uSW5mbyhwdHIpO2luZm8uaW5pdCh0eXBlLGRlc3RydWN0b3IpO2V4Y2VwdGlvbkxhc3Q9cHRyO3VuY2F1Z2h0RXhjZXB0aW9uQ291bnQrKzt0aHJvdyBleGNlcHRpb25MYXN0fTt2YXIgdHVwbGVSZWdpc3RyYXRpb25zPXt9O3ZhciBydW5EZXN0cnVjdG9ycz1kZXN0cnVjdG9ycz0+e3doaWxlKGRlc3RydWN0b3JzLmxlbmd0aCl7dmFyIHB0cj1kZXN0cnVjdG9ycy5wb3AoKTt2YXIgZGVsPWRlc3RydWN0b3JzLnBvcCgpO2RlbChwdHIpfX07ZnVuY3Rpb24gc2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUDMyW3BvaW50ZXI+PjJdKX12YXIgYXdhaXRpbmdEZXBlbmRlbmNpZXM9e307dmFyIHJlZ2lzdGVyZWRUeXBlcz17fTt2YXIgdHlwZURlcGVuZGVuY2llcz17fTt2YXIgSW50ZXJuYWxFcnJvcjt2YXIgdGhyb3dJbnRlcm5hbEVycm9yPW1lc3NhZ2U9Pnt0aHJvdyBuZXcgSW50ZXJuYWxFcnJvcihtZXNzYWdlKX07dmFyIHdoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkPShteVR5cGVzLGRlcGVuZGVudFR5cGVzLGdldFR5cGVDb252ZXJ0ZXJzKT0+e215VHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKXt0eXBlRGVwZW5kZW5jaWVzW3R5cGVdPWRlcGVuZGVudFR5cGVzfSk7ZnVuY3Rpb24gb25Db21wbGV0ZSh0eXBlQ29udmVydGVycyl7dmFyIG15VHlwZUNvbnZlcnRlcnM9Z2V0VHlwZUNvbnZlcnRlcnModHlwZUNvbnZlcnRlcnMpO2lmKG15VHlwZUNvbnZlcnRlcnMubGVuZ3RoIT09bXlUeXBlcy5sZW5ndGgpe3Rocm93SW50ZXJuYWxFcnJvcihcIk1pc21hdGNoZWQgdHlwZSBjb252ZXJ0ZXIgY291bnRcIil9Zm9yKHZhciBpPTA7aTxteVR5cGVzLmxlbmd0aDsrK2kpe3JlZ2lzdGVyVHlwZShteVR5cGVzW2ldLG15VHlwZUNvbnZlcnRlcnNbaV0pfX12YXIgdHlwZUNvbnZlcnRlcnM9bmV3IEFycmF5KGRlcGVuZGVudFR5cGVzLmxlbmd0aCk7dmFyIHVucmVnaXN0ZXJlZFR5cGVzPVtdO3ZhciByZWdpc3RlcmVkPTA7ZGVwZW5kZW50VHlwZXMuZm9yRWFjaCgoZHQsaSk9PntpZihyZWdpc3RlcmVkVHlwZXMuaGFzT3duUHJvcGVydHkoZHQpKXt0eXBlQ29udmVydGVyc1tpXT1yZWdpc3RlcmVkVHlwZXNbZHRdfWVsc2V7dW5yZWdpc3RlcmVkVHlwZXMucHVzaChkdCk7aWYoIWF3YWl0aW5nRGVwZW5kZW5jaWVzLmhhc093blByb3BlcnR5KGR0KSl7YXdhaXRpbmdEZXBlbmRlbmNpZXNbZHRdPVtdfWF3YWl0aW5nRGVwZW5kZW5jaWVzW2R0XS5wdXNoKCgpPT57dHlwZUNvbnZlcnRlcnNbaV09cmVnaXN0ZXJlZFR5cGVzW2R0XTsrK3JlZ2lzdGVyZWQ7aWYocmVnaXN0ZXJlZD09PXVucmVnaXN0ZXJlZFR5cGVzLmxlbmd0aCl7b25Db21wbGV0ZSh0eXBlQ29udmVydGVycyl9fSl9fSk7aWYoMD09PXVucmVnaXN0ZXJlZFR5cGVzLmxlbmd0aCl7b25Db21wbGV0ZSh0eXBlQ29udmVydGVycyl9fTt2YXIgX19lbWJpbmRfZmluYWxpemVfdmFsdWVfYXJyYXk9cmF3VHVwbGVUeXBlPT57dmFyIHJlZz10dXBsZVJlZ2lzdHJhdGlvbnNbcmF3VHVwbGVUeXBlXTtkZWxldGUgdHVwbGVSZWdpc3RyYXRpb25zW3Jhd1R1cGxlVHlwZV07dmFyIGVsZW1lbnRzPXJlZy5lbGVtZW50czt2YXIgZWxlbWVudHNMZW5ndGg9ZWxlbWVudHMubGVuZ3RoO3ZhciBlbGVtZW50VHlwZXM9ZWxlbWVudHMubWFwKGVsdD0+ZWx0LmdldHRlclJldHVyblR5cGUpLmNvbmNhdChlbGVtZW50cy5tYXAoZWx0PT5lbHQuc2V0dGVyQXJndW1lbnRUeXBlKSk7dmFyIHJhd0NvbnN0cnVjdG9yPXJlZy5yYXdDb25zdHJ1Y3Rvcjt2YXIgcmF3RGVzdHJ1Y3Rvcj1yZWcucmF3RGVzdHJ1Y3Rvcjt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbcmF3VHVwbGVUeXBlXSxlbGVtZW50VHlwZXMsZnVuY3Rpb24oZWxlbWVudFR5cGVzKXtlbGVtZW50cy5mb3JFYWNoKChlbHQsaSk9Pnt2YXIgZ2V0dGVyUmV0dXJuVHlwZT1lbGVtZW50VHlwZXNbaV07dmFyIGdldHRlcj1lbHQuZ2V0dGVyO3ZhciBnZXR0ZXJDb250ZXh0PWVsdC5nZXR0ZXJDb250ZXh0O3ZhciBzZXR0ZXJBcmd1bWVudFR5cGU9ZWxlbWVudFR5cGVzW2krZWxlbWVudHNMZW5ndGhdO3ZhciBzZXR0ZXI9ZWx0LnNldHRlcjt2YXIgc2V0dGVyQ29udGV4dD1lbHQuc2V0dGVyQ29udGV4dDtlbHQucmVhZD1wdHI9PmdldHRlclJldHVyblR5cGVbXCJmcm9tV2lyZVR5cGVcIl0oZ2V0dGVyKGdldHRlckNvbnRleHQscHRyKSk7ZWx0LndyaXRlPShwdHIsbyk9Pnt2YXIgZGVzdHJ1Y3RvcnM9W107c2V0dGVyKHNldHRlckNvbnRleHQscHRyLHNldHRlckFyZ3VtZW50VHlwZVtcInRvV2lyZVR5cGVcIl0oZGVzdHJ1Y3RvcnMsbykpO3J1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKX19KTtyZXR1cm5be25hbWU6cmVnLm5hbWUsXCJmcm9tV2lyZVR5cGVcIjpwdHI9Pnt2YXIgcnY9bmV3IEFycmF5KGVsZW1lbnRzTGVuZ3RoKTtmb3IodmFyIGk9MDtpPGVsZW1lbnRzTGVuZ3RoOysraSl7cnZbaV09ZWxlbWVudHNbaV0ucmVhZChwdHIpfXJhd0Rlc3RydWN0b3IocHRyKTtyZXR1cm4gcnZ9LFwidG9XaXJlVHlwZVwiOihkZXN0cnVjdG9ycyxvKT0+e2lmKGVsZW1lbnRzTGVuZ3RoIT09by5sZW5ndGgpe3Rocm93IG5ldyBUeXBlRXJyb3IoYEluY29ycmVjdCBudW1iZXIgb2YgdHVwbGUgZWxlbWVudHMgZm9yICR7cmVnLm5hbWV9OiBleHBlY3RlZD0ke2VsZW1lbnRzTGVuZ3RofSwgYWN0dWFsPSR7by5sZW5ndGh9YCl9dmFyIHB0cj1yYXdDb25zdHJ1Y3RvcigpO2Zvcih2YXIgaT0wO2k8ZWxlbWVudHNMZW5ndGg7KytpKXtlbGVtZW50c1tpXS53cml0ZShwdHIsb1tpXSl9aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKHJhd0Rlc3RydWN0b3IscHRyKX1yZXR1cm4gcHRyfSxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6c2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uOnJhd0Rlc3RydWN0b3J9XX0pfTt2YXIgc3RydWN0UmVnaXN0cmF0aW9ucz17fTt2YXIgX19lbWJpbmRfZmluYWxpemVfdmFsdWVfb2JqZWN0PXN0cnVjdFR5cGU9Pnt2YXIgcmVnPXN0cnVjdFJlZ2lzdHJhdGlvbnNbc3RydWN0VHlwZV07ZGVsZXRlIHN0cnVjdFJlZ2lzdHJhdGlvbnNbc3RydWN0VHlwZV07dmFyIHJhd0NvbnN0cnVjdG9yPXJlZy5yYXdDb25zdHJ1Y3Rvcjt2YXIgcmF3RGVzdHJ1Y3Rvcj1yZWcucmF3RGVzdHJ1Y3Rvcjt2YXIgZmllbGRSZWNvcmRzPXJlZy5maWVsZHM7dmFyIGZpZWxkVHlwZXM9ZmllbGRSZWNvcmRzLm1hcChmaWVsZD0+ZmllbGQuZ2V0dGVyUmV0dXJuVHlwZSkuY29uY2F0KGZpZWxkUmVjb3Jkcy5tYXAoZmllbGQ9PmZpZWxkLnNldHRlckFyZ3VtZW50VHlwZSkpO3doZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkKFtzdHJ1Y3RUeXBlXSxmaWVsZFR5cGVzLGZpZWxkVHlwZXM9Pnt2YXIgZmllbGRzPXt9O2ZpZWxkUmVjb3Jkcy5mb3JFYWNoKChmaWVsZCxpKT0+e3ZhciBmaWVsZE5hbWU9ZmllbGQuZmllbGROYW1lO3ZhciBnZXR0ZXJSZXR1cm5UeXBlPWZpZWxkVHlwZXNbaV07dmFyIGdldHRlcj1maWVsZC5nZXR0ZXI7dmFyIGdldHRlckNvbnRleHQ9ZmllbGQuZ2V0dGVyQ29udGV4dDt2YXIgc2V0dGVyQXJndW1lbnRUeXBlPWZpZWxkVHlwZXNbaStmaWVsZFJlY29yZHMubGVuZ3RoXTt2YXIgc2V0dGVyPWZpZWxkLnNldHRlcjt2YXIgc2V0dGVyQ29udGV4dD1maWVsZC5zZXR0ZXJDb250ZXh0O2ZpZWxkc1tmaWVsZE5hbWVdPXtyZWFkOnB0cj0+Z2V0dGVyUmV0dXJuVHlwZVtcImZyb21XaXJlVHlwZVwiXShnZXR0ZXIoZ2V0dGVyQ29udGV4dCxwdHIpKSx3cml0ZToocHRyLG8pPT57dmFyIGRlc3RydWN0b3JzPVtdO3NldHRlcihzZXR0ZXJDb250ZXh0LHB0cixzZXR0ZXJBcmd1bWVudFR5cGVbXCJ0b1dpcmVUeXBlXCJdKGRlc3RydWN0b3JzLG8pKTtydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyl9fX0pO3JldHVyblt7bmFtZTpyZWcubmFtZSxcImZyb21XaXJlVHlwZVwiOnB0cj0+e3ZhciBydj17fTtmb3IodmFyIGkgaW4gZmllbGRzKXtydltpXT1maWVsZHNbaV0ucmVhZChwdHIpfXJhd0Rlc3RydWN0b3IocHRyKTtyZXR1cm4gcnZ9LFwidG9XaXJlVHlwZVwiOihkZXN0cnVjdG9ycyxvKT0+e2Zvcih2YXIgZmllbGROYW1lIGluIGZpZWxkcyl7aWYoIShmaWVsZE5hbWUgaW4gbykpe3Rocm93IG5ldyBUeXBlRXJyb3IoYE1pc3NpbmcgZmllbGQ6IFwiJHtmaWVsZE5hbWV9XCJgKX19dmFyIHB0cj1yYXdDb25zdHJ1Y3RvcigpO2ZvcihmaWVsZE5hbWUgaW4gZmllbGRzKXtmaWVsZHNbZmllbGROYW1lXS53cml0ZShwdHIsb1tmaWVsZE5hbWVdKX1pZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2gocmF3RGVzdHJ1Y3RvcixwdHIpfXJldHVybiBwdHJ9LFwiYXJnUGFja0FkdmFuY2VcIjpHZW5lcmljV2lyZVR5cGVTaXplLFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjpzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb246cmF3RGVzdHJ1Y3Rvcn1dfSl9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQ9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e307dmFyIGVtYmluZF9pbml0X2NoYXJDb2Rlcz0oKT0+e3ZhciBjb2Rlcz1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIGk9MDtpPDI1NjsrK2kpe2NvZGVzW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoaSl9ZW1iaW5kX2NoYXJDb2Rlcz1jb2Rlc307dmFyIGVtYmluZF9jaGFyQ29kZXM7dmFyIHJlYWRMYXRpbjFTdHJpbmc9cHRyPT57dmFyIHJldD1cIlwiO3ZhciBjPXB0cjt3aGlsZShIRUFQVThbY10pe3JldCs9ZW1iaW5kX2NoYXJDb2Rlc1tIRUFQVThbYysrXV19cmV0dXJuIHJldH07dmFyIEJpbmRpbmdFcnJvcjt2YXIgdGhyb3dCaW5kaW5nRXJyb3I9bWVzc2FnZT0+e3Rocm93IG5ldyBCaW5kaW5nRXJyb3IobWVzc2FnZSl9O2Z1bmN0aW9uIHNoYXJlZFJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zPXt9KXt2YXIgbmFtZT1yZWdpc3RlcmVkSW5zdGFuY2UubmFtZTtpZighcmF3VHlwZSl7dGhyb3dCaW5kaW5nRXJyb3IoYHR5cGUgXCIke25hbWV9XCIgbXVzdCBoYXZlIGEgcG9zaXRpdmUgaW50ZWdlciB0eXBlaWQgcG9pbnRlcmApfWlmKHJlZ2lzdGVyZWRUeXBlcy5oYXNPd25Qcm9wZXJ0eShyYXdUeXBlKSl7aWYob3B0aW9ucy5pZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zKXtyZXR1cm59ZWxzZXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIHR5cGUgJyR7bmFtZX0nIHR3aWNlYCl9fXJlZ2lzdGVyZWRUeXBlc1tyYXdUeXBlXT1yZWdpc3RlcmVkSW5zdGFuY2U7ZGVsZXRlIHR5cGVEZXBlbmRlbmNpZXNbcmF3VHlwZV07aWYoYXdhaXRpbmdEZXBlbmRlbmNpZXMuaGFzT3duUHJvcGVydHkocmF3VHlwZSkpe3ZhciBjYWxsYmFja3M9YXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07ZGVsZXRlIGF3YWl0aW5nRGVwZW5kZW5jaWVzW3Jhd1R5cGVdO2NhbGxiYWNrcy5mb3JFYWNoKGNiPT5jYigpKX19ZnVuY3Rpb24gcmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnM9e30pe2lmKCEoXCJhcmdQYWNrQWR2YW5jZVwiaW4gcmVnaXN0ZXJlZEluc3RhbmNlKSl7dGhyb3cgbmV3IFR5cGVFcnJvcihcInJlZ2lzdGVyVHlwZSByZWdpc3RlcmVkSW5zdGFuY2UgcmVxdWlyZXMgYXJnUGFja0FkdmFuY2VcIil9cmV0dXJuIHNoYXJlZFJlZ2lzdGVyVHlwZShyYXdUeXBlLHJlZ2lzdGVyZWRJbnN0YW5jZSxvcHRpb25zKX12YXIgR2VuZXJpY1dpcmVUeXBlU2l6ZT04O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9ib29sPShyYXdUeXBlLG5hbWUsdHJ1ZVZhbHVlLGZhbHNlVmFsdWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsXCJmcm9tV2lyZVR5cGVcIjpmdW5jdGlvbih3dCl7cmV0dXJuISF3dH0sXCJ0b1dpcmVUeXBlXCI6ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsbyl7cmV0dXJuIG8/dHJ1ZVZhbHVlOmZhbHNlVmFsdWV9LFwiYXJnUGFja0FkdmFuY2VcIjpHZW5lcmljV2lyZVR5cGVTaXplLFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjpmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQVThbcG9pbnRlcl0pfSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfTt2YXIgc2hhbGxvd0NvcHlJbnRlcm5hbFBvaW50ZXI9bz0+KHtjb3VudDpvLmNvdW50LGRlbGV0ZVNjaGVkdWxlZDpvLmRlbGV0ZVNjaGVkdWxlZCxwcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZTpvLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlLHB0cjpvLnB0cixwdHJUeXBlOm8ucHRyVHlwZSxzbWFydFB0cjpvLnNtYXJ0UHRyLHNtYXJ0UHRyVHlwZTpvLnNtYXJ0UHRyVHlwZX0pO3ZhciB0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQ9b2JqPT57ZnVuY3Rpb24gZ2V0SW5zdGFuY2VUeXBlTmFtZShoYW5kbGUpe3JldHVybiBoYW5kbGUuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3MubmFtZX10aHJvd0JpbmRpbmdFcnJvcihnZXRJbnN0YW5jZVR5cGVOYW1lKG9iaikrXCIgaW5zdGFuY2UgYWxyZWFkeSBkZWxldGVkXCIpfTt2YXIgZmluYWxpemF0aW9uUmVnaXN0cnk9ZmFsc2U7dmFyIGRldGFjaEZpbmFsaXplcj1oYW5kbGU9Pnt9O3ZhciBydW5EZXN0cnVjdG9yPSQkPT57aWYoJCQuc21hcnRQdHIpeyQkLnNtYXJ0UHRyVHlwZS5yYXdEZXN0cnVjdG9yKCQkLnNtYXJ0UHRyKX1lbHNleyQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzLnJhd0Rlc3RydWN0b3IoJCQucHRyKX19O3ZhciByZWxlYXNlQ2xhc3NIYW5kbGU9JCQ9PnskJC5jb3VudC52YWx1ZS09MTt2YXIgdG9EZWxldGU9MD09PSQkLmNvdW50LnZhbHVlO2lmKHRvRGVsZXRlKXtydW5EZXN0cnVjdG9yKCQkKX19O3ZhciBkb3duY2FzdFBvaW50ZXI9KHB0cixwdHJDbGFzcyxkZXNpcmVkQ2xhc3MpPT57aWYocHRyQ2xhc3M9PT1kZXNpcmVkQ2xhc3Mpe3JldHVybiBwdHJ9aWYodW5kZWZpbmVkPT09ZGVzaXJlZENsYXNzLmJhc2VDbGFzcyl7cmV0dXJuIG51bGx9dmFyIHJ2PWRvd25jYXN0UG9pbnRlcihwdHIscHRyQ2xhc3MsZGVzaXJlZENsYXNzLmJhc2VDbGFzcyk7aWYocnY9PT1udWxsKXtyZXR1cm4gbnVsbH1yZXR1cm4gZGVzaXJlZENsYXNzLmRvd25jYXN0KHJ2KX07dmFyIHJlZ2lzdGVyZWRQb2ludGVycz17fTt2YXIgZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudD0oKT0+T2JqZWN0LmtleXMocmVnaXN0ZXJlZEluc3RhbmNlcykubGVuZ3RoO3ZhciBnZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzPSgpPT57dmFyIHJ2PVtdO2Zvcih2YXIgayBpbiByZWdpc3RlcmVkSW5zdGFuY2VzKXtpZihyZWdpc3RlcmVkSW5zdGFuY2VzLmhhc093blByb3BlcnR5KGspKXtydi5wdXNoKHJlZ2lzdGVyZWRJbnN0YW5jZXNba10pfX1yZXR1cm4gcnZ9O3ZhciBkZWxldGlvblF1ZXVlPVtdO3ZhciBmbHVzaFBlbmRpbmdEZWxldGVzPSgpPT57d2hpbGUoZGVsZXRpb25RdWV1ZS5sZW5ndGgpe3ZhciBvYmo9ZGVsZXRpb25RdWV1ZS5wb3AoKTtvYmouJCQuZGVsZXRlU2NoZWR1bGVkPWZhbHNlO29ialtcImRlbGV0ZVwiXSgpfX07dmFyIGRlbGF5RnVuY3Rpb247dmFyIHNldERlbGF5RnVuY3Rpb249Zm49PntkZWxheUZ1bmN0aW9uPWZuO2lmKGRlbGV0aW9uUXVldWUubGVuZ3RoJiZkZWxheUZ1bmN0aW9uKXtkZWxheUZ1bmN0aW9uKGZsdXNoUGVuZGluZ0RlbGV0ZXMpfX07dmFyIGluaXRfZW1iaW5kPSgpPT57TW9kdWxlW1wiZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudFwiXT1nZXRJbmhlcml0ZWRJbnN0YW5jZUNvdW50O01vZHVsZVtcImdldExpdmVJbmhlcml0ZWRJbnN0YW5jZXNcIl09Z2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcztNb2R1bGVbXCJmbHVzaFBlbmRpbmdEZWxldGVzXCJdPWZsdXNoUGVuZGluZ0RlbGV0ZXM7TW9kdWxlW1wic2V0RGVsYXlGdW5jdGlvblwiXT1zZXREZWxheUZ1bmN0aW9ufTt2YXIgcmVnaXN0ZXJlZEluc3RhbmNlcz17fTt2YXIgZ2V0QmFzZXN0UG9pbnRlcj0oY2xhc3NfLHB0cik9PntpZihwdHI9PT11bmRlZmluZWQpe3Rocm93QmluZGluZ0Vycm9yKFwicHRyIHNob3VsZCBub3QgYmUgdW5kZWZpbmVkXCIpfXdoaWxlKGNsYXNzXy5iYXNlQ2xhc3Mpe3B0cj1jbGFzc18udXBjYXN0KHB0cik7Y2xhc3NfPWNsYXNzXy5iYXNlQ2xhc3N9cmV0dXJuIHB0cn07dmFyIGdldEluaGVyaXRlZEluc3RhbmNlPShjbGFzc18scHRyKT0+e3B0cj1nZXRCYXNlc3RQb2ludGVyKGNsYXNzXyxwdHIpO3JldHVybiByZWdpc3RlcmVkSW5zdGFuY2VzW3B0cl19O3ZhciBtYWtlQ2xhc3NIYW5kbGU9KHByb3RvdHlwZSxyZWNvcmQpPT57aWYoIXJlY29yZC5wdHJUeXBlfHwhcmVjb3JkLnB0cil7dGhyb3dJbnRlcm5hbEVycm9yKFwibWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZVwiKX12YXIgaGFzU21hcnRQdHJUeXBlPSEhcmVjb3JkLnNtYXJ0UHRyVHlwZTt2YXIgaGFzU21hcnRQdHI9ISFyZWNvcmQuc21hcnRQdHI7aWYoaGFzU21hcnRQdHJUeXBlIT09aGFzU21hcnRQdHIpe3Rocm93SW50ZXJuYWxFcnJvcihcIkJvdGggc21hcnRQdHJUeXBlIGFuZCBzbWFydFB0ciBtdXN0IGJlIHNwZWNpZmllZFwiKX1yZWNvcmQuY291bnQ9e3ZhbHVlOjF9O3JldHVybiBhdHRhY2hGaW5hbGl6ZXIoT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUseyQkOnt2YWx1ZTpyZWNvcmR9fSkpfTtmdW5jdGlvbiBSZWdpc3RlcmVkUG9pbnRlcl9mcm9tV2lyZVR5cGUocHRyKXt2YXIgcmF3UG9pbnRlcj10aGlzLmdldFBvaW50ZWUocHRyKTtpZighcmF3UG9pbnRlcil7dGhpcy5kZXN0cnVjdG9yKHB0cik7cmV0dXJuIG51bGx9dmFyIHJlZ2lzdGVyZWRJbnN0YW5jZT1nZXRJbmhlcml0ZWRJbnN0YW5jZSh0aGlzLnJlZ2lzdGVyZWRDbGFzcyxyYXdQb2ludGVyKTtpZih1bmRlZmluZWQhPT1yZWdpc3RlcmVkSW5zdGFuY2Upe2lmKDA9PT1yZWdpc3RlcmVkSW5zdGFuY2UuJCQuY291bnQudmFsdWUpe3JlZ2lzdGVyZWRJbnN0YW5jZS4kJC5wdHI9cmF3UG9pbnRlcjtyZWdpc3RlcmVkSW5zdGFuY2UuJCQuc21hcnRQdHI9cHRyO3JldHVybiByZWdpc3RlcmVkSW5zdGFuY2VbXCJjbG9uZVwiXSgpfWVsc2V7dmFyIHJ2PXJlZ2lzdGVyZWRJbnN0YW5jZVtcImNsb25lXCJdKCk7dGhpcy5kZXN0cnVjdG9yKHB0cik7cmV0dXJuIHJ2fX1mdW5jdGlvbiBtYWtlRGVmYXVsdEhhbmRsZSgpe2lmKHRoaXMuaXNTbWFydFBvaW50ZXIpe3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUse3B0clR5cGU6dGhpcy5wb2ludGVlVHlwZSxwdHI6cmF3UG9pbnRlcixzbWFydFB0clR5cGU6dGhpcyxzbWFydFB0cjpwdHJ9KX1lbHNle3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodGhpcy5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUse3B0clR5cGU6dGhpcyxwdHI6cHRyfSl9fXZhciBhY3R1YWxUeXBlPXRoaXMucmVnaXN0ZXJlZENsYXNzLmdldEFjdHVhbFR5cGUocmF3UG9pbnRlcik7dmFyIHJlZ2lzdGVyZWRQb2ludGVyUmVjb3JkPXJlZ2lzdGVyZWRQb2ludGVyc1thY3R1YWxUeXBlXTtpZighcmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQpe3JldHVybiBtYWtlRGVmYXVsdEhhbmRsZS5jYWxsKHRoaXMpfXZhciB0b1R5cGU7aWYodGhpcy5pc0NvbnN0KXt0b1R5cGU9cmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQuY29uc3RQb2ludGVyVHlwZX1lbHNle3RvVHlwZT1yZWdpc3RlcmVkUG9pbnRlclJlY29yZC5wb2ludGVyVHlwZX12YXIgZHA9ZG93bmNhc3RQb2ludGVyKHJhd1BvaW50ZXIsdGhpcy5yZWdpc3RlcmVkQ2xhc3MsdG9UeXBlLnJlZ2lzdGVyZWRDbGFzcyk7aWYoZHA9PT1udWxsKXtyZXR1cm4gbWFrZURlZmF1bHRIYW5kbGUuY2FsbCh0aGlzKX1pZih0aGlzLmlzU21hcnRQb2ludGVyKXtyZXR1cm4gbWFrZUNsYXNzSGFuZGxlKHRvVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUse3B0clR5cGU6dG9UeXBlLHB0cjpkcCxzbWFydFB0clR5cGU6dGhpcyxzbWFydFB0cjpwdHJ9KX1lbHNle3JldHVybiBtYWtlQ2xhc3NIYW5kbGUodG9UeXBlLnJlZ2lzdGVyZWRDbGFzcy5pbnN0YW5jZVByb3RvdHlwZSx7cHRyVHlwZTp0b1R5cGUscHRyOmRwfSl9fXZhciBhdHRhY2hGaW5hbGl6ZXI9aGFuZGxlPT57aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSl7YXR0YWNoRmluYWxpemVyPWhhbmRsZT0+aGFuZGxlO3JldHVybiBoYW5kbGV9ZmluYWxpemF0aW9uUmVnaXN0cnk9bmV3IEZpbmFsaXphdGlvblJlZ2lzdHJ5KGluZm89PntyZWxlYXNlQ2xhc3NIYW5kbGUoaW5mby4kJCl9KTthdHRhY2hGaW5hbGl6ZXI9aGFuZGxlPT57dmFyICQkPWhhbmRsZS4kJDt2YXIgaGFzU21hcnRQdHI9ISEkJC5zbWFydFB0cjtpZihoYXNTbWFydFB0cil7dmFyIGluZm89eyQkOiQkfTtmaW5hbGl6YXRpb25SZWdpc3RyeS5yZWdpc3RlcihoYW5kbGUsaW5mbyxoYW5kbGUpfXJldHVybiBoYW5kbGV9O2RldGFjaEZpbmFsaXplcj1oYW5kbGU9PmZpbmFsaXphdGlvblJlZ2lzdHJ5LnVucmVnaXN0ZXIoaGFuZGxlKTtyZXR1cm4gYXR0YWNoRmluYWxpemVyKGhhbmRsZSl9O3ZhciBpbml0X0NsYXNzSGFuZGxlPSgpPT57T2JqZWN0LmFzc2lnbihDbGFzc0hhbmRsZS5wcm90b3R5cGUse1wiaXNBbGlhc09mXCIob3RoZXIpe2lmKCEodGhpcyBpbnN0YW5jZW9mIENsYXNzSGFuZGxlKSl7cmV0dXJuIGZhbHNlfWlmKCEob3RoZXIgaW5zdGFuY2VvZiBDbGFzc0hhbmRsZSkpe3JldHVybiBmYWxzZX12YXIgbGVmdENsYXNzPXRoaXMuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7dmFyIGxlZnQ9dGhpcy4kJC5wdHI7b3RoZXIuJCQ9b3RoZXIuJCQ7dmFyIHJpZ2h0Q2xhc3M9b3RoZXIuJCQucHRyVHlwZS5yZWdpc3RlcmVkQ2xhc3M7dmFyIHJpZ2h0PW90aGVyLiQkLnB0cjt3aGlsZShsZWZ0Q2xhc3MuYmFzZUNsYXNzKXtsZWZ0PWxlZnRDbGFzcy51cGNhc3QobGVmdCk7bGVmdENsYXNzPWxlZnRDbGFzcy5iYXNlQ2xhc3N9d2hpbGUocmlnaHRDbGFzcy5iYXNlQ2xhc3Mpe3JpZ2h0PXJpZ2h0Q2xhc3MudXBjYXN0KHJpZ2h0KTtyaWdodENsYXNzPXJpZ2h0Q2xhc3MuYmFzZUNsYXNzfXJldHVybiBsZWZ0Q2xhc3M9PT1yaWdodENsYXNzJiZsZWZ0PT09cmlnaHR9LFwiY2xvbmVcIigpe2lmKCF0aGlzLiQkLnB0cil7dGhyb3dJbnN0YW5jZUFscmVhZHlEZWxldGVkKHRoaXMpfWlmKHRoaXMuJCQucHJlc2VydmVQb2ludGVyT25EZWxldGUpe3RoaXMuJCQuY291bnQudmFsdWUrPTE7cmV0dXJuIHRoaXN9ZWxzZXt2YXIgY2xvbmU9YXR0YWNoRmluYWxpemVyKE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLHskJDp7dmFsdWU6c2hhbGxvd0NvcHlJbnRlcm5hbFBvaW50ZXIodGhpcy4kJCl9fSkpO2Nsb25lLiQkLmNvdW50LnZhbHVlKz0xO2Nsb25lLiQkLmRlbGV0ZVNjaGVkdWxlZD1mYWxzZTtyZXR1cm4gY2xvbmV9fSxcImRlbGV0ZVwiKCl7aWYoIXRoaXMuJCQucHRyKXt0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQodGhpcyl9aWYodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQmJiF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKXt0aHJvd0JpbmRpbmdFcnJvcihcIk9iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb25cIil9ZGV0YWNoRmluYWxpemVyKHRoaXMpO3JlbGVhc2VDbGFzc0hhbmRsZSh0aGlzLiQkKTtpZighdGhpcy4kJC5wcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSl7dGhpcy4kJC5zbWFydFB0cj11bmRlZmluZWQ7dGhpcy4kJC5wdHI9dW5kZWZpbmVkfX0sXCJpc0RlbGV0ZWRcIigpe3JldHVybiF0aGlzLiQkLnB0cn0sXCJkZWxldGVMYXRlclwiKCl7aWYoIXRoaXMuJCQucHRyKXt0aHJvd0luc3RhbmNlQWxyZWFkeURlbGV0ZWQodGhpcyl9aWYodGhpcy4kJC5kZWxldGVTY2hlZHVsZWQmJiF0aGlzLiQkLnByZXNlcnZlUG9pbnRlck9uRGVsZXRlKXt0aHJvd0JpbmRpbmdFcnJvcihcIk9iamVjdCBhbHJlYWR5IHNjaGVkdWxlZCBmb3IgZGVsZXRpb25cIil9ZGVsZXRpb25RdWV1ZS5wdXNoKHRoaXMpO2lmKGRlbGV0aW9uUXVldWUubGVuZ3RoPT09MSYmZGVsYXlGdW5jdGlvbil7ZGVsYXlGdW5jdGlvbihmbHVzaFBlbmRpbmdEZWxldGVzKX10aGlzLiQkLmRlbGV0ZVNjaGVkdWxlZD10cnVlO3JldHVybiB0aGlzfX0pfTtmdW5jdGlvbiBDbGFzc0hhbmRsZSgpe312YXIgY2hhcl8wPTQ4O3ZhciBjaGFyXzk9NTc7dmFyIG1ha2VMZWdhbEZ1bmN0aW9uTmFtZT1uYW1lPT57aWYodW5kZWZpbmVkPT09bmFtZSl7cmV0dXJuXCJfdW5rbm93blwifW5hbWU9bmFtZS5yZXBsYWNlKC9bXmEtekEtWjAtOV9dL2csXCIkXCIpO3ZhciBmPW5hbWUuY2hhckNvZGVBdCgwKTtpZihmPj1jaGFyXzAmJmY8PWNoYXJfOSl7cmV0dXJuYF8ke25hbWV9YH1yZXR1cm4gbmFtZX07ZnVuY3Rpb24gY3JlYXRlTmFtZWRGdW5jdGlvbihuYW1lLGJvZHkpe25hbWU9bWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpO3JldHVybntbbmFtZV06ZnVuY3Rpb24oKXtyZXR1cm4gYm9keS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fVtuYW1lXX12YXIgZW5zdXJlT3ZlcmxvYWRUYWJsZT0ocHJvdG8sbWV0aG9kTmFtZSxodW1hbk5hbWUpPT57aWYodW5kZWZpbmVkPT09cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSl7dmFyIHByZXZGdW5jPXByb3RvW21ldGhvZE5hbWVdO3Byb3RvW21ldGhvZE5hbWVdPWZ1bmN0aW9uKCl7aWYoIXByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzLmxlbmd0aCkpe3Rocm93QmluZGluZ0Vycm9yKGBGdW5jdGlvbiAnJHtodW1hbk5hbWV9JyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCR7YXJndW1lbnRzLmxlbmd0aH0pIC0gZXhwZWN0cyBvbmUgb2YgKCR7cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZX0pIWApfXJldHVybiBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZT1bXTtwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW3ByZXZGdW5jLmFyZ0NvdW50XT1wcmV2RnVuY319O3ZhciBleHBvc2VQdWJsaWNTeW1ib2w9KG5hbWUsdmFsdWUsbnVtQXJndW1lbnRzKT0+e2lmKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSl7aWYodW5kZWZpbmVkPT09bnVtQXJndW1lbnRzfHx1bmRlZmluZWQhPT1Nb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZSYmdW5kZWZpbmVkIT09TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSl7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCByZWdpc3RlciBwdWJsaWMgbmFtZSAnJHtuYW1lfScgdHdpY2VgKX1lbnN1cmVPdmVybG9hZFRhYmxlKE1vZHVsZSxuYW1lLG5hbWUpO2lmKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShudW1Bcmd1bWVudHMpKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoJHtudW1Bcmd1bWVudHN9KSFgKX1Nb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZVtudW1Bcmd1bWVudHNdPXZhbHVlfWVsc2V7TW9kdWxlW25hbWVdPXZhbHVlO2lmKHVuZGVmaW5lZCE9PW51bUFyZ3VtZW50cyl7TW9kdWxlW25hbWVdLm51bUFyZ3VtZW50cz1udW1Bcmd1bWVudHN9fX07ZnVuY3Rpb24gUmVnaXN0ZXJlZENsYXNzKG5hbWUsY29uc3RydWN0b3IsaW5zdGFuY2VQcm90b3R5cGUscmF3RGVzdHJ1Y3RvcixiYXNlQ2xhc3MsZ2V0QWN0dWFsVHlwZSx1cGNhc3QsZG93bmNhc3Qpe3RoaXMubmFtZT1uYW1lO3RoaXMuY29uc3RydWN0b3I9Y29uc3RydWN0b3I7dGhpcy5pbnN0YW5jZVByb3RvdHlwZT1pbnN0YW5jZVByb3RvdHlwZTt0aGlzLnJhd0Rlc3RydWN0b3I9cmF3RGVzdHJ1Y3Rvcjt0aGlzLmJhc2VDbGFzcz1iYXNlQ2xhc3M7dGhpcy5nZXRBY3R1YWxUeXBlPWdldEFjdHVhbFR5cGU7dGhpcy51cGNhc3Q9dXBjYXN0O3RoaXMuZG93bmNhc3Q9ZG93bmNhc3Q7dGhpcy5wdXJlVmlydHVhbEZ1bmN0aW9ucz1bXX12YXIgdXBjYXN0UG9pbnRlcj0ocHRyLHB0ckNsYXNzLGRlc2lyZWRDbGFzcyk9Pnt3aGlsZShwdHJDbGFzcyE9PWRlc2lyZWRDbGFzcyl7aWYoIXB0ckNsYXNzLnVwY2FzdCl7dGhyb3dCaW5kaW5nRXJyb3IoYEV4cGVjdGVkIG51bGwgb3IgaW5zdGFuY2Ugb2YgJHtkZXNpcmVkQ2xhc3MubmFtZX0sIGdvdCBhbiBpbnN0YW5jZSBvZiAke3B0ckNsYXNzLm5hbWV9YCl9cHRyPXB0ckNsYXNzLnVwY2FzdChwdHIpO3B0ckNsYXNzPXB0ckNsYXNzLmJhc2VDbGFzc31yZXR1cm4gcHRyfTtmdW5jdGlvbiBjb25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycyxoYW5kbGUpe2lmKGhhbmRsZT09PW51bGwpe2lmKHRoaXMuaXNSZWZlcmVuY2Upe3Rocm93QmluZGluZ0Vycm9yKGBudWxsIGlzIG5vdCBhIHZhbGlkICR7dGhpcy5uYW1lfWApfXJldHVybiAwfWlmKCFoYW5kbGUuJCQpe3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcGFzcyBcIiR7ZW1iaW5kUmVwcihoYW5kbGUpfVwiIGFzIGEgJHt0aGlzLm5hbWV9YCl9aWYoIWhhbmRsZS4kJC5wdHIpe3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcGFzcyBkZWxldGVkIG9iamVjdCBhcyBhIHBvaW50ZXIgb2YgdHlwZSAke3RoaXMubmFtZX1gKX12YXIgaGFuZGxlQ2xhc3M9aGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3ZhciBwdHI9dXBjYXN0UG9pbnRlcihoYW5kbGUuJCQucHRyLGhhbmRsZUNsYXNzLHRoaXMucmVnaXN0ZXJlZENsYXNzKTtyZXR1cm4gcHRyfWZ1bmN0aW9uIGdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZShkZXN0cnVjdG9ycyxoYW5kbGUpe3ZhciBwdHI7aWYoaGFuZGxlPT09bnVsbCl7aWYodGhpcy5pc1JlZmVyZW5jZSl7dGhyb3dCaW5kaW5nRXJyb3IoYG51bGwgaXMgbm90IGEgdmFsaWQgJHt0aGlzLm5hbWV9YCl9aWYodGhpcy5pc1NtYXJ0UG9pbnRlcil7cHRyPXRoaXMucmF3Q29uc3RydWN0b3IoKTtpZihkZXN0cnVjdG9ycyE9PW51bGwpe2Rlc3RydWN0b3JzLnB1c2godGhpcy5yYXdEZXN0cnVjdG9yLHB0cil9cmV0dXJuIHB0cn1lbHNle3JldHVybiAwfX1pZighaGFuZGxlLiQkKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3MgXCIke2VtYmluZFJlcHIoaGFuZGxlKX1cIiBhcyBhICR7dGhpcy5uYW1lfWApfWlmKCFoYW5kbGUuJCQucHRyKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgJHt0aGlzLm5hbWV9YCl9aWYoIXRoaXMuaXNDb25zdCYmaGFuZGxlLiQkLnB0clR5cGUuaXNDb25zdCl7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCBjb252ZXJ0IGFyZ3VtZW50IG9mIHR5cGUgJHtoYW5kbGUuJCQuc21hcnRQdHJUeXBlP2hhbmRsZS4kJC5zbWFydFB0clR5cGUubmFtZTpoYW5kbGUuJCQucHRyVHlwZS5uYW1lfSB0byBwYXJhbWV0ZXIgdHlwZSAke3RoaXMubmFtZX1gKX12YXIgaGFuZGxlQ2xhc3M9aGFuZGxlLiQkLnB0clR5cGUucmVnaXN0ZXJlZENsYXNzO3B0cj11cGNhc3RQb2ludGVyKGhhbmRsZS4kJC5wdHIsaGFuZGxlQ2xhc3MsdGhpcy5yZWdpc3RlcmVkQ2xhc3MpO2lmKHRoaXMuaXNTbWFydFBvaW50ZXIpe2lmKHVuZGVmaW5lZD09PWhhbmRsZS4kJC5zbWFydFB0cil7dGhyb3dCaW5kaW5nRXJyb3IoXCJQYXNzaW5nIHJhdyBwb2ludGVyIHRvIHNtYXJ0IHBvaW50ZXIgaXMgaWxsZWdhbFwiKX1zd2l0Y2godGhpcy5zaGFyaW5nUG9saWN5KXtjYXNlIDA6aWYoaGFuZGxlLiQkLnNtYXJ0UHRyVHlwZT09PXRoaXMpe3B0cj1oYW5kbGUuJCQuc21hcnRQdHJ9ZWxzZXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAke2hhbmRsZS4kJC5zbWFydFB0clR5cGU/aGFuZGxlLiQkLnNtYXJ0UHRyVHlwZS5uYW1lOmhhbmRsZS4kJC5wdHJUeXBlLm5hbWV9IHRvIHBhcmFtZXRlciB0eXBlICR7dGhpcy5uYW1lfWApfWJyZWFrO2Nhc2UgMTpwdHI9aGFuZGxlLiQkLnNtYXJ0UHRyO2JyZWFrO2Nhc2UgMjppZihoYW5kbGUuJCQuc21hcnRQdHJUeXBlPT09dGhpcyl7cHRyPWhhbmRsZS4kJC5zbWFydFB0cn1lbHNle3ZhciBjbG9uZWRIYW5kbGU9aGFuZGxlW1wiY2xvbmVcIl0oKTtwdHI9dGhpcy5yYXdTaGFyZShwdHIsRW12YWwudG9IYW5kbGUoKCk9PmNsb25lZEhhbmRsZVtcImRlbGV0ZVwiXSgpKSk7aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKHRoaXMucmF3RGVzdHJ1Y3RvcixwdHIpfX1icmVhaztkZWZhdWx0OnRocm93QmluZGluZ0Vycm9yKFwiVW5zdXBwb3J0aW5nIHNoYXJpbmcgcG9saWN5XCIpfX1yZXR1cm4gcHRyfWZ1bmN0aW9uIG5vbkNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlKGRlc3RydWN0b3JzLGhhbmRsZSl7aWYoaGFuZGxlPT09bnVsbCl7aWYodGhpcy5pc1JlZmVyZW5jZSl7dGhyb3dCaW5kaW5nRXJyb3IoYG51bGwgaXMgbm90IGEgdmFsaWQgJHt0aGlzLm5hbWV9YCl9cmV0dXJuIDB9aWYoIWhhbmRsZS4kJCl7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCBwYXNzIFwiJHtlbWJpbmRSZXByKGhhbmRsZSl9XCIgYXMgYSAke3RoaXMubmFtZX1gKX1pZighaGFuZGxlLiQkLnB0cil7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCBwYXNzIGRlbGV0ZWQgb2JqZWN0IGFzIGEgcG9pbnRlciBvZiB0eXBlICR7dGhpcy5uYW1lfWApfWlmKGhhbmRsZS4kJC5wdHJUeXBlLmlzQ29uc3Qpe3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICR7aGFuZGxlLiQkLnB0clR5cGUubmFtZX0gdG8gcGFyYW1ldGVyIHR5cGUgJHt0aGlzLm5hbWV9YCl9dmFyIGhhbmRsZUNsYXNzPWhhbmRsZS4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzczt2YXIgcHRyPXVwY2FzdFBvaW50ZXIoaGFuZGxlLiQkLnB0cixoYW5kbGVDbGFzcyx0aGlzLnJlZ2lzdGVyZWRDbGFzcyk7cmV0dXJuIHB0cn1mdW5jdGlvbiByZWFkUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQVTMyW3BvaW50ZXI+PjJdKX12YXIgaW5pdF9SZWdpc3RlcmVkUG9pbnRlcj0oKT0+e09iamVjdC5hc3NpZ24oUmVnaXN0ZXJlZFBvaW50ZXIucHJvdG90eXBlLHtnZXRQb2ludGVlKHB0cil7aWYodGhpcy5yYXdHZXRQb2ludGVlKXtwdHI9dGhpcy5yYXdHZXRQb2ludGVlKHB0cil9cmV0dXJuIHB0cn0sZGVzdHJ1Y3RvcihwdHIpe2lmKHRoaXMucmF3RGVzdHJ1Y3Rvcil7dGhpcy5yYXdEZXN0cnVjdG9yKHB0cil9fSxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6cmVhZFBvaW50ZXIsXCJkZWxldGVPYmplY3RcIihoYW5kbGUpe2lmKGhhbmRsZSE9PW51bGwpe2hhbmRsZVtcImRlbGV0ZVwiXSgpfX0sXCJmcm9tV2lyZVR5cGVcIjpSZWdpc3RlcmVkUG9pbnRlcl9mcm9tV2lyZVR5cGV9KX07ZnVuY3Rpb24gUmVnaXN0ZXJlZFBvaW50ZXIobmFtZSxyZWdpc3RlcmVkQ2xhc3MsaXNSZWZlcmVuY2UsaXNDb25zdCxpc1NtYXJ0UG9pbnRlcixwb2ludGVlVHlwZSxzaGFyaW5nUG9saWN5LHJhd0dldFBvaW50ZWUscmF3Q29uc3RydWN0b3IscmF3U2hhcmUscmF3RGVzdHJ1Y3Rvcil7dGhpcy5uYW1lPW5hbWU7dGhpcy5yZWdpc3RlcmVkQ2xhc3M9cmVnaXN0ZXJlZENsYXNzO3RoaXMuaXNSZWZlcmVuY2U9aXNSZWZlcmVuY2U7dGhpcy5pc0NvbnN0PWlzQ29uc3Q7dGhpcy5pc1NtYXJ0UG9pbnRlcj1pc1NtYXJ0UG9pbnRlcjt0aGlzLnBvaW50ZWVUeXBlPXBvaW50ZWVUeXBlO3RoaXMuc2hhcmluZ1BvbGljeT1zaGFyaW5nUG9saWN5O3RoaXMucmF3R2V0UG9pbnRlZT1yYXdHZXRQb2ludGVlO3RoaXMucmF3Q29uc3RydWN0b3I9cmF3Q29uc3RydWN0b3I7dGhpcy5yYXdTaGFyZT1yYXdTaGFyZTt0aGlzLnJhd0Rlc3RydWN0b3I9cmF3RGVzdHJ1Y3RvcjtpZighaXNTbWFydFBvaW50ZXImJnJlZ2lzdGVyZWRDbGFzcy5iYXNlQ2xhc3M9PT11bmRlZmluZWQpe2lmKGlzQ29uc3Qpe3RoaXNbXCJ0b1dpcmVUeXBlXCJdPWNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlO3RoaXMuZGVzdHJ1Y3RvckZ1bmN0aW9uPW51bGx9ZWxzZXt0aGlzW1widG9XaXJlVHlwZVwiXT1ub25Db25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZTt0aGlzLmRlc3RydWN0b3JGdW5jdGlvbj1udWxsfX1lbHNle3RoaXNbXCJ0b1dpcmVUeXBlXCJdPWdlbmVyaWNQb2ludGVyVG9XaXJlVHlwZX19dmFyIHJlcGxhY2VQdWJsaWNTeW1ib2w9KG5hbWUsdmFsdWUsbnVtQXJndW1lbnRzKT0+e2lmKCFNb2R1bGUuaGFzT3duUHJvcGVydHkobmFtZSkpe3Rocm93SW50ZXJuYWxFcnJvcihcIlJlcGxhY2luZyBub25leGlzdGFudCBwdWJsaWMgc3ltYm9sXCIpfWlmKHVuZGVmaW5lZCE9PU1vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlJiZ1bmRlZmluZWQhPT1udW1Bcmd1bWVudHMpe01vZHVsZVtuYW1lXS5vdmVybG9hZFRhYmxlW251bUFyZ3VtZW50c109dmFsdWV9ZWxzZXtNb2R1bGVbbmFtZV09dmFsdWU7TW9kdWxlW25hbWVdLmFyZ0NvdW50PW51bUFyZ3VtZW50c319O3ZhciBkeW5DYWxsTGVnYWN5PShzaWcscHRyLGFyZ3MpPT57dmFyIGY9TW9kdWxlW1wiZHluQ2FsbF9cIitzaWddO3JldHVybiBhcmdzJiZhcmdzLmxlbmd0aD9mLmFwcGx5KG51bGwsW3B0cl0uY29uY2F0KGFyZ3MpKTpmLmNhbGwobnVsbCxwdHIpfTt2YXIgd2FzbVRhYmxlTWlycm9yPVtdO3ZhciB3YXNtVGFibGU7dmFyIGdldFdhc21UYWJsZUVudHJ5PWZ1bmNQdHI9Pnt2YXIgZnVuYz13YXNtVGFibGVNaXJyb3JbZnVuY1B0cl07aWYoIWZ1bmMpe2lmKGZ1bmNQdHI+PXdhc21UYWJsZU1pcnJvci5sZW5ndGgpd2FzbVRhYmxlTWlycm9yLmxlbmd0aD1mdW5jUHRyKzE7d2FzbVRhYmxlTWlycm9yW2Z1bmNQdHJdPWZ1bmM9d2FzbVRhYmxlLmdldChmdW5jUHRyKX1yZXR1cm4gZnVuY307dmFyIGR5bkNhbGw9KHNpZyxwdHIsYXJncyk9PntpZihzaWcuaW5jbHVkZXMoXCJqXCIpKXtyZXR1cm4gZHluQ2FsbExlZ2FjeShzaWcscHRyLGFyZ3MpfXZhciBydG49Z2V0V2FzbVRhYmxlRW50cnkocHRyKS5hcHBseShudWxsLGFyZ3MpO3JldHVybiBydG59O3ZhciBnZXREeW5DYWxsZXI9KHNpZyxwdHIpPT57dmFyIGFyZ0NhY2hlPVtdO3JldHVybiBmdW5jdGlvbigpe2FyZ0NhY2hlLmxlbmd0aD0wO09iamVjdC5hc3NpZ24oYXJnQ2FjaGUsYXJndW1lbnRzKTtyZXR1cm4gZHluQ2FsbChzaWcscHRyLGFyZ0NhY2hlKX19O3ZhciBlbWJpbmRfX3JlcXVpcmVGdW5jdGlvbj0oc2lnbmF0dXJlLHJhd0Z1bmN0aW9uKT0+e3NpZ25hdHVyZT1yZWFkTGF0aW4xU3RyaW5nKHNpZ25hdHVyZSk7ZnVuY3Rpb24gbWFrZUR5bkNhbGxlcigpe2lmKHNpZ25hdHVyZS5pbmNsdWRlcyhcImpcIikpe3JldHVybiBnZXREeW5DYWxsZXIoc2lnbmF0dXJlLHJhd0Z1bmN0aW9uKX1yZXR1cm4gZ2V0V2FzbVRhYmxlRW50cnkocmF3RnVuY3Rpb24pfXZhciBmcD1tYWtlRHluQ2FsbGVyKCk7aWYodHlwZW9mIGZwIT1cImZ1bmN0aW9uXCIpe3Rocm93QmluZGluZ0Vycm9yKGB1bmtub3duIGZ1bmN0aW9uIHBvaW50ZXIgd2l0aCBzaWduYXR1cmUgJHtzaWduYXR1cmV9OiAke3Jhd0Z1bmN0aW9ufWApfXJldHVybiBmcH07dmFyIGV4dGVuZEVycm9yPShiYXNlRXJyb3JUeXBlLGVycm9yTmFtZSk9Pnt2YXIgZXJyb3JDbGFzcz1jcmVhdGVOYW1lZEZ1bmN0aW9uKGVycm9yTmFtZSxmdW5jdGlvbihtZXNzYWdlKXt0aGlzLm5hbWU9ZXJyb3JOYW1lO3RoaXMubWVzc2FnZT1tZXNzYWdlO3ZhciBzdGFjaz1uZXcgRXJyb3IobWVzc2FnZSkuc3RhY2s7aWYoc3RhY2shPT11bmRlZmluZWQpe3RoaXMuc3RhY2s9dGhpcy50b1N0cmluZygpK1wiXFxuXCIrc3RhY2sucmVwbGFjZSgvXkVycm9yKDpbXlxcbl0qKT9cXG4vLFwiXCIpfX0pO2Vycm9yQ2xhc3MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYmFzZUVycm9yVHlwZS5wcm90b3R5cGUpO2Vycm9yQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yPWVycm9yQ2xhc3M7ZXJyb3JDbGFzcy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtpZih0aGlzLm1lc3NhZ2U9PT11bmRlZmluZWQpe3JldHVybiB0aGlzLm5hbWV9ZWxzZXtyZXR1cm5gJHt0aGlzLm5hbWV9OiAke3RoaXMubWVzc2FnZX1gfX07cmV0dXJuIGVycm9yQ2xhc3N9O3ZhciBVbmJvdW5kVHlwZUVycm9yO3ZhciBnZXRUeXBlTmFtZT10eXBlPT57dmFyIHB0cj1fX19nZXRUeXBlTmFtZSh0eXBlKTt2YXIgcnY9cmVhZExhdGluMVN0cmluZyhwdHIpO19mcmVlKHB0cik7cmV0dXJuIHJ2fTt2YXIgdGhyb3dVbmJvdW5kVHlwZUVycm9yPShtZXNzYWdlLHR5cGVzKT0+e3ZhciB1bmJvdW5kVHlwZXM9W107dmFyIHNlZW49e307ZnVuY3Rpb24gdmlzaXQodHlwZSl7aWYoc2Vlblt0eXBlXSl7cmV0dXJufWlmKHJlZ2lzdGVyZWRUeXBlc1t0eXBlXSl7cmV0dXJufWlmKHR5cGVEZXBlbmRlbmNpZXNbdHlwZV0pe3R5cGVEZXBlbmRlbmNpZXNbdHlwZV0uZm9yRWFjaCh2aXNpdCk7cmV0dXJufXVuYm91bmRUeXBlcy5wdXNoKHR5cGUpO3NlZW5bdHlwZV09dHJ1ZX10eXBlcy5mb3JFYWNoKHZpc2l0KTt0aHJvdyBuZXcgVW5ib3VuZFR5cGVFcnJvcihgJHttZXNzYWdlfTogYCt1bmJvdW5kVHlwZXMubWFwKGdldFR5cGVOYW1lKS5qb2luKFtcIiwgXCJdKSl9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzcz0ocmF3VHlwZSxyYXdQb2ludGVyVHlwZSxyYXdDb25zdFBvaW50ZXJUeXBlLGJhc2VDbGFzc1Jhd1R5cGUsZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSxnZXRBY3R1YWxUeXBlLHVwY2FzdFNpZ25hdHVyZSx1cGNhc3QsZG93bmNhc3RTaWduYXR1cmUsZG93bmNhc3QsbmFtZSxkZXN0cnVjdG9yU2lnbmF0dXJlLHJhd0Rlc3RydWN0b3IpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO2dldEFjdHVhbFR5cGU9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSxnZXRBY3R1YWxUeXBlKTtpZih1cGNhc3Qpe3VwY2FzdD1lbWJpbmRfX3JlcXVpcmVGdW5jdGlvbih1cGNhc3RTaWduYXR1cmUsdXBjYXN0KX1pZihkb3duY2FzdCl7ZG93bmNhc3Q9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZG93bmNhc3RTaWduYXR1cmUsZG93bmNhc3QpfXJhd0Rlc3RydWN0b3I9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKTt2YXIgbGVnYWxGdW5jdGlvbk5hbWU9bWFrZUxlZ2FsRnVuY3Rpb25OYW1lKG5hbWUpO2V4cG9zZVB1YmxpY1N5bWJvbChsZWdhbEZ1bmN0aW9uTmFtZSxmdW5jdGlvbigpe3Rocm93VW5ib3VuZFR5cGVFcnJvcihgQ2Fubm90IGNvbnN0cnVjdCAke25hbWV9IGR1ZSB0byB1bmJvdW5kIHR5cGVzYCxbYmFzZUNsYXNzUmF3VHlwZV0pfSk7d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW3Jhd1R5cGUscmF3UG9pbnRlclR5cGUscmF3Q29uc3RQb2ludGVyVHlwZV0sYmFzZUNsYXNzUmF3VHlwZT9bYmFzZUNsYXNzUmF3VHlwZV06W10sZnVuY3Rpb24oYmFzZSl7YmFzZT1iYXNlWzBdO3ZhciBiYXNlQ2xhc3M7dmFyIGJhc2VQcm90b3R5cGU7aWYoYmFzZUNsYXNzUmF3VHlwZSl7YmFzZUNsYXNzPWJhc2UucmVnaXN0ZXJlZENsYXNzO2Jhc2VQcm90b3R5cGU9YmFzZUNsYXNzLmluc3RhbmNlUHJvdG90eXBlfWVsc2V7YmFzZVByb3RvdHlwZT1DbGFzc0hhbmRsZS5wcm90b3R5cGV9dmFyIGNvbnN0cnVjdG9yPWNyZWF0ZU5hbWVkRnVuY3Rpb24obGVnYWxGdW5jdGlvbk5hbWUsZnVuY3Rpb24oKXtpZihPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykhPT1pbnN0YW5jZVByb3RvdHlwZSl7dGhyb3cgbmV3IEJpbmRpbmdFcnJvcihcIlVzZSAnbmV3JyB0byBjb25zdHJ1Y3QgXCIrbmFtZSl9aWYodW5kZWZpbmVkPT09cmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpe3Rocm93IG5ldyBCaW5kaW5nRXJyb3IobmFtZStcIiBoYXMgbm8gYWNjZXNzaWJsZSBjb25zdHJ1Y3RvclwiKX12YXIgYm9keT1yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmd1bWVudHMubGVuZ3RoXTtpZih1bmRlZmluZWQ9PT1ib2R5KXt0aHJvdyBuZXcgQmluZGluZ0Vycm9yKGBUcmllZCB0byBpbnZva2UgY3RvciBvZiAke25hbWV9IHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoJHthcmd1bWVudHMubGVuZ3RofSkgLSBleHBlY3RlZCAoJHtPYmplY3Qua2V5cyhyZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keSkudG9TdHJpbmcoKX0pIHBhcmFtZXRlcnMgaW5zdGVhZCFgKX1yZXR1cm4gYm9keS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KTt2YXIgaW5zdGFuY2VQcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShiYXNlUHJvdG90eXBlLHtjb25zdHJ1Y3Rvcjp7dmFsdWU6Y29uc3RydWN0b3J9fSk7Y29uc3RydWN0b3IucHJvdG90eXBlPWluc3RhbmNlUHJvdG90eXBlO3ZhciByZWdpc3RlcmVkQ2xhc3M9bmV3IFJlZ2lzdGVyZWRDbGFzcyhuYW1lLGNvbnN0cnVjdG9yLGluc3RhbmNlUHJvdG90eXBlLHJhd0Rlc3RydWN0b3IsYmFzZUNsYXNzLGdldEFjdHVhbFR5cGUsdXBjYXN0LGRvd25jYXN0KTtpZihyZWdpc3RlcmVkQ2xhc3MuYmFzZUNsYXNzKXtpZihyZWdpc3RlcmVkQ2xhc3MuYmFzZUNsYXNzLl9fZGVyaXZlZENsYXNzZXM9PT11bmRlZmluZWQpe3JlZ2lzdGVyZWRDbGFzcy5iYXNlQ2xhc3MuX19kZXJpdmVkQ2xhc3Nlcz1bXX1yZWdpc3RlcmVkQ2xhc3MuYmFzZUNsYXNzLl9fZGVyaXZlZENsYXNzZXMucHVzaChyZWdpc3RlcmVkQ2xhc3MpfXZhciByZWZlcmVuY2VDb252ZXJ0ZXI9bmV3IFJlZ2lzdGVyZWRQb2ludGVyKG5hbWUscmVnaXN0ZXJlZENsYXNzLHRydWUsZmFsc2UsZmFsc2UpO3ZhciBwb2ludGVyQ29udmVydGVyPW5ldyBSZWdpc3RlcmVkUG9pbnRlcihuYW1lK1wiKlwiLHJlZ2lzdGVyZWRDbGFzcyxmYWxzZSxmYWxzZSxmYWxzZSk7dmFyIGNvbnN0UG9pbnRlckNvbnZlcnRlcj1uZXcgUmVnaXN0ZXJlZFBvaW50ZXIobmFtZStcIiBjb25zdCpcIixyZWdpc3RlcmVkQ2xhc3MsZmFsc2UsdHJ1ZSxmYWxzZSk7cmVnaXN0ZXJlZFBvaW50ZXJzW3Jhd1R5cGVdPXtwb2ludGVyVHlwZTpwb2ludGVyQ29udmVydGVyLGNvbnN0UG9pbnRlclR5cGU6Y29uc3RQb2ludGVyQ29udmVydGVyfTtyZXBsYWNlUHVibGljU3ltYm9sKGxlZ2FsRnVuY3Rpb25OYW1lLGNvbnN0cnVjdG9yKTtyZXR1cm5bcmVmZXJlbmNlQ29udmVydGVyLHBvaW50ZXJDb252ZXJ0ZXIsY29uc3RQb2ludGVyQ29udmVydGVyXX0pfTt2YXIgaGVhcDMyVmVjdG9yVG9BcnJheT0oY291bnQsZmlyc3RFbGVtZW50KT0+e3ZhciBhcnJheT1bXTtmb3IodmFyIGk9MDtpPGNvdW50O2krKyl7YXJyYXkucHVzaChIRUFQVTMyW2ZpcnN0RWxlbWVudCtpKjQ+PjJdKX1yZXR1cm4gYXJyYXl9O2Z1bmN0aW9uIG5ld0Z1bmMoY29uc3RydWN0b3IsYXJndW1lbnRMaXN0KXtpZighKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24pKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBuZXdfIGNhbGxlZCB3aXRoIGNvbnN0cnVjdG9yIHR5cGUgJHt0eXBlb2YgY29uc3RydWN0b3J9IHdoaWNoIGlzIG5vdCBhIGZ1bmN0aW9uYCl9dmFyIGR1bW15PWNyZWF0ZU5hbWVkRnVuY3Rpb24oY29uc3RydWN0b3IubmFtZXx8XCJ1bmtub3duRnVuY3Rpb25OYW1lXCIsZnVuY3Rpb24oKXt9KTtkdW1teS5wcm90b3R5cGU9Y29uc3RydWN0b3IucHJvdG90eXBlO3ZhciBvYmo9bmV3IGR1bW15O3ZhciByPWNvbnN0cnVjdG9yLmFwcGx5KG9iaixhcmd1bWVudExpc3QpO3JldHVybiByIGluc3RhbmNlb2YgT2JqZWN0P3I6b2JqfWZ1bmN0aW9uIGNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSxhcmdUeXBlcyxjbGFzc1R5cGUsY3BwSW52b2tlckZ1bmMsY3BwVGFyZ2V0RnVuYyxpc0FzeW5jKXt2YXIgYXJnQ291bnQ9YXJnVHlwZXMubGVuZ3RoO2lmKGFyZ0NvdW50PDIpe3Rocm93QmluZGluZ0Vycm9yKFwiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhXCIpfXZhciBpc0NsYXNzTWV0aG9kRnVuYz1hcmdUeXBlc1sxXSE9PW51bGwmJmNsYXNzVHlwZSE9PW51bGw7dmFyIG5lZWRzRGVzdHJ1Y3RvclN0YWNrPWZhbHNlO2Zvcih2YXIgaT0xO2k8YXJnVHlwZXMubGVuZ3RoOysraSl7aWYoYXJnVHlwZXNbaV0hPT1udWxsJiZhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb249PT11bmRlZmluZWQpe25lZWRzRGVzdHJ1Y3RvclN0YWNrPXRydWU7YnJlYWt9fXZhciByZXR1cm5zPWFyZ1R5cGVzWzBdLm5hbWUhPT1cInZvaWRcIjt2YXIgYXJnc0xpc3Q9XCJcIjt2YXIgYXJnc0xpc3RXaXJlZD1cIlwiO2Zvcih2YXIgaT0wO2k8YXJnQ291bnQtMjsrK2kpe2FyZ3NMaXN0Kz0oaSE9PTA/XCIsIFwiOlwiXCIpK1wiYXJnXCIraTthcmdzTGlzdFdpcmVkKz0oaSE9PTA/XCIsIFwiOlwiXCIpK1wiYXJnXCIraStcIldpcmVkXCJ9dmFyIGludm9rZXJGbkJvZHk9YFxcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICR7bWFrZUxlZ2FsRnVuY3Rpb25OYW1lKGh1bWFuTmFtZSl9KCR7YXJnc0xpc3R9KSB7XFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gJHthcmdDb3VudC0yfSkge1xcbiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignZnVuY3Rpb24gJHtodW1hbk5hbWV9IGNhbGxlZCB3aXRoICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMsIGV4cGVjdGVkICR7YXJnQ291bnQtMn0nKTtcXG4gICAgICAgIH1gO2lmKG5lZWRzRGVzdHJ1Y3RvclN0YWNrKXtpbnZva2VyRm5Cb2R5Kz1cInZhciBkZXN0cnVjdG9ycyA9IFtdO1xcblwifXZhciBkdG9yU3RhY2s9bmVlZHNEZXN0cnVjdG9yU3RhY2s/XCJkZXN0cnVjdG9yc1wiOlwibnVsbFwiO3ZhciBhcmdzMT1bXCJ0aHJvd0JpbmRpbmdFcnJvclwiLFwiaW52b2tlclwiLFwiZm5cIixcInJ1bkRlc3RydWN0b3JzXCIsXCJyZXRUeXBlXCIsXCJjbGFzc1BhcmFtXCJdO3ZhciBhcmdzMj1bdGhyb3dCaW5kaW5nRXJyb3IsY3BwSW52b2tlckZ1bmMsY3BwVGFyZ2V0RnVuYyxydW5EZXN0cnVjdG9ycyxhcmdUeXBlc1swXSxhcmdUeXBlc1sxXV07aWYoaXNDbGFzc01ldGhvZEZ1bmMpe2ludm9rZXJGbkJvZHkrPVwidmFyIHRoaXNXaXJlZCA9IGNsYXNzUGFyYW0udG9XaXJlVHlwZShcIitkdG9yU3RhY2srXCIsIHRoaXMpO1xcblwifWZvcih2YXIgaT0wO2k8YXJnQ291bnQtMjsrK2kpe2ludm9rZXJGbkJvZHkrPVwidmFyIGFyZ1wiK2krXCJXaXJlZCA9IGFyZ1R5cGVcIitpK1wiLnRvV2lyZVR5cGUoXCIrZHRvclN0YWNrK1wiLCBhcmdcIitpK1wiKTsgLy8gXCIrYXJnVHlwZXNbaSsyXS5uYW1lK1wiXFxuXCI7YXJnczEucHVzaChcImFyZ1R5cGVcIitpKTthcmdzMi5wdXNoKGFyZ1R5cGVzW2krMl0pfWlmKGlzQ2xhc3NNZXRob2RGdW5jKXthcmdzTGlzdFdpcmVkPVwidGhpc1dpcmVkXCIrKGFyZ3NMaXN0V2lyZWQubGVuZ3RoPjA/XCIsIFwiOlwiXCIpK2FyZ3NMaXN0V2lyZWR9aW52b2tlckZuQm9keSs9KHJldHVybnN8fGlzQXN5bmM/XCJ2YXIgcnYgPSBcIjpcIlwiKStcImludm9rZXIoZm5cIisoYXJnc0xpc3RXaXJlZC5sZW5ndGg+MD9cIiwgXCI6XCJcIikrYXJnc0xpc3RXaXJlZCtcIik7XFxuXCI7aWYobmVlZHNEZXN0cnVjdG9yU3RhY2spe2ludm9rZXJGbkJvZHkrPVwicnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpO1xcblwifWVsc2V7Zm9yKHZhciBpPWlzQ2xhc3NNZXRob2RGdW5jPzE6MjtpPGFyZ1R5cGVzLmxlbmd0aDsrK2kpe3ZhciBwYXJhbU5hbWU9aT09PTE/XCJ0aGlzV2lyZWRcIjpcImFyZ1wiKyhpLTIpK1wiV2lyZWRcIjtpZihhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24hPT1udWxsKXtpbnZva2VyRm5Cb2R5Kz1wYXJhbU5hbWUrXCJfZHRvcihcIitwYXJhbU5hbWUrXCIpOyAvLyBcIithcmdUeXBlc1tpXS5uYW1lK1wiXFxuXCI7YXJnczEucHVzaChwYXJhbU5hbWUrXCJfZHRvclwiKTthcmdzMi5wdXNoKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbil9fX1pZihyZXR1cm5zKXtpbnZva2VyRm5Cb2R5Kz1cInZhciByZXQgPSByZXRUeXBlLmZyb21XaXJlVHlwZShydik7XFxuXCIrXCJyZXR1cm4gcmV0O1xcblwifWVsc2V7fWludm9rZXJGbkJvZHkrPVwifVxcblwiO2FyZ3MxLnB1c2goaW52b2tlckZuQm9keSk7cmV0dXJuIG5ld0Z1bmMoRnVuY3Rpb24sYXJnczEpLmFwcGx5KG51bGwsYXJnczIpfXZhciBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3Rvcj0ocmF3Q2xhc3NUeXBlLGFyZ0NvdW50LHJhd0FyZ1R5cGVzQWRkcixpbnZva2VyU2lnbmF0dXJlLGludm9rZXIscmF3Q29uc3RydWN0b3IpPT57dmFyIHJhd0FyZ1R5cGVzPWhlYXAzMlZlY3RvclRvQXJyYXkoYXJnQ291bnQscmF3QXJnVHlwZXNBZGRyKTtpbnZva2VyPWVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGludm9rZXJTaWduYXR1cmUsaW52b2tlcik7d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sW3Jhd0NsYXNzVHlwZV0sZnVuY3Rpb24oY2xhc3NUeXBlKXtjbGFzc1R5cGU9Y2xhc3NUeXBlWzBdO3ZhciBodW1hbk5hbWU9YGNvbnN0cnVjdG9yICR7Y2xhc3NUeXBlLm5hbWV9YDtpZih1bmRlZmluZWQ9PT1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHkpe2NsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keT1bXX1pZih1bmRlZmluZWQhPT1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQtMV0pe3Rocm93IG5ldyBCaW5kaW5nRXJyb3IoYENhbm5vdCByZWdpc3RlciBtdWx0aXBsZSBjb25zdHJ1Y3RvcnMgd2l0aCBpZGVudGljYWwgbnVtYmVyIG9mIHBhcmFtZXRlcnMgKCR7YXJnQ291bnQtMX0pIGZvciBjbGFzcyAnJHtjbGFzc1R5cGUubmFtZX0nISBPdmVybG9hZCByZXNvbHV0aW9uIGlzIGN1cnJlbnRseSBvbmx5IHBlcmZvcm1lZCB1c2luZyB0aGUgcGFyYW1ldGVyIGNvdW50LCBub3QgYWN0dWFsIHR5cGUgaW5mbyFgKX1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmNvbnN0cnVjdG9yX2JvZHlbYXJnQ291bnQtMV09KCk9Pnt0aHJvd1VuYm91bmRUeXBlRXJyb3IoYENhbm5vdCBjb25zdHJ1Y3QgJHtjbGFzc1R5cGUubmFtZX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLHJhd0FyZ1R5cGVzKX07d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10scmF3QXJnVHlwZXMsYXJnVHlwZXM9PnthcmdUeXBlcy5zcGxpY2UoMSwwLG51bGwpO2NsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3JfYm9keVthcmdDb3VudC0xXT1jcmFmdEludm9rZXJGdW5jdGlvbihodW1hbk5hbWUsYXJnVHlwZXMsbnVsbCxpbnZva2VyLHJhd0NvbnN0cnVjdG9yKTtyZXR1cm5bXX0pO3JldHVybltdfSl9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbj0ocmF3Q2xhc3NUeXBlLG1ldGhvZE5hbWUsYXJnQ291bnQscmF3QXJnVHlwZXNBZGRyLGludm9rZXJTaWduYXR1cmUscmF3SW52b2tlcixjb250ZXh0LGlzUHVyZVZpcnR1YWwsaXNBc3luYyk9Pnt2YXIgcmF3QXJnVHlwZXM9aGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIpO21ldGhvZE5hbWU9cmVhZExhdGluMVN0cmluZyhtZXRob2ROYW1lKTtyYXdJbnZva2VyPWVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGludm9rZXJTaWduYXR1cmUscmF3SW52b2tlcik7d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sW3Jhd0NsYXNzVHlwZV0sZnVuY3Rpb24oY2xhc3NUeXBlKXtjbGFzc1R5cGU9Y2xhc3NUeXBlWzBdO3ZhciBodW1hbk5hbWU9YCR7Y2xhc3NUeXBlLm5hbWV9LiR7bWV0aG9kTmFtZX1gO2lmKG1ldGhvZE5hbWUuc3RhcnRzV2l0aChcIkBAXCIpKXttZXRob2ROYW1lPVN5bWJvbFttZXRob2ROYW1lLnN1YnN0cmluZygyKV19aWYoaXNQdXJlVmlydHVhbCl7Y2xhc3NUeXBlLnJlZ2lzdGVyZWRDbGFzcy5wdXJlVmlydHVhbEZ1bmN0aW9ucy5wdXNoKG1ldGhvZE5hbWUpfWZ1bmN0aW9uIHVuYm91bmRUeXBlc0hhbmRsZXIoKXt0aHJvd1VuYm91bmRUeXBlRXJyb3IoYENhbm5vdCBjYWxsICR7aHVtYW5OYW1lfSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AscmF3QXJnVHlwZXMpfXZhciBwcm90bz1jbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlO3ZhciBtZXRob2Q9cHJvdG9bbWV0aG9kTmFtZV07aWYodW5kZWZpbmVkPT09bWV0aG9kfHx1bmRlZmluZWQ9PT1tZXRob2Qub3ZlcmxvYWRUYWJsZSYmbWV0aG9kLmNsYXNzTmFtZSE9PWNsYXNzVHlwZS5uYW1lJiZtZXRob2QuYXJnQ291bnQ9PT1hcmdDb3VudC0yKXt1bmJvdW5kVHlwZXNIYW5kbGVyLmFyZ0NvdW50PWFyZ0NvdW50LTI7dW5ib3VuZFR5cGVzSGFuZGxlci5jbGFzc05hbWU9Y2xhc3NUeXBlLm5hbWU7cHJvdG9bbWV0aG9kTmFtZV09dW5ib3VuZFR5cGVzSGFuZGxlcn1lbHNle2Vuc3VyZU92ZXJsb2FkVGFibGUocHJvdG8sbWV0aG9kTmFtZSxodW1hbk5hbWUpO3Byb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGVbYXJnQ291bnQtMl09dW5ib3VuZFR5cGVzSGFuZGxlcn13aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSxyYXdBcmdUeXBlcyxmdW5jdGlvbihhcmdUeXBlcyl7dmFyIG1lbWJlckZ1bmN0aW9uPWNyYWZ0SW52b2tlckZ1bmN0aW9uKGh1bWFuTmFtZSxhcmdUeXBlcyxjbGFzc1R5cGUscmF3SW52b2tlcixjb250ZXh0LGlzQXN5bmMpO2lmKHVuZGVmaW5lZD09PXByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUpe21lbWJlckZ1bmN0aW9uLmFyZ0NvdW50PWFyZ0NvdW50LTI7cHJvdG9bbWV0aG9kTmFtZV09bWVtYmVyRnVuY3Rpb259ZWxzZXtwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ0NvdW50LTJdPW1lbWJlckZ1bmN0aW9ufXJldHVybltdfSk7cmV0dXJuW119KX07dmFyIHZhbGlkYXRlVGhpcz0odGhpc18sY2xhc3NUeXBlLGh1bWFuTmFtZSk9PntpZighKHRoaXNfIGluc3RhbmNlb2YgT2JqZWN0KSl7dGhyb3dCaW5kaW5nRXJyb3IoYCR7aHVtYW5OYW1lfSB3aXRoIGludmFsaWQgXCJ0aGlzXCI6ICR7dGhpc199YCl9aWYoISh0aGlzXyBpbnN0YW5jZW9mIGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuY29uc3RydWN0b3IpKXt0aHJvd0JpbmRpbmdFcnJvcihgJHtodW1hbk5hbWV9IGluY29tcGF0aWJsZSB3aXRoIFwidGhpc1wiIG9mIHR5cGUgJHt0aGlzXy5jb25zdHJ1Y3Rvci5uYW1lfWApfWlmKCF0aGlzXy4kJC5wdHIpe3Rocm93QmluZGluZ0Vycm9yKGBjYW5ub3QgY2FsbCBlbXNjcmlwdGVuIGJpbmRpbmcgbWV0aG9kICR7aHVtYW5OYW1lfSBvbiBkZWxldGVkIG9iamVjdGApfXJldHVybiB1cGNhc3RQb2ludGVyKHRoaXNfLiQkLnB0cix0aGlzXy4kJC5wdHJUeXBlLnJlZ2lzdGVyZWRDbGFzcyxjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzKX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX3Byb3BlcnR5PShjbGFzc1R5cGUsZmllbGROYW1lLGdldHRlclJldHVyblR5cGUsZ2V0dGVyU2lnbmF0dXJlLGdldHRlcixnZXR0ZXJDb250ZXh0LHNldHRlckFyZ3VtZW50VHlwZSxzZXR0ZXJTaWduYXR1cmUsc2V0dGVyLHNldHRlckNvbnRleHQpPT57ZmllbGROYW1lPXJlYWRMYXRpbjFTdHJpbmcoZmllbGROYW1lKTtnZXR0ZXI9ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0dGVyU2lnbmF0dXJlLGdldHRlcik7d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW10sW2NsYXNzVHlwZV0sZnVuY3Rpb24oY2xhc3NUeXBlKXtjbGFzc1R5cGU9Y2xhc3NUeXBlWzBdO3ZhciBodW1hbk5hbWU9YCR7Y2xhc3NUeXBlLm5hbWV9LiR7ZmllbGROYW1lfWA7dmFyIGRlc2M9e2dldCgpe3Rocm93VW5ib3VuZFR5cGVFcnJvcihgQ2Fubm90IGFjY2VzcyAke2h1bWFuTmFtZX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLFtnZXR0ZXJSZXR1cm5UeXBlLHNldHRlckFyZ3VtZW50VHlwZV0pfSxlbnVtZXJhYmxlOnRydWUsY29uZmlndXJhYmxlOnRydWV9O2lmKHNldHRlcil7ZGVzYy5zZXQ9KCk9PnRocm93VW5ib3VuZFR5cGVFcnJvcihgQ2Fubm90IGFjY2VzcyAke2h1bWFuTmFtZX0gZHVlIHRvIHVuYm91bmQgdHlwZXNgLFtnZXR0ZXJSZXR1cm5UeXBlLHNldHRlckFyZ3VtZW50VHlwZV0pfWVsc2V7ZGVzYy5zZXQ9dj0+dGhyb3dCaW5kaW5nRXJyb3IoaHVtYW5OYW1lK1wiIGlzIGEgcmVhZC1vbmx5IHByb3BlcnR5XCIpfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbGFzc1R5cGUucmVnaXN0ZXJlZENsYXNzLmluc3RhbmNlUHJvdG90eXBlLGZpZWxkTmFtZSxkZXNjKTt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSxzZXR0ZXI/W2dldHRlclJldHVyblR5cGUsc2V0dGVyQXJndW1lbnRUeXBlXTpbZ2V0dGVyUmV0dXJuVHlwZV0sZnVuY3Rpb24odHlwZXMpe3ZhciBnZXR0ZXJSZXR1cm5UeXBlPXR5cGVzWzBdO3ZhciBkZXNjPXtnZXQoKXt2YXIgcHRyPXZhbGlkYXRlVGhpcyh0aGlzLGNsYXNzVHlwZSxodW1hbk5hbWUrXCIgZ2V0dGVyXCIpO3JldHVybiBnZXR0ZXJSZXR1cm5UeXBlW1wiZnJvbVdpcmVUeXBlXCJdKGdldHRlcihnZXR0ZXJDb250ZXh0LHB0cikpfSxlbnVtZXJhYmxlOnRydWV9O2lmKHNldHRlcil7c2V0dGVyPWVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNldHRlclNpZ25hdHVyZSxzZXR0ZXIpO3ZhciBzZXR0ZXJBcmd1bWVudFR5cGU9dHlwZXNbMV07ZGVzYy5zZXQ9ZnVuY3Rpb24odil7dmFyIHB0cj12YWxpZGF0ZVRoaXModGhpcyxjbGFzc1R5cGUsaHVtYW5OYW1lK1wiIHNldHRlclwiKTt2YXIgZGVzdHJ1Y3RvcnM9W107c2V0dGVyKHNldHRlckNvbnRleHQscHRyLHNldHRlckFyZ3VtZW50VHlwZVtcInRvV2lyZVR5cGVcIl0oZGVzdHJ1Y3RvcnMsdikpO3J1bkRlc3RydWN0b3JzKGRlc3RydWN0b3JzKX19T2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzVHlwZS5yZWdpc3RlcmVkQ2xhc3MuaW5zdGFuY2VQcm90b3R5cGUsZmllbGROYW1lLGRlc2MpO3JldHVybltdfSk7cmV0dXJuW119KX07ZnVuY3Rpb24gaGFuZGxlQWxsb2NhdG9ySW5pdCgpe09iamVjdC5hc3NpZ24oSGFuZGxlQWxsb2NhdG9yLnByb3RvdHlwZSx7Z2V0KGlkKXtyZXR1cm4gdGhpcy5hbGxvY2F0ZWRbaWRdfSxoYXMoaWQpe3JldHVybiB0aGlzLmFsbG9jYXRlZFtpZF0hPT11bmRlZmluZWR9LGFsbG9jYXRlKGhhbmRsZSl7dmFyIGlkPXRoaXMuZnJlZWxpc3QucG9wKCl8fHRoaXMuYWxsb2NhdGVkLmxlbmd0aDt0aGlzLmFsbG9jYXRlZFtpZF09aGFuZGxlO3JldHVybiBpZH0sZnJlZShpZCl7dGhpcy5hbGxvY2F0ZWRbaWRdPXVuZGVmaW5lZDt0aGlzLmZyZWVsaXN0LnB1c2goaWQpfX0pfWZ1bmN0aW9uIEhhbmRsZUFsbG9jYXRvcigpe3RoaXMuYWxsb2NhdGVkPVt1bmRlZmluZWRdO3RoaXMuZnJlZWxpc3Q9W119dmFyIGVtdmFsX2hhbmRsZXM9bmV3IEhhbmRsZUFsbG9jYXRvcjt2YXIgX19lbXZhbF9kZWNyZWY9aGFuZGxlPT57aWYoaGFuZGxlPj1lbXZhbF9oYW5kbGVzLnJlc2VydmVkJiYwPT09LS1lbXZhbF9oYW5kbGVzLmdldChoYW5kbGUpLnJlZmNvdW50KXtlbXZhbF9oYW5kbGVzLmZyZWUoaGFuZGxlKX19O3ZhciBjb3VudF9lbXZhbF9oYW5kbGVzPSgpPT57dmFyIGNvdW50PTA7Zm9yKHZhciBpPWVtdmFsX2hhbmRsZXMucmVzZXJ2ZWQ7aTxlbXZhbF9oYW5kbGVzLmFsbG9jYXRlZC5sZW5ndGg7KytpKXtpZihlbXZhbF9oYW5kbGVzLmFsbG9jYXRlZFtpXSE9PXVuZGVmaW5lZCl7Kytjb3VudH19cmV0dXJuIGNvdW50fTt2YXIgaW5pdF9lbXZhbD0oKT0+e2VtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLnB1c2goe3ZhbHVlOnVuZGVmaW5lZH0se3ZhbHVlOm51bGx9LHt2YWx1ZTp0cnVlfSx7dmFsdWU6ZmFsc2V9KTtlbXZhbF9oYW5kbGVzLnJlc2VydmVkPWVtdmFsX2hhbmRsZXMuYWxsb2NhdGVkLmxlbmd0aDtNb2R1bGVbXCJjb3VudF9lbXZhbF9oYW5kbGVzXCJdPWNvdW50X2VtdmFsX2hhbmRsZXN9O3ZhciBFbXZhbD17dG9WYWx1ZTpoYW5kbGU9PntpZighaGFuZGxlKXt0aHJvd0JpbmRpbmdFcnJvcihcIkNhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9IFwiK2hhbmRsZSl9cmV0dXJuIGVtdmFsX2hhbmRsZXMuZ2V0KGhhbmRsZSkudmFsdWV9LHRvSGFuZGxlOnZhbHVlPT57c3dpdGNoKHZhbHVlKXtjYXNlIHVuZGVmaW5lZDpyZXR1cm4gMTtjYXNlIG51bGw6cmV0dXJuIDI7Y2FzZSB0cnVlOnJldHVybiAzO2Nhc2UgZmFsc2U6cmV0dXJuIDQ7ZGVmYXVsdDp7cmV0dXJuIGVtdmFsX2hhbmRsZXMuYWxsb2NhdGUoe3JlZmNvdW50OjEsdmFsdWU6dmFsdWV9KX19fX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsPShyYXdUeXBlLG5hbWUpPT57bmFtZT1yZWFkTGF0aW4xU3RyaW5nKG5hbWUpO3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsXCJmcm9tV2lyZVR5cGVcIjpoYW5kbGU9Pnt2YXIgcnY9RW12YWwudG9WYWx1ZShoYW5kbGUpO19fZW12YWxfZGVjcmVmKGhhbmRsZSk7cmV0dXJuIHJ2fSxcInRvV2lyZVR5cGVcIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT5FbXZhbC50b0hhbmRsZSh2YWx1ZSksXCJhcmdQYWNrQWR2YW5jZVwiOkdlbmVyaWNXaXJlVHlwZVNpemUsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSl9O3ZhciBlbnVtUmVhZFZhbHVlRnJvbVBvaW50ZXI9KG5hbWUsd2lkdGgsc2lnbmVkKT0+e3N3aXRjaCh3aWR0aCl7Y2FzZSAxOnJldHVybiBzaWduZWQ/ZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUDhbcG9pbnRlcj4+MF0pfTpmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQVThbcG9pbnRlcj4+MF0pfTtjYXNlIDI6cmV0dXJuIHNpZ25lZD9mdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQMTZbcG9pbnRlcj4+MV0pfTpmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQVTE2W3BvaW50ZXI+PjFdKX07Y2FzZSA0OnJldHVybiBzaWduZWQ/ZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUDMyW3BvaW50ZXI+PjJdKX06ZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUFUzMltwb2ludGVyPj4yXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBpbnRlZ2VyIHdpZHRoICgke3dpZHRofSk6ICR7bmFtZX1gKX19O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9lbnVtPShyYXdUeXBlLG5hbWUsc2l6ZSxpc1NpZ25lZCk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7ZnVuY3Rpb24gY3Rvcigpe31jdG9yLnZhbHVlcz17fTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLGNvbnN0cnVjdG9yOmN0b3IsXCJmcm9tV2lyZVR5cGVcIjpmdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci52YWx1ZXNbY119LFwidG9XaXJlVHlwZVwiOihkZXN0cnVjdG9ycyxjKT0+Yy52YWx1ZSxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6ZW51bVJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2l6ZSxpc1NpZ25lZCksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KTtleHBvc2VQdWJsaWNTeW1ib2wobmFtZSxjdG9yKX07dmFyIHJlcXVpcmVSZWdpc3RlcmVkVHlwZT0ocmF3VHlwZSxodW1hbk5hbWUpPT57dmFyIGltcGw9cmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdO2lmKHVuZGVmaW5lZD09PWltcGwpe3Rocm93QmluZGluZ0Vycm9yKGh1bWFuTmFtZStcIiBoYXMgdW5rbm93biB0eXBlIFwiK2dldFR5cGVOYW1lKHJhd1R5cGUpKX1yZXR1cm4gaW1wbH07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2VudW1fdmFsdWU9KHJhd0VudW1UeXBlLG5hbWUsZW51bVZhbHVlKT0+e3ZhciBlbnVtVHlwZT1yZXF1aXJlUmVnaXN0ZXJlZFR5cGUocmF3RW51bVR5cGUsXCJlbnVtXCIpO25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgRW51bT1lbnVtVHlwZS5jb25zdHJ1Y3Rvcjt2YXIgVmFsdWU9T2JqZWN0LmNyZWF0ZShlbnVtVHlwZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUse3ZhbHVlOnt2YWx1ZTplbnVtVmFsdWV9LGNvbnN0cnVjdG9yOnt2YWx1ZTpjcmVhdGVOYW1lZEZ1bmN0aW9uKGAke2VudW1UeXBlLm5hbWV9XyR7bmFtZX1gLGZ1bmN0aW9uKCl7fSl9fSk7RW51bS52YWx1ZXNbZW51bVZhbHVlXT1WYWx1ZTtFbnVtW25hbWVdPVZhbHVlfTt2YXIgZW1iaW5kUmVwcj12PT57aWYodj09PW51bGwpe3JldHVyblwibnVsbFwifXZhciB0PXR5cGVvZiB2O2lmKHQ9PT1cIm9iamVjdFwifHx0PT09XCJhcnJheVwifHx0PT09XCJmdW5jdGlvblwiKXtyZXR1cm4gdi50b1N0cmluZygpfWVsc2V7cmV0dXJuXCJcIit2fX07dmFyIGZsb2F0UmVhZFZhbHVlRnJvbVBvaW50ZXI9KG5hbWUsd2lkdGgpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDQ6cmV0dXJuIGZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVBGMzJbcG9pbnRlcj4+Ml0pfTtjYXNlIDg6cmV0dXJuIGZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVBGNjRbcG9pbnRlcj4+M10pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgZmxvYXQgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0PShyYXdUeXBlLG5hbWUsc2l6ZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiOnZhbHVlPT52YWx1ZSxcInRvV2lyZVR5cGVcIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT52YWx1ZSxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6ZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcihuYW1lLHNpemUpLGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSl9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbj0obmFtZSxhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIsc2lnbmF0dXJlLHJhd0ludm9rZXIsZm4saXNBc3luYyk9Pnt2YXIgYXJnVHlwZXM9aGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIpO25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyYXdJbnZva2VyPWVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNpZ25hdHVyZSxyYXdJbnZva2VyKTtleHBvc2VQdWJsaWNTeW1ib2wobmFtZSxmdW5jdGlvbigpe3Rocm93VW5ib3VuZFR5cGVFcnJvcihgQ2Fubm90IGNhbGwgJHtuYW1lfSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsYXJnVHlwZXMpfSxhcmdDb3VudC0xKTt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSxhcmdUeXBlcyxmdW5jdGlvbihhcmdUeXBlcyl7dmFyIGludm9rZXJBcmdzQXJyYXk9W2FyZ1R5cGVzWzBdLG51bGxdLmNvbmNhdChhcmdUeXBlcy5zbGljZSgxKSk7cmVwbGFjZVB1YmxpY1N5bWJvbChuYW1lLGNyYWZ0SW52b2tlckZ1bmN0aW9uKG5hbWUsaW52b2tlckFyZ3NBcnJheSxudWxsLHJhd0ludm9rZXIsZm4saXNBc3luYyksYXJnQ291bnQtMSk7cmV0dXJuW119KX07dmFyIGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCxzaWduZWQpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDE6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQOFtwb2ludGVyPj4wXTpwb2ludGVyPT5IRUFQVThbcG9pbnRlcj4+MF07Y2FzZSAyOnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDE2W3BvaW50ZXI+PjFdOnBvaW50ZXI9PkhFQVBVMTZbcG9pbnRlcj4+MV07Y2FzZSA0OnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDMyW3BvaW50ZXI+PjJdOnBvaW50ZXI9PkhFQVBVMzJbcG9pbnRlcj4+Ml07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXI9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtpZihtYXhSYW5nZT09PS0xKXttYXhSYW5nZT00Mjk0OTY3Mjk1fXZhciBmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlO2lmKG1pblJhbmdlPT09MCl7dmFyIGJpdHNoaWZ0PTMyLTgqc2l6ZTtmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlPDxiaXRzaGlmdD4+PmJpdHNoaWZ0fXZhciBpc1Vuc2lnbmVkVHlwZT1uYW1lLmluY2x1ZGVzKFwidW5zaWduZWRcIik7dmFyIGNoZWNrQXNzZXJ0aW9ucz0odmFsdWUsdG9UeXBlTmFtZSk9Pnt9O3ZhciB0b1dpcmVUeXBlO2lmKGlzVW5zaWduZWRUeXBlKXt0b1dpcmVUeXBlPWZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtjaGVja0Fzc2VydGlvbnModmFsdWUsdGhpcy5uYW1lKTtyZXR1cm4gdmFsdWU+Pj4wfX1lbHNle3RvV2lyZVR5cGU9ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2NoZWNrQXNzZXJ0aW9ucyh2YWx1ZSx0aGlzLm5hbWUpO3JldHVybiB2YWx1ZX19cmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiOmZyb21XaXJlVHlwZSxcInRvV2lyZVR5cGVcIjp0b1dpcmVUeXBlLFwiYXJnUGFja0FkdmFuY2VcIjpHZW5lcmljV2lyZVR5cGVTaXplLFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjppbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplLG1pblJhbmdlIT09MCksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3PShyYXdUeXBlLGRhdGFUeXBlSW5kZXgsbmFtZSk9Pnt2YXIgdHlwZU1hcHBpbmc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5XTt2YXIgVEE9dHlwZU1hcHBpbmdbZGF0YVR5cGVJbmRleF07ZnVuY3Rpb24gZGVjb2RlTWVtb3J5VmlldyhoYW5kbGUpe3ZhciBzaXplPUhFQVBVMzJbaGFuZGxlPj4yXTt2YXIgZGF0YT1IRUFQVTMyW2hhbmRsZSs0Pj4yXTtyZXR1cm4gbmV3IFRBKEhFQVA4LmJ1ZmZlcixkYXRhLHNpemUpfW5hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6ZGVjb2RlTWVtb3J5VmlldyxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6ZGVjb2RlTWVtb3J5Vmlld30se2lnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnM6dHJ1ZX0pfTt2YXIgc3RyaW5nVG9VVEY4QXJyYXk9KHN0cixoZWFwLG91dElkeCxtYXhCeXRlc1RvV3JpdGUpPT57aWYoIShtYXhCeXRlc1RvV3JpdGU+MCkpcmV0dXJuIDA7dmFyIHN0YXJ0SWR4PW91dElkeDt2YXIgZW5kSWR4PW91dElkeCttYXhCeXRlc1RvV3JpdGUtMTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpe3ZhciB1MT1zdHIuY2hhckNvZGVBdCgrK2kpO3U9NjU1MzYrKCh1JjEwMjMpPDwxMCl8dTEmMTAyM31pZih1PD0xMjcpe2lmKG91dElkeD49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPXV9ZWxzZSBpZih1PD0yMDQ3KXtpZihvdXRJZHgrMT49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTE5Mnx1Pj42O2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2UgaWYodTw9NjU1MzUpe2lmKG91dElkeCsyPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjI0fHU+PjEyO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2V7aWYob3V0SWR4KzM+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yNDB8dT4+MTg7aGVhcFtvdXRJZHgrK109MTI4fHU+PjEyJjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfX1oZWFwW291dElkeF09MDtyZXR1cm4gb3V0SWR4LXN0YXJ0SWR4fTt2YXIgc3RyaW5nVG9VVEY4PShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PnN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQVTgsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk7dmFyIGxlbmd0aEJ5dGVzVVRGOD1zdHI9Pnt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGM9c3RyLmNoYXJDb2RlQXQoaSk7aWYoYzw9MTI3KXtsZW4rK31lbHNlIGlmKGM8PTIwNDcpe2xlbis9Mn1lbHNlIGlmKGM+PTU1Mjk2JiZjPD01NzM0Myl7bGVuKz00OysraX1lbHNle2xlbis9M319cmV0dXJuIGxlbn07dmFyIFVURjhEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9XCJ1bmRlZmluZWRcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnVuZGVmaW5lZDt2YXIgVVRGOEFycmF5VG9TdHJpbmc9KGhlYXBPckFycmF5LGlkeCxtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgZW5kSWR4PWlkeCttYXhCeXRlc1RvUmVhZDt2YXIgZW5kUHRyPWlkeDt3aGlsZShoZWFwT3JBcnJheVtlbmRQdHJdJiYhKGVuZFB0cj49ZW5kSWR4KSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZoZWFwT3JBcnJheS5idWZmZXImJlVURjhEZWNvZGVyKXtyZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCxlbmRQdHIpKX12YXIgc3RyPVwiXCI7d2hpbGUoaWR4PGVuZFB0cil7dmFyIHUwPWhlYXBPckFycmF5W2lkeCsrXTtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dmFyIHUxPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjI0KT09MTkyKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKHUwJjMxKTw8Nnx1MSk7Y29udGludWV9dmFyIHUyPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mn1lbHNle3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fGhlYXBPckFycmF5W2lkeCsrXSY2M31pZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKX1lbHNle3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfX1yZXR1cm4gc3RyfTt2YXIgVVRGOFRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT5wdHI/VVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LHB0cixtYXhCeXRlc1RvUmVhZCk6XCJcIjt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZz0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgc3RkU3RyaW5nSXNVVEY4PW5hbWU9PT1cInN0ZDo6c3RyaW5nXCI7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiKHZhbHVlKXt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBwYXlsb2FkPXZhbHVlKzQ7dmFyIHN0cjtpZihzdGRTdHJpbmdJc1VURjgpe3ZhciBkZWNvZGVTdGFydFB0cj1wYXlsb2FkO2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj1wYXlsb2FkK2k7aWYoaT09bGVuZ3RofHxIRUFQVThbY3VycmVudEJ5dGVQdHJdPT0wKXt2YXIgbWF4UmVhZD1jdXJyZW50Qnl0ZVB0ci1kZWNvZGVTdGFydFB0cjt2YXIgc3RyaW5nU2VnbWVudD1VVEY4VG9TdHJpbmcoZGVjb2RlU3RhcnRQdHIsbWF4UmVhZCk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudH1lbHNle3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnR9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrMX19fWVsc2V7dmFyIGE9bmV3IEFycmF5KGxlbmd0aCk7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXthW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoSEVBUFU4W3BheWxvYWQraV0pfXN0cj1hLmpvaW4oXCJcIil9X2ZyZWUodmFsdWUpO3JldHVybiBzdHJ9LFwidG9XaXJlVHlwZVwiKGRlc3RydWN0b3JzLHZhbHVlKXtpZih2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXt2YWx1ZT1uZXcgVWludDhBcnJheSh2YWx1ZSl9dmFyIGxlbmd0aDt2YXIgdmFsdWVJc09mVHlwZVN0cmluZz10eXBlb2YgdmFsdWU9PVwic3RyaW5nXCI7aWYoISh2YWx1ZUlzT2ZUeXBlU3RyaW5nfHx2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5KSl7dGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nXCIpfWlmKHN0ZFN0cmluZ0lzVVRGOCYmdmFsdWVJc09mVHlwZVN0cmluZyl7bGVuZ3RoPWxlbmd0aEJ5dGVzVVRGOCh2YWx1ZSl9ZWxzZXtsZW5ndGg9dmFsdWUubGVuZ3RofXZhciBiYXNlPV9tYWxsb2MoNCtsZW5ndGgrMSk7dmFyIHB0cj1iYXNlKzQ7SEVBUFUzMltiYXNlPj4yXT1sZW5ndGg7aWYoc3RkU3RyaW5nSXNVVEY4JiZ2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtzdHJpbmdUb1VURjgodmFsdWUscHRyLGxlbmd0aCsxKX1lbHNle2lmKHZhbHVlSXNPZlR5cGVTdHJpbmcpe2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7dmFyIGNoYXJDb2RlPXZhbHVlLmNoYXJDb2RlQXQoaSk7aWYoY2hhckNvZGU+MjU1KXtfZnJlZShwdHIpO3Rocm93QmluZGluZ0Vycm9yKFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpfUhFQVBVOFtwdHIraV09Y2hhckNvZGV9fWVsc2V7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXtIRUFQVThbcHRyK2ldPXZhbHVlW2ldfX19aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLGJhc2UpfXJldHVybiBiYXNlfSxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6cmVhZFBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cil7X2ZyZWUocHRyKX19KX07dmFyIFVURjE2RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPVwidW5kZWZpbmVkXCI/bmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIik6dW5kZWZpbmVkO3ZhciBVVEYxNlRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGVuZFB0cj1wdHI7dmFyIGlkeD1lbmRQdHI+PjE7dmFyIG1heElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQvMjt3aGlsZSghKGlkeD49bWF4SWR4KSYmSEVBUFUxNltpZHhdKSsraWR4O2VuZFB0cj1pZHg8PDE7aWYoZW5kUHRyLXB0cj4zMiYmVVRGMTZEZWNvZGVyKXJldHVybiBVVEYxNkRlY29kZXIuZGVjb2RlKEhFQVBVOC5zdWJhcnJheShwdHIsZW5kUHRyKSk7dmFyIHN0cj1cIlwiO2Zvcih2YXIgaT0wOyEoaT49bWF4Qnl0ZXNUb1JlYWQvMik7KytpKXt2YXIgY29kZVVuaXQ9SEVBUDE2W3B0citpKjI+PjFdO2lmKGNvZGVVbml0PT0wKWJyZWFrO3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlVW5pdCl9cmV0dXJuIHN0cn07dmFyIHN0cmluZ1RvVVRGMTY9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+e2lmKG1heEJ5dGVzVG9Xcml0ZT09PXVuZGVmaW5lZCl7bWF4Qnl0ZXNUb1dyaXRlPTIxNDc0ODM2NDd9aWYobWF4Qnl0ZXNUb1dyaXRlPDIpcmV0dXJuIDA7bWF4Qnl0ZXNUb1dyaXRlLT0yO3ZhciBzdGFydFB0cj1vdXRQdHI7dmFyIG51bUNoYXJzVG9Xcml0ZT1tYXhCeXRlc1RvV3JpdGU8c3RyLmxlbmd0aCoyP21heEJ5dGVzVG9Xcml0ZS8yOnN0ci5sZW5ndGg7Zm9yKHZhciBpPTA7aTxudW1DaGFyc1RvV3JpdGU7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7SEVBUDE2W291dFB0cj4+MV09Y29kZVVuaXQ7b3V0UHRyKz0yfUhFQVAxNltvdXRQdHI+PjFdPTA7cmV0dXJuIG91dFB0ci1zdGFydFB0cn07dmFyIGxlbmd0aEJ5dGVzVVRGMTY9c3RyPT5zdHIubGVuZ3RoKjI7dmFyIFVURjMyVG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgaT0wO3ZhciBzdHI9XCJcIjt3aGlsZSghKGk+PW1heEJ5dGVzVG9SZWFkLzQpKXt2YXIgdXRmMzI9SEVBUDMyW3B0citpKjQ+PjJdO2lmKHV0ZjMyPT0wKWJyZWFrOysraTtpZih1dGYzMj49NjU1MzYpe3ZhciBjaD11dGYzMi02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfWVsc2V7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKX19cmV0dXJuIHN0cn07dmFyIHN0cmluZ1RvVVRGMzI9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+e2lmKG1heEJ5dGVzVG9Xcml0ZT09PXVuZGVmaW5lZCl7bWF4Qnl0ZXNUb1dyaXRlPTIxNDc0ODM2NDd9aWYobWF4Qnl0ZXNUb1dyaXRlPDQpcmV0dXJuIDA7dmFyIHN0YXJ0UHRyPW91dFB0cjt2YXIgZW5kUHRyPXN0YXJ0UHRyK21heEJ5dGVzVG9Xcml0ZS00O2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjb2RlVW5pdD1zdHIuY2hhckNvZGVBdChpKTtpZihjb2RlVW5pdD49NTUyOTYmJmNvZGVVbml0PD01NzM0Myl7dmFyIHRyYWlsU3Vycm9nYXRlPXN0ci5jaGFyQ29kZUF0KCsraSk7Y29kZVVuaXQ9NjU1MzYrKChjb2RlVW5pdCYxMDIzKTw8MTApfHRyYWlsU3Vycm9nYXRlJjEwMjN9SEVBUDMyW291dFB0cj4+Ml09Y29kZVVuaXQ7b3V0UHRyKz00O2lmKG91dFB0cis0PmVuZFB0cilicmVha31IRUFQMzJbb3V0UHRyPj4yXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjMyPXN0cj0+e3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7aWYoY29kZVVuaXQ+PTU1Mjk2JiZjb2RlVW5pdDw9NTczNDMpKytpO2xlbis9NH1yZXR1cm4gbGVufTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmc9KHJhd1R5cGUsY2hhclNpemUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7dmFyIGRlY29kZVN0cmluZyxlbmNvZGVTdHJpbmcsZ2V0SGVhcCxsZW5ndGhCeXRlc1VURixzaGlmdDtpZihjaGFyU2l6ZT09PTIpe2RlY29kZVN0cmluZz1VVEYxNlRvU3RyaW5nO2VuY29kZVN0cmluZz1zdHJpbmdUb1VURjE2O2xlbmd0aEJ5dGVzVVRGPWxlbmd0aEJ5dGVzVVRGMTY7Z2V0SGVhcD0oKT0+SEVBUFUxNjtzaGlmdD0xfWVsc2UgaWYoY2hhclNpemU9PT00KXtkZWNvZGVTdHJpbmc9VVRGMzJUb1N0cmluZztlbmNvZGVTdHJpbmc9c3RyaW5nVG9VVEYzMjtsZW5ndGhCeXRlc1VURj1sZW5ndGhCeXRlc1VURjMyO2dldEhlYXA9KCk9PkhFQVBVMzI7c2hpZnQ9Mn1yZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6dmFsdWU9Pnt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBIRUFQPWdldEhlYXAoKTt2YXIgc3RyO3ZhciBkZWNvZGVTdGFydFB0cj12YWx1ZSs0O2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj12YWx1ZSs0K2kqY2hhclNpemU7aWYoaT09bGVuZ3RofHxIRUFQW2N1cnJlbnRCeXRlUHRyPj5zaGlmdF09PTApe3ZhciBtYXhSZWFkQnl0ZXM9Y3VycmVudEJ5dGVQdHItZGVjb2RlU3RhcnRQdHI7dmFyIHN0cmluZ1NlZ21lbnQ9ZGVjb2RlU3RyaW5nKGRlY29kZVN0YXJ0UHRyLG1heFJlYWRCeXRlcyk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudH1lbHNle3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnR9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrY2hhclNpemV9fV9mcmVlKHZhbHVlKTtyZXR1cm4gc3RyfSxcInRvV2lyZVR5cGVcIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT57aWYoISh0eXBlb2YgdmFsdWU9PVwic3RyaW5nXCIpKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtuYW1lfWApfXZhciBsZW5ndGg9bGVuZ3RoQnl0ZXNVVEYodmFsdWUpO3ZhciBwdHI9X21hbGxvYyg0K2xlbmd0aCtjaGFyU2l6ZSk7SEVBUFUzMltwdHI+PjJdPWxlbmd0aD4+c2hpZnQ7ZW5jb2RlU3RyaW5nKHZhbHVlLHB0cis0LGxlbmd0aCtjaGFyU2l6ZSk7aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLHB0cil9cmV0dXJuIHB0cn0sXCJhcmdQYWNrQWR2YW5jZVwiOkdlbmVyaWNXaXJlVHlwZVNpemUsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbihwdHIpe19mcmVlKHB0cil9fSl9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9hcnJheT0ocmF3VHlwZSxuYW1lLGNvbnN0cnVjdG9yU2lnbmF0dXJlLHJhd0NvbnN0cnVjdG9yLGRlc3RydWN0b3JTaWduYXR1cmUscmF3RGVzdHJ1Y3Rvcik9Pnt0dXBsZVJlZ2lzdHJhdGlvbnNbcmF3VHlwZV09e25hbWU6cmVhZExhdGluMVN0cmluZyhuYW1lKSxyYXdDb25zdHJ1Y3RvcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihjb25zdHJ1Y3RvclNpZ25hdHVyZSxyYXdDb25zdHJ1Y3RvcikscmF3RGVzdHJ1Y3RvcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkZXN0cnVjdG9yU2lnbmF0dXJlLHJhd0Rlc3RydWN0b3IpLGVsZW1lbnRzOltdfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX2FycmF5X2VsZW1lbnQ9KHJhd1R1cGxlVHlwZSxnZXR0ZXJSZXR1cm5UeXBlLGdldHRlclNpZ25hdHVyZSxnZXR0ZXIsZ2V0dGVyQ29udGV4dCxzZXR0ZXJBcmd1bWVudFR5cGUsc2V0dGVyU2lnbmF0dXJlLHNldHRlcixzZXR0ZXJDb250ZXh0KT0+e3R1cGxlUmVnaXN0cmF0aW9uc1tyYXdUdXBsZVR5cGVdLmVsZW1lbnRzLnB1c2goe2dldHRlclJldHVyblR5cGU6Z2V0dGVyUmV0dXJuVHlwZSxnZXR0ZXI6ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0dGVyU2lnbmF0dXJlLGdldHRlciksZ2V0dGVyQ29udGV4dDpnZXR0ZXJDb250ZXh0LHNldHRlckFyZ3VtZW50VHlwZTpzZXR0ZXJBcmd1bWVudFR5cGUsc2V0dGVyOmVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNldHRlclNpZ25hdHVyZSxzZXR0ZXIpLHNldHRlckNvbnRleHQ6c2V0dGVyQ29udGV4dH0pfTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0PShyYXdUeXBlLG5hbWUsY29uc3RydWN0b3JTaWduYXR1cmUscmF3Q29uc3RydWN0b3IsZGVzdHJ1Y3RvclNpZ25hdHVyZSxyYXdEZXN0cnVjdG9yKT0+e3N0cnVjdFJlZ2lzdHJhdGlvbnNbcmF3VHlwZV09e25hbWU6cmVhZExhdGluMVN0cmluZyhuYW1lKSxyYXdDb25zdHJ1Y3RvcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihjb25zdHJ1Y3RvclNpZ25hdHVyZSxyYXdDb25zdHJ1Y3RvcikscmF3RGVzdHJ1Y3RvcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkZXN0cnVjdG9yU2lnbmF0dXJlLHJhd0Rlc3RydWN0b3IpLGZpZWxkczpbXX19O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9vYmplY3RfZmllbGQ9KHN0cnVjdFR5cGUsZmllbGROYW1lLGdldHRlclJldHVyblR5cGUsZ2V0dGVyU2lnbmF0dXJlLGdldHRlcixnZXR0ZXJDb250ZXh0LHNldHRlckFyZ3VtZW50VHlwZSxzZXR0ZXJTaWduYXR1cmUsc2V0dGVyLHNldHRlckNvbnRleHQpPT57c3RydWN0UmVnaXN0cmF0aW9uc1tzdHJ1Y3RUeXBlXS5maWVsZHMucHVzaCh7ZmllbGROYW1lOnJlYWRMYXRpbjFTdHJpbmcoZmllbGROYW1lKSxnZXR0ZXJSZXR1cm5UeXBlOmdldHRlclJldHVyblR5cGUsZ2V0dGVyOmVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKGdldHRlclNpZ25hdHVyZSxnZXR0ZXIpLGdldHRlckNvbnRleHQ6Z2V0dGVyQ29udGV4dCxzZXR0ZXJBcmd1bWVudFR5cGU6c2V0dGVyQXJndW1lbnRUeXBlLHNldHRlcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihzZXR0ZXJTaWduYXR1cmUsc2V0dGVyKSxzZXR0ZXJDb250ZXh0OnNldHRlckNvbnRleHR9KX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQ9KHJhd1R5cGUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse2lzVm9pZDp0cnVlLG5hbWU6bmFtZSxcImFyZ1BhY2tBZHZhbmNlXCI6MCxcImZyb21XaXJlVHlwZVwiOigpPT51bmRlZmluZWQsXCJ0b1dpcmVUeXBlXCI6KGRlc3RydWN0b3JzLG8pPT51bmRlZmluZWR9KX07dmFyIF9fZW12YWxfaW5jcmVmPWhhbmRsZT0+e2lmKGhhbmRsZT40KXtlbXZhbF9oYW5kbGVzLmdldChoYW5kbGUpLnJlZmNvdW50Kz0xfX07dmFyIF9fZW12YWxfdGFrZV92YWx1ZT0odHlwZSxhcmcpPT57dHlwZT1yZXF1aXJlUmVnaXN0ZXJlZFR5cGUodHlwZSxcIl9lbXZhbF90YWtlX3ZhbHVlXCIpO3ZhciB2PXR5cGVbXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiXShhcmcpO3JldHVybiBFbXZhbC50b0hhbmRsZSh2KX07dmFyIF9hYm9ydD0oKT0+e2Fib3J0KFwiXCIpfTt2YXIgX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzPShkZXN0LHNyYyxudW0pPT5IRUFQVTguY29weVdpdGhpbihkZXN0LHNyYyxzcmMrbnVtKTt2YXIgZ2V0SGVhcE1heD0oKT0+MjE0NzQ4MzY0ODt2YXIgZ3Jvd01lbW9yeT1zaXplPT57dmFyIGI9d2FzbU1lbW9yeS5idWZmZXI7dmFyIHBhZ2VzPShzaXplLWIuYnl0ZUxlbmd0aCs2NTUzNSkvNjU1MzY7dHJ5e3dhc21NZW1vcnkuZ3JvdyhwYWdlcyk7dXBkYXRlTWVtb3J5Vmlld3MoKTtyZXR1cm4gMX1jYXRjaChlKXt9fTt2YXIgX2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXA9cmVxdWVzdGVkU2l6ZT0+e3ZhciBvbGRTaXplPUhFQVBVOC5sZW5ndGg7cmVxdWVzdGVkU2l6ZT4+Pj0wO3ZhciBtYXhIZWFwU2l6ZT1nZXRIZWFwTWF4KCk7aWYocmVxdWVzdGVkU2l6ZT5tYXhIZWFwU2l6ZSl7cmV0dXJuIGZhbHNlfXZhciBhbGlnblVwPSh4LG11bHRpcGxlKT0+eCsobXVsdGlwbGUteCVtdWx0aXBsZSklbXVsdGlwbGU7Zm9yKHZhciBjdXREb3duPTE7Y3V0RG93bjw9NDtjdXREb3duKj0yKXt2YXIgb3Zlckdyb3duSGVhcFNpemU9b2xkU2l6ZSooMSsuMi9jdXREb3duKTtvdmVyR3Jvd25IZWFwU2l6ZT1NYXRoLm1pbihvdmVyR3Jvd25IZWFwU2l6ZSxyZXF1ZXN0ZWRTaXplKzEwMDY2MzI5Nik7dmFyIG5ld1NpemU9TWF0aC5taW4obWF4SGVhcFNpemUsYWxpZ25VcChNYXRoLm1heChyZXF1ZXN0ZWRTaXplLG92ZXJHcm93bkhlYXBTaXplKSw2NTUzNikpO3ZhciByZXBsYWNlbWVudD1ncm93TWVtb3J5KG5ld1NpemUpO2lmKHJlcGxhY2VtZW50KXtyZXR1cm4gdHJ1ZX19cmV0dXJuIGZhbHNlfTt2YXIgRU5WPXt9O3ZhciBnZXRFeGVjdXRhYmxlTmFtZT0oKT0+dGhpc1Byb2dyYW18fFwiLi90aGlzLnByb2dyYW1cIjt2YXIgZ2V0RW52U3RyaW5ncz0oKT0+e2lmKCFnZXRFbnZTdHJpbmdzLnN0cmluZ3Mpe3ZhciBsYW5nPSh0eXBlb2YgbmF2aWdhdG9yPT1cIm9iamVjdFwiJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzJiZuYXZpZ2F0b3IubGFuZ3VhZ2VzWzBdfHxcIkNcIikucmVwbGFjZShcIi1cIixcIl9cIikrXCIuVVRGLThcIjt2YXIgZW52PXtcIlVTRVJcIjpcIndlYl91c2VyXCIsXCJMT0dOQU1FXCI6XCJ3ZWJfdXNlclwiLFwiUEFUSFwiOlwiL1wiLFwiUFdEXCI6XCIvXCIsXCJIT01FXCI6XCIvaG9tZS93ZWJfdXNlclwiLFwiTEFOR1wiOmxhbmcsXCJfXCI6Z2V0RXhlY3V0YWJsZU5hbWUoKX07Zm9yKHZhciB4IGluIEVOVil7aWYoRU5WW3hdPT09dW5kZWZpbmVkKWRlbGV0ZSBlbnZbeF07ZWxzZSBlbnZbeF09RU5WW3hdfXZhciBzdHJpbmdzPVtdO2Zvcih2YXIgeCBpbiBlbnYpe3N0cmluZ3MucHVzaChgJHt4fT0ke2Vudlt4XX1gKX1nZXRFbnZTdHJpbmdzLnN0cmluZ3M9c3RyaW5nc31yZXR1cm4gZ2V0RW52U3RyaW5ncy5zdHJpbmdzfTt2YXIgc3RyaW5nVG9Bc2NpaT0oc3RyLGJ1ZmZlcik9Pntmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXtIRUFQOFtidWZmZXIrKz4+MF09c3RyLmNoYXJDb2RlQXQoaSl9SEVBUDhbYnVmZmVyPj4wXT0wfTt2YXIgUEFUSD17aXNBYnM6cGF0aD0+cGF0aC5jaGFyQXQoMCk9PT1cIi9cIixzcGxpdFBhdGg6ZmlsZW5hbWU9Pnt2YXIgc3BsaXRQYXRoUmU9L14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87cmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpfSxub3JtYWxpemVBcnJheToocGFydHMsYWxsb3dBYm92ZVJvb3QpPT57dmFyIHVwPTA7Zm9yKHZhciBpPXBhcnRzLmxlbmd0aC0xO2k+PTA7aS0tKXt2YXIgbGFzdD1wYXJ0c1tpXTtpZihsYXN0PT09XCIuXCIpe3BhcnRzLnNwbGljZShpLDEpfWVsc2UgaWYobGFzdD09PVwiLi5cIil7cGFydHMuc3BsaWNlKGksMSk7dXArK31lbHNlIGlmKHVwKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cC0tfX1pZihhbGxvd0Fib3ZlUm9vdCl7Zm9yKDt1cDt1cC0tKXtwYXJ0cy51bnNoaWZ0KFwiLi5cIil9fXJldHVybiBwYXJ0c30sbm9ybWFsaXplOnBhdGg9Pnt2YXIgaXNBYnNvbHV0ZT1QQVRILmlzQWJzKHBhdGgpLHRyYWlsaW5nU2xhc2g9cGF0aC5zdWJzdHIoLTEpPT09XCIvXCI7cGF0aD1QQVRILm5vcm1hbGl6ZUFycmF5KHBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihwPT4hIXApLCFpc0Fic29sdXRlKS5qb2luKFwiL1wiKTtpZighcGF0aCYmIWlzQWJzb2x1dGUpe3BhdGg9XCIuXCJ9aWYocGF0aCYmdHJhaWxpbmdTbGFzaCl7cGF0aCs9XCIvXCJ9cmV0dXJuKGlzQWJzb2x1dGU/XCIvXCI6XCJcIikrcGF0aH0sZGlybmFtZTpwYXRoPT57dmFyIHJlc3VsdD1QQVRILnNwbGl0UGF0aChwYXRoKSxyb290PXJlc3VsdFswXSxkaXI9cmVzdWx0WzFdO2lmKCFyb290JiYhZGlyKXtyZXR1cm5cIi5cIn1pZihkaXIpe2Rpcj1kaXIuc3Vic3RyKDAsZGlyLmxlbmd0aC0xKX1yZXR1cm4gcm9vdCtkaXJ9LGJhc2VuYW1lOnBhdGg9PntpZihwYXRoPT09XCIvXCIpcmV0dXJuXCIvXCI7cGF0aD1QQVRILm5vcm1hbGl6ZShwYXRoKTtwYXRoPXBhdGgucmVwbGFjZSgvXFwvJC8sXCJcIik7dmFyIGxhc3RTbGFzaD1wYXRoLmxhc3RJbmRleE9mKFwiL1wiKTtpZihsYXN0U2xhc2g9PT0tMSlyZXR1cm4gcGF0aDtyZXR1cm4gcGF0aC5zdWJzdHIobGFzdFNsYXNoKzEpfSxqb2luOmZ1bmN0aW9uKCl7dmFyIHBhdGhzPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7cmV0dXJuIFBBVEgubm9ybWFsaXplKHBhdGhzLmpvaW4oXCIvXCIpKX0sam9pbjI6KGwscik9PlBBVEgubm9ybWFsaXplKGwrXCIvXCIrcil9O3ZhciBpbml0UmFuZG9tRmlsbD0oKT0+e2lmKHR5cGVvZiBjcnlwdG89PVwib2JqZWN0XCImJnR5cGVvZiBjcnlwdG9bXCJnZXRSYW5kb21WYWx1ZXNcIl09PVwiZnVuY3Rpb25cIil7cmV0dXJuIHZpZXc9PmNyeXB0by5nZXRSYW5kb21WYWx1ZXModmlldyl9ZWxzZSBhYm9ydChcImluaXRSYW5kb21EZXZpY2VcIil9O3ZhciByYW5kb21GaWxsPXZpZXc9PihyYW5kb21GaWxsPWluaXRSYW5kb21GaWxsKCkpKHZpZXcpO3ZhciBQQVRIX0ZTPXtyZXNvbHZlOmZ1bmN0aW9uKCl7dmFyIHJlc29sdmVkUGF0aD1cIlwiLHJlc29sdmVkQWJzb2x1dGU9ZmFsc2U7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgtMTtpPj0tMSYmIXJlc29sdmVkQWJzb2x1dGU7aS0tKXt2YXIgcGF0aD1pPj0wP2FyZ3VtZW50c1tpXTpGUy5jd2QoKTtpZih0eXBlb2YgcGF0aCE9XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50cyB0byBwYXRoLnJlc29sdmUgbXVzdCBiZSBzdHJpbmdzXCIpfWVsc2UgaWYoIXBhdGgpe3JldHVyblwiXCJ9cmVzb2x2ZWRQYXRoPXBhdGgrXCIvXCIrcmVzb2x2ZWRQYXRoO3Jlc29sdmVkQWJzb2x1dGU9UEFUSC5pc0FicyhwYXRoKX1yZXNvbHZlZFBhdGg9UEFUSC5ub3JtYWxpemVBcnJheShyZXNvbHZlZFBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihwPT4hIXApLCFyZXNvbHZlZEFic29sdXRlKS5qb2luKFwiL1wiKTtyZXR1cm4ocmVzb2x2ZWRBYnNvbHV0ZT9cIi9cIjpcIlwiKStyZXNvbHZlZFBhdGh8fFwiLlwifSxyZWxhdGl2ZTooZnJvbSx0byk9Pntmcm9tPVBBVEhfRlMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7dG89UEFUSF9GUy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7ZnVuY3Rpb24gdHJpbShhcnIpe3ZhciBzdGFydD0wO2Zvcig7c3RhcnQ8YXJyLmxlbmd0aDtzdGFydCsrKXtpZihhcnJbc3RhcnRdIT09XCJcIilicmVha312YXIgZW5kPWFyci5sZW5ndGgtMTtmb3IoO2VuZD49MDtlbmQtLSl7aWYoYXJyW2VuZF0hPT1cIlwiKWJyZWFrfWlmKHN0YXJ0PmVuZClyZXR1cm5bXTtyZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LGVuZC1zdGFydCsxKX12YXIgZnJvbVBhcnRzPXRyaW0oZnJvbS5zcGxpdChcIi9cIikpO3ZhciB0b1BhcnRzPXRyaW0odG8uc3BsaXQoXCIvXCIpKTt2YXIgbGVuZ3RoPU1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsdG9QYXJ0cy5sZW5ndGgpO3ZhciBzYW1lUGFydHNMZW5ndGg9bGVuZ3RoO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7aWYoZnJvbVBhcnRzW2ldIT09dG9QYXJ0c1tpXSl7c2FtZVBhcnRzTGVuZ3RoPWk7YnJlYWt9fXZhciBvdXRwdXRQYXJ0cz1bXTtmb3IodmFyIGk9c2FtZVBhcnRzTGVuZ3RoO2k8ZnJvbVBhcnRzLmxlbmd0aDtpKyspe291dHB1dFBhcnRzLnB1c2goXCIuLlwiKX1vdXRwdXRQYXJ0cz1vdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtyZXR1cm4gb3V0cHV0UGFydHMuam9pbihcIi9cIil9fTt2YXIgRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXI9W107ZnVuY3Rpb24gaW50QXJyYXlGcm9tU3RyaW5nKHN0cmluZ3ksZG9udEFkZE51bGwsbGVuZ3RoKXt2YXIgbGVuPWxlbmd0aD4wP2xlbmd0aDpsZW5ndGhCeXRlc1VURjgoc3RyaW5neSkrMTt2YXIgdThhcnJheT1uZXcgQXJyYXkobGVuKTt2YXIgbnVtQnl0ZXNXcml0dGVuPXN0cmluZ1RvVVRGOEFycmF5KHN0cmluZ3ksdThhcnJheSwwLHU4YXJyYXkubGVuZ3RoKTtpZihkb250QWRkTnVsbCl1OGFycmF5Lmxlbmd0aD1udW1CeXRlc1dyaXR0ZW47cmV0dXJuIHU4YXJyYXl9dmFyIEZTX3N0ZGluX2dldENoYXI9KCk9PntpZighRlNfc3RkaW5fZ2V0Q2hhcl9idWZmZXIubGVuZ3RoKXt2YXIgcmVzdWx0PW51bGw7aWYodHlwZW9mIHdpbmRvdyE9XCJ1bmRlZmluZWRcIiYmdHlwZW9mIHdpbmRvdy5wcm9tcHQ9PVwiZnVuY3Rpb25cIil7cmVzdWx0PXdpbmRvdy5wcm9tcHQoXCJJbnB1dDogXCIpO2lmKHJlc3VsdCE9PW51bGwpe3Jlc3VsdCs9XCJcXG5cIn19ZWxzZSBpZih0eXBlb2YgcmVhZGxpbmU9PVwiZnVuY3Rpb25cIil7cmVzdWx0PXJlYWRsaW5lKCk7aWYocmVzdWx0IT09bnVsbCl7cmVzdWx0Kz1cIlxcblwifX1pZighcmVzdWx0KXtyZXR1cm4gbnVsbH1GU19zdGRpbl9nZXRDaGFyX2J1ZmZlcj1pbnRBcnJheUZyb21TdHJpbmcocmVzdWx0LHRydWUpfXJldHVybiBGU19zdGRpbl9nZXRDaGFyX2J1ZmZlci5zaGlmdCgpfTt2YXIgVFRZPXt0dHlzOltdLGluaXQoKXt9LHNodXRkb3duKCl7fSxyZWdpc3RlcihkZXYsb3BzKXtUVFkudHR5c1tkZXZdPXtpbnB1dDpbXSxvdXRwdXQ6W10sb3BzOm9wc307RlMucmVnaXN0ZXJEZXZpY2UoZGV2LFRUWS5zdHJlYW1fb3BzKX0sc3RyZWFtX29wczp7b3BlbihzdHJlYW0pe3ZhciB0dHk9VFRZLnR0eXNbc3RyZWFtLm5vZGUucmRldl07aWYoIXR0eSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpfXN0cmVhbS50dHk9dHR5O3N0cmVhbS5zZWVrYWJsZT1mYWxzZX0sY2xvc2Uoc3RyZWFtKXtzdHJlYW0udHR5Lm9wcy5mc3luYyhzdHJlYW0udHR5KX0sZnN5bmMoc3RyZWFtKXtzdHJlYW0udHR5Lm9wcy5mc3luYyhzdHJlYW0udHR5KX0scmVhZChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zKXtpZighc3RyZWFtLnR0eXx8IXN0cmVhbS50dHkub3BzLmdldF9jaGFyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2MCl9dmFyIGJ5dGVzUmVhZD0wO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7dmFyIHJlc3VsdDt0cnl7cmVzdWx0PXN0cmVhbS50dHkub3BzLmdldF9jaGFyKHN0cmVhbS50dHkpfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KX1pZihyZXN1bHQ9PT11bmRlZmluZWQmJmJ5dGVzUmVhZD09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpfWlmKHJlc3VsdD09PW51bGx8fHJlc3VsdD09PXVuZGVmaW5lZClicmVhaztieXRlc1JlYWQrKztidWZmZXJbb2Zmc2V0K2ldPXJlc3VsdH1pZihieXRlc1JlYWQpe3N0cmVhbS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpfXJldHVybiBieXRlc1JlYWR9LHdyaXRlKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe2lmKCFzdHJlYW0udHR5fHwhc3RyZWFtLnR0eS5vcHMucHV0X2NoYXIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKX10cnl7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXtzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcihzdHJlYW0udHR5LGJ1ZmZlcltvZmZzZXQraV0pfX1jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSl9aWYobGVuZ3RoKXtzdHJlYW0ubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKX1yZXR1cm4gaX19LGRlZmF1bHRfdHR5X29wczp7Z2V0X2NoYXIodHR5KXtyZXR1cm4gRlNfc3RkaW5fZ2V0Q2hhcigpfSxwdXRfY2hhcih0dHksdmFsKXtpZih2YWw9PT1udWxsfHx2YWw9PT0xMCl7b3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119ZWxzZXtpZih2YWwhPTApdHR5Lm91dHB1dC5wdXNoKHZhbCl9fSxmc3luYyh0dHkpe2lmKHR0eS5vdXRwdXQmJnR0eS5vdXRwdXQubGVuZ3RoPjApe291dChVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LDApKTt0dHkub3V0cHV0PVtdfX0saW9jdGxfdGNnZXRzKHR0eSl7cmV0dXJue2NfaWZsYWc6MjU4NTYsY19vZmxhZzo1LGNfY2ZsYWc6MTkxLGNfbGZsYWc6MzUzODcsY19jYzpbMywyOCwxMjcsMjEsNCwwLDEsMCwxNywxOSwyNiwwLDE4LDE1LDIzLDIyLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDBdfX0saW9jdGxfdGNzZXRzKHR0eSxvcHRpb25hbF9hY3Rpb25zLGRhdGEpe3JldHVybiAwfSxpb2N0bF90aW9jZ3dpbnN6KHR0eSl7cmV0dXJuWzI0LDgwXX19LGRlZmF1bHRfdHR5MV9vcHM6e3B1dF9jaGFyKHR0eSx2YWwpe2lmKHZhbD09PW51bGx8fHZhbD09PTEwKXtlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwwKSk7dHR5Lm91dHB1dD1bXX1lbHNle2lmKHZhbCE9MCl0dHkub3V0cHV0LnB1c2godmFsKX19LGZzeW5jKHR0eSl7aWYodHR5Lm91dHB1dCYmdHR5Lm91dHB1dC5sZW5ndGg+MCl7ZXJyKFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119fX19O3ZhciBtbWFwQWxsb2M9c2l6ZT0+e2Fib3J0KCl9O3ZhciBNRU1GUz17b3BzX3RhYmxlOm51bGwsbW91bnQobW91bnQpe3JldHVybiBNRU1GUy5jcmVhdGVOb2RlKG51bGwsXCIvXCIsMTYzODR8NTExLDApfSxjcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUsZGV2KXtpZihGUy5pc0Jsa2Rldihtb2RlKXx8RlMuaXNGSUZPKG1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myl9aWYoIU1FTUZTLm9wc190YWJsZSl7TUVNRlMub3BzX3RhYmxlPXtkaXI6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHIsbG9va3VwOk1FTUZTLm5vZGVfb3BzLmxvb2t1cCxta25vZDpNRU1GUy5ub2RlX29wcy5ta25vZCxyZW5hbWU6TUVNRlMubm9kZV9vcHMucmVuYW1lLHVubGluazpNRU1GUy5ub2RlX29wcy51bmxpbmsscm1kaXI6TUVNRlMubm9kZV9vcHMucm1kaXIscmVhZGRpcjpNRU1GUy5ub2RlX29wcy5yZWFkZGlyLHN5bWxpbms6TUVNRlMubm9kZV9vcHMuc3ltbGlua30sc3RyZWFtOntsbHNlZWs6TUVNRlMuc3RyZWFtX29wcy5sbHNlZWt9fSxmaWxlOntub2RlOntnZXRhdHRyOk1FTUZTLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpNRU1GUy5ub2RlX29wcy5zZXRhdHRyfSxzdHJlYW06e2xsc2VlazpNRU1GUy5zdHJlYW1fb3BzLmxsc2VlayxyZWFkOk1FTUZTLnN0cmVhbV9vcHMucmVhZCx3cml0ZTpNRU1GUy5zdHJlYW1fb3BzLndyaXRlLGFsbG9jYXRlOk1FTUZTLnN0cmVhbV9vcHMuYWxsb2NhdGUsbW1hcDpNRU1GUy5zdHJlYW1fb3BzLm1tYXAsbXN5bmM6TUVNRlMuc3RyZWFtX29wcy5tc3luY319LGxpbms6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHIscmVhZGxpbms6TUVNRlMubm9kZV9vcHMucmVhZGxpbmt9LHN0cmVhbTp7fX0sY2hyZGV2Ontub2RlOntnZXRhdHRyOk1FTUZTLm5vZGVfb3BzLmdldGF0dHIsc2V0YXR0cjpNRU1GUy5ub2RlX29wcy5zZXRhdHRyfSxzdHJlYW06RlMuY2hyZGV2X3N0cmVhbV9vcHN9fX12YXIgbm9kZT1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUsZGV2KTtpZihGUy5pc0Rpcihub2RlLm1vZGUpKXtub2RlLm5vZGVfb3BzPU1FTUZTLm9wc190YWJsZS5kaXIubm9kZTtub2RlLnN0cmVhbV9vcHM9TUVNRlMub3BzX3RhYmxlLmRpci5zdHJlYW07bm9kZS5jb250ZW50cz17fX1lbHNlIGlmKEZTLmlzRmlsZShub2RlLm1vZGUpKXtub2RlLm5vZGVfb3BzPU1FTUZTLm9wc190YWJsZS5maWxlLm5vZGU7bm9kZS5zdHJlYW1fb3BzPU1FTUZTLm9wc190YWJsZS5maWxlLnN0cmVhbTtub2RlLnVzZWRCeXRlcz0wO25vZGUuY29udGVudHM9bnVsbH1lbHNlIGlmKEZTLmlzTGluayhub2RlLm1vZGUpKXtub2RlLm5vZGVfb3BzPU1FTUZTLm9wc190YWJsZS5saW5rLm5vZGU7bm9kZS5zdHJlYW1fb3BzPU1FTUZTLm9wc190YWJsZS5saW5rLnN0cmVhbX1lbHNlIGlmKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpe25vZGUubm9kZV9vcHM9TUVNRlMub3BzX3RhYmxlLmNocmRldi5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUuY2hyZGV2LnN0cmVhbX1ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpO2lmKHBhcmVudCl7cGFyZW50LmNvbnRlbnRzW25hbWVdPW5vZGU7cGFyZW50LnRpbWVzdGFtcD1ub2RlLnRpbWVzdGFtcH1yZXR1cm4gbm9kZX0sZ2V0RmlsZURhdGFBc1R5cGVkQXJyYXkobm9kZSl7aWYoIW5vZGUuY29udGVudHMpcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO2lmKG5vZGUuY29udGVudHMuc3ViYXJyYXkpcmV0dXJuIG5vZGUuY29udGVudHMuc3ViYXJyYXkoMCxub2RlLnVzZWRCeXRlcyk7cmV0dXJuIG5ldyBVaW50OEFycmF5KG5vZGUuY29udGVudHMpfSxleHBhbmRGaWxlU3RvcmFnZShub2RlLG5ld0NhcGFjaXR5KXt2YXIgcHJldkNhcGFjaXR5PW5vZGUuY29udGVudHM/bm9kZS5jb250ZW50cy5sZW5ndGg6MDtpZihwcmV2Q2FwYWNpdHk+PW5ld0NhcGFjaXR5KXJldHVybjt2YXIgQ0FQQUNJVFlfRE9VQkxJTkdfTUFYPTEwMjQqMTAyNDtuZXdDYXBhY2l0eT1NYXRoLm1heChuZXdDYXBhY2l0eSxwcmV2Q2FwYWNpdHkqKHByZXZDYXBhY2l0eTxDQVBBQ0lUWV9ET1VCTElOR19NQVg/MjoxLjEyNSk+Pj4wKTtpZihwcmV2Q2FwYWNpdHkhPTApbmV3Q2FwYWNpdHk9TWF0aC5tYXgobmV3Q2FwYWNpdHksMjU2KTt2YXIgb2xkQ29udGVudHM9bm9kZS5jb250ZW50cztub2RlLmNvbnRlbnRzPW5ldyBVaW50OEFycmF5KG5ld0NhcGFjaXR5KTtpZihub2RlLnVzZWRCeXRlcz4wKW5vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsbm9kZS51c2VkQnl0ZXMpLDApfSxyZXNpemVGaWxlU3RvcmFnZShub2RlLG5ld1NpemUpe2lmKG5vZGUudXNlZEJ5dGVzPT1uZXdTaXplKXJldHVybjtpZihuZXdTaXplPT0wKXtub2RlLmNvbnRlbnRzPW51bGw7bm9kZS51c2VkQnl0ZXM9MH1lbHNle3ZhciBvbGRDb250ZW50cz1ub2RlLmNvbnRlbnRzO25vZGUuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkobmV3U2l6ZSk7aWYob2xkQ29udGVudHMpe25vZGUuY29udGVudHMuc2V0KG9sZENvbnRlbnRzLnN1YmFycmF5KDAsTWF0aC5taW4obmV3U2l6ZSxub2RlLnVzZWRCeXRlcykpKX1ub2RlLnVzZWRCeXRlcz1uZXdTaXplfX0sbm9kZV9vcHM6e2dldGF0dHIobm9kZSl7dmFyIGF0dHI9e307YXR0ci5kZXY9RlMuaXNDaHJkZXYobm9kZS5tb2RlKT9ub2RlLmlkOjE7YXR0ci5pbm89bm9kZS5pZDthdHRyLm1vZGU9bm9kZS5tb2RlO2F0dHIubmxpbms9MTthdHRyLnVpZD0wO2F0dHIuZ2lkPTA7YXR0ci5yZGV2PW5vZGUucmRldjtpZihGUy5pc0Rpcihub2RlLm1vZGUpKXthdHRyLnNpemU9NDA5Nn1lbHNlIGlmKEZTLmlzRmlsZShub2RlLm1vZGUpKXthdHRyLnNpemU9bm9kZS51c2VkQnl0ZXN9ZWxzZSBpZihGUy5pc0xpbmsobm9kZS5tb2RlKSl7YXR0ci5zaXplPW5vZGUubGluay5sZW5ndGh9ZWxzZXthdHRyLnNpemU9MH1hdHRyLmF0aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLm10aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLmN0aW1lPW5ldyBEYXRlKG5vZGUudGltZXN0YW1wKTthdHRyLmJsa3NpemU9NDA5NjthdHRyLmJsb2Nrcz1NYXRoLmNlaWwoYXR0ci5zaXplL2F0dHIuYmxrc2l6ZSk7cmV0dXJuIGF0dHJ9LHNldGF0dHIobm9kZSxhdHRyKXtpZihhdHRyLm1vZGUhPT11bmRlZmluZWQpe25vZGUubW9kZT1hdHRyLm1vZGV9aWYoYXR0ci50aW1lc3RhbXAhPT11bmRlZmluZWQpe25vZGUudGltZXN0YW1wPWF0dHIudGltZXN0YW1wfWlmKGF0dHIuc2l6ZSE9PXVuZGVmaW5lZCl7TUVNRlMucmVzaXplRmlsZVN0b3JhZ2Uobm9kZSxhdHRyLnNpemUpfX0sbG9va3VwKHBhcmVudCxuYW1lKXt0aHJvdyBGUy5nZW5lcmljRXJyb3JzWzQ0XX0sbWtub2QocGFyZW50LG5hbWUsbW9kZSxkZXYpe3JldHVybiBNRU1GUy5jcmVhdGVOb2RlKHBhcmVudCxuYW1lLG1vZGUsZGV2KX0scmVuYW1lKG9sZF9ub2RlLG5ld19kaXIsbmV3X25hbWUpe2lmKEZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpKXt2YXIgbmV3X25vZGU7dHJ5e25ld19ub2RlPUZTLmxvb2t1cE5vZGUobmV3X2RpcixuZXdfbmFtZSl9Y2F0Y2goZSl7fWlmKG5ld19ub2RlKXtmb3IodmFyIGkgaW4gbmV3X25vZGUuY29udGVudHMpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KX19fWRlbGV0ZSBvbGRfbm9kZS5wYXJlbnQuY29udGVudHNbb2xkX25vZGUubmFtZV07b2xkX25vZGUucGFyZW50LnRpbWVzdGFtcD1EYXRlLm5vdygpO29sZF9ub2RlLm5hbWU9bmV3X25hbWU7bmV3X2Rpci5jb250ZW50c1tuZXdfbmFtZV09b2xkX25vZGU7bmV3X2Rpci50aW1lc3RhbXA9b2xkX25vZGUucGFyZW50LnRpbWVzdGFtcDtvbGRfbm9kZS5wYXJlbnQ9bmV3X2Rpcn0sdW5saW5rKHBhcmVudCxuYW1lKXtkZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO3BhcmVudC50aW1lc3RhbXA9RGF0ZS5ub3coKX0scm1kaXIocGFyZW50LG5hbWUpe3ZhciBub2RlPUZTLmxvb2t1cE5vZGUocGFyZW50LG5hbWUpO2Zvcih2YXIgaSBpbiBub2RlLmNvbnRlbnRzKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSl9ZGVsZXRlIHBhcmVudC5jb250ZW50c1tuYW1lXTtwYXJlbnQudGltZXN0YW1wPURhdGUubm93KCl9LHJlYWRkaXIobm9kZSl7dmFyIGVudHJpZXM9W1wiLlwiLFwiLi5cIl07Zm9yKHZhciBrZXkgaW4gbm9kZS5jb250ZW50cyl7aWYoIW5vZGUuY29udGVudHMuaGFzT3duUHJvcGVydHkoa2V5KSl7Y29udGludWV9ZW50cmllcy5wdXNoKGtleSl9cmV0dXJuIGVudHJpZXN9LHN5bWxpbmsocGFyZW50LG5ld25hbWUsb2xkcGF0aCl7dmFyIG5vZGU9TUVNRlMuY3JlYXRlTm9kZShwYXJlbnQsbmV3bmFtZSw1MTF8NDA5NjAsMCk7bm9kZS5saW5rPW9sZHBhdGg7cmV0dXJuIG5vZGV9LHJlYWRsaW5rKG5vZGUpe2lmKCFGUy5pc0xpbmsobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfXJldHVybiBub2RlLmxpbmt9fSxzdHJlYW1fb3BzOntyZWFkKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbil7dmFyIGNvbnRlbnRzPXN0cmVhbS5ub2RlLmNvbnRlbnRzO2lmKHBvc2l0aW9uPj1zdHJlYW0ubm9kZS51c2VkQnl0ZXMpcmV0dXJuIDA7dmFyIHNpemU9TWF0aC5taW4oc3RyZWFtLm5vZGUudXNlZEJ5dGVzLXBvc2l0aW9uLGxlbmd0aCk7aWYoc2l6ZT44JiZjb250ZW50cy5zdWJhcnJheSl7YnVmZmVyLnNldChjb250ZW50cy5zdWJhcnJheShwb3NpdGlvbixwb3NpdGlvbitzaXplKSxvZmZzZXQpfWVsc2V7Zm9yKHZhciBpPTA7aTxzaXplO2krKylidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzW3Bvc2l0aW9uK2ldfXJldHVybiBzaXplfSx3cml0ZShzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24sY2FuT3duKXtpZihidWZmZXIuYnVmZmVyPT09SEVBUDguYnVmZmVyKXtjYW5Pd249ZmFsc2V9aWYoIWxlbmd0aClyZXR1cm4gMDt2YXIgbm9kZT1zdHJlYW0ubm9kZTtub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpO2lmKGJ1ZmZlci5zdWJhcnJheSYmKCFub2RlLmNvbnRlbnRzfHxub2RlLmNvbnRlbnRzLnN1YmFycmF5KSl7aWYoY2FuT3duKXtub2RlLmNvbnRlbnRzPWJ1ZmZlci5zdWJhcnJheShvZmZzZXQsb2Zmc2V0K2xlbmd0aCk7bm9kZS51c2VkQnl0ZXM9bGVuZ3RoO3JldHVybiBsZW5ndGh9ZWxzZSBpZihub2RlLnVzZWRCeXRlcz09PTAmJnBvc2l0aW9uPT09MCl7bm9kZS5jb250ZW50cz1idWZmZXIuc2xpY2Uob2Zmc2V0LG9mZnNldCtsZW5ndGgpO25vZGUudXNlZEJ5dGVzPWxlbmd0aDtyZXR1cm4gbGVuZ3RofWVsc2UgaWYocG9zaXRpb24rbGVuZ3RoPD1ub2RlLnVzZWRCeXRlcyl7bm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKSxwb3NpdGlvbik7cmV0dXJuIGxlbmd0aH19TUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uobm9kZSxwb3NpdGlvbitsZW5ndGgpO2lmKG5vZGUuY29udGVudHMuc3ViYXJyYXkmJmJ1ZmZlci5zdWJhcnJheSl7bm9kZS5jb250ZW50cy5zZXQoYnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKSxwb3NpdGlvbil9ZWxzZXtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe25vZGUuY29udGVudHNbcG9zaXRpb24raV09YnVmZmVyW29mZnNldCtpXX19bm9kZS51c2VkQnl0ZXM9TWF0aC5tYXgobm9kZS51c2VkQnl0ZXMscG9zaXRpb24rbGVuZ3RoKTtyZXR1cm4gbGVuZ3RofSxsbHNlZWsoc3RyZWFtLG9mZnNldCx3aGVuY2Upe3ZhciBwb3NpdGlvbj1vZmZzZXQ7aWYod2hlbmNlPT09MSl7cG9zaXRpb24rPXN0cmVhbS5wb3NpdGlvbn1lbHNlIGlmKHdoZW5jZT09PTIpe2lmKEZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSl7cG9zaXRpb24rPXN0cmVhbS5ub2RlLnVzZWRCeXRlc319aWYocG9zaXRpb248MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfXJldHVybiBwb3NpdGlvbn0sYWxsb2NhdGUoc3RyZWFtLG9mZnNldCxsZW5ndGgpe01FTUZTLmV4cGFuZEZpbGVTdG9yYWdlKHN0cmVhbS5ub2RlLG9mZnNldCtsZW5ndGgpO3N0cmVhbS5ub2RlLnVzZWRCeXRlcz1NYXRoLm1heChzdHJlYW0ubm9kZS51c2VkQnl0ZXMsb2Zmc2V0K2xlbmd0aCl9LG1tYXAoc3RyZWFtLGxlbmd0aCxwb3NpdGlvbixwcm90LGZsYWdzKXtpZighRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myl9dmFyIHB0cjt2YXIgYWxsb2NhdGVkO3ZhciBjb250ZW50cz1zdHJlYW0ubm9kZS5jb250ZW50cztpZighKGZsYWdzJjIpJiZjb250ZW50cy5idWZmZXI9PT1IRUFQOC5idWZmZXIpe2FsbG9jYXRlZD1mYWxzZTtwdHI9Y29udGVudHMuYnl0ZU9mZnNldH1lbHNle2lmKHBvc2l0aW9uPjB8fHBvc2l0aW9uK2xlbmd0aDxjb250ZW50cy5sZW5ndGgpe2lmKGNvbnRlbnRzLnN1YmFycmF5KXtjb250ZW50cz1jb250ZW50cy5zdWJhcnJheShwb3NpdGlvbixwb3NpdGlvbitsZW5ndGgpfWVsc2V7Y29udGVudHM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGVudHMscG9zaXRpb24scG9zaXRpb24rbGVuZ3RoKX19YWxsb2NhdGVkPXRydWU7cHRyPW1tYXBBbGxvYyhsZW5ndGgpO2lmKCFwdHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ4KX1IRUFQOC5zZXQoY29udGVudHMscHRyKX1yZXR1cm57cHRyOnB0cixhbGxvY2F0ZWQ6YWxsb2NhdGVkfX0sbXN5bmMoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl7TUVNRlMuc3RyZWFtX29wcy53cml0ZShzdHJlYW0sYnVmZmVyLDAsbGVuZ3RoLG9mZnNldCxmYWxzZSk7cmV0dXJuIDB9fX07dmFyIGFzeW5jTG9hZD0odXJsLG9ubG9hZCxvbmVycm9yLG5vUnVuRGVwKT0+e3ZhciBkZXA9IW5vUnVuRGVwP2dldFVuaXF1ZVJ1bkRlcGVuZGVuY3koYGFsICR7dXJsfWApOlwiXCI7cmVhZEFzeW5jKHVybCxhcnJheUJ1ZmZlcj0+e2Fzc2VydChhcnJheUJ1ZmZlcixgTG9hZGluZyBkYXRhIGZpbGUgXCIke3VybH1cIiBmYWlsZWQgKG5vIGFycmF5QnVmZmVyKS5gKTtvbmxvYWQobmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpKTtpZihkZXApcmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApfSxldmVudD0+e2lmKG9uZXJyb3Ipe29uZXJyb3IoKX1lbHNle3Rocm93YExvYWRpbmcgZGF0YSBmaWxlIFwiJHt1cmx9XCIgZmFpbGVkLmB9fSk7aWYoZGVwKWFkZFJ1bkRlcGVuZGVuY3koZGVwKX07dmFyIEZTX2NyZWF0ZURhdGFGaWxlPShwYXJlbnQsbmFtZSxmaWxlRGF0YSxjYW5SZWFkLGNhbldyaXRlLGNhbk93bik9PkZTLmNyZWF0ZURhdGFGaWxlKHBhcmVudCxuYW1lLGZpbGVEYXRhLGNhblJlYWQsY2FuV3JpdGUsY2FuT3duKTt2YXIgcHJlbG9hZFBsdWdpbnM9TW9kdWxlW1wicHJlbG9hZFBsdWdpbnNcIl18fFtdO3ZhciBGU19oYW5kbGVkQnlQcmVsb2FkUGx1Z2luPShieXRlQXJyYXksZnVsbG5hbWUsZmluaXNoLG9uZXJyb3IpPT57aWYodHlwZW9mIEJyb3dzZXIhPVwidW5kZWZpbmVkXCIpQnJvd3Nlci5pbml0KCk7dmFyIGhhbmRsZWQ9ZmFsc2U7cHJlbG9hZFBsdWdpbnMuZm9yRWFjaChwbHVnaW49PntpZihoYW5kbGVkKXJldHVybjtpZihwbHVnaW5bXCJjYW5IYW5kbGVcIl0oZnVsbG5hbWUpKXtwbHVnaW5bXCJoYW5kbGVcIl0oYnl0ZUFycmF5LGZ1bGxuYW1lLGZpbmlzaCxvbmVycm9yKTtoYW5kbGVkPXRydWV9fSk7cmV0dXJuIGhhbmRsZWR9O3ZhciBGU19jcmVhdGVQcmVsb2FkZWRGaWxlPShwYXJlbnQsbmFtZSx1cmwsY2FuUmVhZCxjYW5Xcml0ZSxvbmxvYWQsb25lcnJvcixkb250Q3JlYXRlRmlsZSxjYW5Pd24scHJlRmluaXNoKT0+e3ZhciBmdWxsbmFtZT1uYW1lP1BBVEhfRlMucmVzb2x2ZShQQVRILmpvaW4yKHBhcmVudCxuYW1lKSk6cGFyZW50O3ZhciBkZXA9Z2V0VW5pcXVlUnVuRGVwZW5kZW5jeShgY3AgJHtmdWxsbmFtZX1gKTtmdW5jdGlvbiBwcm9jZXNzRGF0YShieXRlQXJyYXkpe2Z1bmN0aW9uIGZpbmlzaChieXRlQXJyYXkpe2lmKHByZUZpbmlzaClwcmVGaW5pc2goKTtpZighZG9udENyZWF0ZUZpbGUpe0ZTX2NyZWF0ZURhdGFGaWxlKHBhcmVudCxuYW1lLGJ5dGVBcnJheSxjYW5SZWFkLGNhbldyaXRlLGNhbk93bil9aWYob25sb2FkKW9ubG9hZCgpO3JlbW92ZVJ1bkRlcGVuZGVuY3koZGVwKX1pZihGU19oYW5kbGVkQnlQcmVsb2FkUGx1Z2luKGJ5dGVBcnJheSxmdWxsbmFtZSxmaW5pc2gsKCk9PntpZihvbmVycm9yKW9uZXJyb3IoKTtyZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCl9KSl7cmV0dXJufWZpbmlzaChieXRlQXJyYXkpfWFkZFJ1bkRlcGVuZGVuY3koZGVwKTtpZih0eXBlb2YgdXJsPT1cInN0cmluZ1wiKXthc3luY0xvYWQodXJsLGJ5dGVBcnJheT0+cHJvY2Vzc0RhdGEoYnl0ZUFycmF5KSxvbmVycm9yKX1lbHNle3Byb2Nlc3NEYXRhKHVybCl9fTt2YXIgRlNfbW9kZVN0cmluZ1RvRmxhZ3M9c3RyPT57dmFyIGZsYWdNb2Rlcz17XCJyXCI6MCxcInIrXCI6MixcIndcIjo1MTJ8NjR8MSxcIncrXCI6NTEyfDY0fDIsXCJhXCI6MTAyNHw2NHwxLFwiYStcIjoxMDI0fDY0fDJ9O3ZhciBmbGFncz1mbGFnTW9kZXNbc3RyXTtpZih0eXBlb2YgZmxhZ3M9PVwidW5kZWZpbmVkXCIpe3Rocm93IG5ldyBFcnJvcihgVW5rbm93biBmaWxlIG9wZW4gbW9kZTogJHtzdHJ9YCl9cmV0dXJuIGZsYWdzfTt2YXIgRlNfZ2V0TW9kZT0oY2FuUmVhZCxjYW5Xcml0ZSk9Pnt2YXIgbW9kZT0wO2lmKGNhblJlYWQpbW9kZXw9MjkyfDczO2lmKGNhbldyaXRlKW1vZGV8PTE0NjtyZXR1cm4gbW9kZX07dmFyIEZTPXtyb290Om51bGwsbW91bnRzOltdLGRldmljZXM6e30sc3RyZWFtczpbXSxuZXh0SW5vZGU6MSxuYW1lVGFibGU6bnVsbCxjdXJyZW50UGF0aDpcIi9cIixpbml0aWFsaXplZDpmYWxzZSxpZ25vcmVQZXJtaXNzaW9uczp0cnVlLEVycm5vRXJyb3I6bnVsbCxnZW5lcmljRXJyb3JzOnt9LGZpbGVzeXN0ZW1zOm51bGwsc3luY0ZTUmVxdWVzdHM6MCxsb29rdXBQYXRoKHBhdGgsb3B0cz17fSl7cGF0aD1QQVRIX0ZTLnJlc29sdmUocGF0aCk7aWYoIXBhdGgpcmV0dXJue3BhdGg6XCJcIixub2RlOm51bGx9O3ZhciBkZWZhdWx0cz17Zm9sbG93X21vdW50OnRydWUscmVjdXJzZV9jb3VudDowfTtvcHRzPU9iamVjdC5hc3NpZ24oZGVmYXVsdHMsb3B0cyk7aWYob3B0cy5yZWN1cnNlX2NvdW50Pjgpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDMyKX12YXIgcGFydHM9cGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKHA9PiEhcCk7dmFyIGN1cnJlbnQ9RlMucm9vdDt2YXIgY3VycmVudF9wYXRoPVwiL1wiO2Zvcih2YXIgaT0wO2k8cGFydHMubGVuZ3RoO2krKyl7dmFyIGlzbGFzdD1pPT09cGFydHMubGVuZ3RoLTE7aWYoaXNsYXN0JiZvcHRzLnBhcmVudCl7YnJlYWt9Y3VycmVudD1GUy5sb29rdXBOb2RlKGN1cnJlbnQscGFydHNbaV0pO2N1cnJlbnRfcGF0aD1QQVRILmpvaW4yKGN1cnJlbnRfcGF0aCxwYXJ0c1tpXSk7aWYoRlMuaXNNb3VudHBvaW50KGN1cnJlbnQpKXtpZighaXNsYXN0fHxpc2xhc3QmJm9wdHMuZm9sbG93X21vdW50KXtjdXJyZW50PWN1cnJlbnQubW91bnRlZC5yb290fX1pZighaXNsYXN0fHxvcHRzLmZvbGxvdyl7dmFyIGNvdW50PTA7d2hpbGUoRlMuaXNMaW5rKGN1cnJlbnQubW9kZSkpe3ZhciBsaW5rPUZTLnJlYWRsaW5rKGN1cnJlbnRfcGF0aCk7Y3VycmVudF9wYXRoPVBBVEhfRlMucmVzb2x2ZShQQVRILmRpcm5hbWUoY3VycmVudF9wYXRoKSxsaW5rKTt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgoY3VycmVudF9wYXRoLHtyZWN1cnNlX2NvdW50Om9wdHMucmVjdXJzZV9jb3VudCsxfSk7Y3VycmVudD1sb29rdXAubm9kZTtpZihjb3VudCsrPjQwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMil9fX19cmV0dXJue3BhdGg6Y3VycmVudF9wYXRoLG5vZGU6Y3VycmVudH19LGdldFBhdGgobm9kZSl7dmFyIHBhdGg7d2hpbGUodHJ1ZSl7aWYoRlMuaXNSb290KG5vZGUpKXt2YXIgbW91bnQ9bm9kZS5tb3VudC5tb3VudHBvaW50O2lmKCFwYXRoKXJldHVybiBtb3VudDtyZXR1cm4gbW91bnRbbW91bnQubGVuZ3RoLTFdIT09XCIvXCI/YCR7bW91bnR9LyR7cGF0aH1gOm1vdW50K3BhdGh9cGF0aD1wYXRoP2Ake25vZGUubmFtZX0vJHtwYXRofWA6bm9kZS5uYW1lO25vZGU9bm9kZS5wYXJlbnR9fSxoYXNoTmFtZShwYXJlbnRpZCxuYW1lKXt2YXIgaGFzaD0wO2Zvcih2YXIgaT0wO2k8bmFtZS5sZW5ndGg7aSsrKXtoYXNoPShoYXNoPDw1KS1oYXNoK25hbWUuY2hhckNvZGVBdChpKXwwfXJldHVybihwYXJlbnRpZCtoYXNoPj4+MCklRlMubmFtZVRhYmxlLmxlbmd0aH0saGFzaEFkZE5vZGUobm9kZSl7dmFyIGhhc2g9RlMuaGFzaE5hbWUobm9kZS5wYXJlbnQuaWQsbm9kZS5uYW1lKTtub2RlLm5hbWVfbmV4dD1GUy5uYW1lVGFibGVbaGFzaF07RlMubmFtZVRhYmxlW2hhc2hdPW5vZGV9LGhhc2hSZW1vdmVOb2RlKG5vZGUpe3ZhciBoYXNoPUZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLG5vZGUubmFtZSk7aWYoRlMubmFtZVRhYmxlW2hhc2hdPT09bm9kZSl7RlMubmFtZVRhYmxlW2hhc2hdPW5vZGUubmFtZV9uZXh0fWVsc2V7dmFyIGN1cnJlbnQ9RlMubmFtZVRhYmxlW2hhc2hdO3doaWxlKGN1cnJlbnQpe2lmKGN1cnJlbnQubmFtZV9uZXh0PT09bm9kZSl7Y3VycmVudC5uYW1lX25leHQ9bm9kZS5uYW1lX25leHQ7YnJlYWt9Y3VycmVudD1jdXJyZW50Lm5hbWVfbmV4dH19fSxsb29rdXBOb2RlKHBhcmVudCxuYW1lKXt2YXIgZXJyQ29kZT1GUy5tYXlMb29rdXAocGFyZW50KTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlLHBhcmVudCl9dmFyIGhhc2g9RlMuaGFzaE5hbWUocGFyZW50LmlkLG5hbWUpO2Zvcih2YXIgbm9kZT1GUy5uYW1lVGFibGVbaGFzaF07bm9kZTtub2RlPW5vZGUubmFtZV9uZXh0KXt2YXIgbm9kZU5hbWU9bm9kZS5uYW1lO2lmKG5vZGUucGFyZW50LmlkPT09cGFyZW50LmlkJiZub2RlTmFtZT09PW5hbWUpe3JldHVybiBub2RlfX1yZXR1cm4gRlMubG9va3VwKHBhcmVudCxuYW1lKX0sY3JlYXRlTm9kZShwYXJlbnQsbmFtZSxtb2RlLHJkZXYpe3ZhciBub2RlPW5ldyBGUy5GU05vZGUocGFyZW50LG5hbWUsbW9kZSxyZGV2KTtGUy5oYXNoQWRkTm9kZShub2RlKTtyZXR1cm4gbm9kZX0sZGVzdHJveU5vZGUobm9kZSl7RlMuaGFzaFJlbW92ZU5vZGUobm9kZSl9LGlzUm9vdChub2RlKXtyZXR1cm4gbm9kZT09PW5vZGUucGFyZW50fSxpc01vdW50cG9pbnQobm9kZSl7cmV0dXJuISFub2RlLm1vdW50ZWR9LGlzRmlsZShtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT0zMjc2OH0saXNEaXIobW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09MTYzODR9LGlzTGluayhtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT00MDk2MH0saXNDaHJkZXYobW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09ODE5Mn0saXNCbGtkZXYobW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09MjQ1NzZ9LGlzRklGTyhtb2RlKXtyZXR1cm4obW9kZSY2MTQ0MCk9PT00MDk2fSxpc1NvY2tldChtb2RlKXtyZXR1cm4obW9kZSY0OTE1Mik9PT00OTE1Mn0sZmxhZ3NUb1Blcm1pc3Npb25TdHJpbmcoZmxhZyl7dmFyIHBlcm1zPVtcInJcIixcIndcIixcInJ3XCJdW2ZsYWcmM107aWYoZmxhZyY1MTIpe3Blcm1zKz1cIndcIn1yZXR1cm4gcGVybXN9LG5vZGVQZXJtaXNzaW9ucyhub2RlLHBlcm1zKXtpZihGUy5pZ25vcmVQZXJtaXNzaW9ucyl7cmV0dXJuIDB9aWYocGVybXMuaW5jbHVkZXMoXCJyXCIpJiYhKG5vZGUubW9kZSYyOTIpKXtyZXR1cm4gMn1lbHNlIGlmKHBlcm1zLmluY2x1ZGVzKFwid1wiKSYmIShub2RlLm1vZGUmMTQ2KSl7cmV0dXJuIDJ9ZWxzZSBpZihwZXJtcy5pbmNsdWRlcyhcInhcIikmJiEobm9kZS5tb2RlJjczKSl7cmV0dXJuIDJ9cmV0dXJuIDB9LG1heUxvb2t1cChkaXIpe3ZhciBlcnJDb2RlPUZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsXCJ4XCIpO2lmKGVyckNvZGUpcmV0dXJuIGVyckNvZGU7aWYoIWRpci5ub2RlX29wcy5sb29rdXApcmV0dXJuIDI7cmV0dXJuIDB9LG1heUNyZWF0ZShkaXIsbmFtZSl7dHJ5e3ZhciBub2RlPUZTLmxvb2t1cE5vZGUoZGlyLG5hbWUpO3JldHVybiAyMH1jYXRjaChlKXt9cmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhkaXIsXCJ3eFwiKX0sbWF5RGVsZXRlKGRpcixuYW1lLGlzZGlyKXt2YXIgbm9kZTt0cnl7bm9kZT1GUy5sb29rdXBOb2RlKGRpcixuYW1lKX1jYXRjaChlKXtyZXR1cm4gZS5lcnJub312YXIgZXJyQ29kZT1GUy5ub2RlUGVybWlzc2lvbnMoZGlyLFwid3hcIik7aWYoZXJyQ29kZSl7cmV0dXJuIGVyckNvZGV9aWYoaXNkaXIpe2lmKCFGUy5pc0Rpcihub2RlLm1vZGUpKXtyZXR1cm4gNTR9aWYoRlMuaXNSb290KG5vZGUpfHxGUy5nZXRQYXRoKG5vZGUpPT09RlMuY3dkKCkpe3JldHVybiAxMH19ZWxzZXtpZihGUy5pc0Rpcihub2RlLm1vZGUpKXtyZXR1cm4gMzF9fXJldHVybiAwfSxtYXlPcGVuKG5vZGUsZmxhZ3Mpe2lmKCFub2RlKXtyZXR1cm4gNDR9aWYoRlMuaXNMaW5rKG5vZGUubW9kZSkpe3JldHVybiAzMn1lbHNlIGlmKEZTLmlzRGlyKG5vZGUubW9kZSkpe2lmKEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSE9PVwiclwifHxmbGFncyY1MTIpe3JldHVybiAzMX19cmV0dXJuIEZTLm5vZGVQZXJtaXNzaW9ucyhub2RlLEZTLmZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWdzKSl9LE1BWF9PUEVOX0ZEUzo0MDk2LG5leHRmZCgpe2Zvcih2YXIgZmQ9MDtmZDw9RlMuTUFYX09QRU5fRkRTO2ZkKyspe2lmKCFGUy5zdHJlYW1zW2ZkXSl7cmV0dXJuIGZkfX10aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMyl9LGdldFN0cmVhbUNoZWNrZWQoZmQpe3ZhciBzdHJlYW09RlMuZ2V0U3RyZWFtKGZkKTtpZighc3RyZWFtKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KX1yZXR1cm4gc3RyZWFtfSxnZXRTdHJlYW06ZmQ9PkZTLnN0cmVhbXNbZmRdLGNyZWF0ZVN0cmVhbShzdHJlYW0sZmQ9LTEpe2lmKCFGUy5GU1N0cmVhbSl7RlMuRlNTdHJlYW09ZnVuY3Rpb24oKXt0aGlzLnNoYXJlZD17fX07RlMuRlNTdHJlYW0ucHJvdG90eXBlPXt9O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEZTLkZTU3RyZWFtLnByb3RvdHlwZSx7b2JqZWN0OntnZXQoKXtyZXR1cm4gdGhpcy5ub2RlfSxzZXQodmFsKXt0aGlzLm5vZGU9dmFsfX0saXNSZWFkOntnZXQoKXtyZXR1cm4odGhpcy5mbGFncyYyMDk3MTU1KSE9PTF9fSxpc1dyaXRlOntnZXQoKXtyZXR1cm4odGhpcy5mbGFncyYyMDk3MTU1KSE9PTB9fSxpc0FwcGVuZDp7Z2V0KCl7cmV0dXJuIHRoaXMuZmxhZ3MmMTAyNH19LGZsYWdzOntnZXQoKXtyZXR1cm4gdGhpcy5zaGFyZWQuZmxhZ3N9LHNldCh2YWwpe3RoaXMuc2hhcmVkLmZsYWdzPXZhbH19LHBvc2l0aW9uOntnZXQoKXtyZXR1cm4gdGhpcy5zaGFyZWQucG9zaXRpb259LHNldCh2YWwpe3RoaXMuc2hhcmVkLnBvc2l0aW9uPXZhbH19fSl9c3RyZWFtPU9iamVjdC5hc3NpZ24obmV3IEZTLkZTU3RyZWFtLHN0cmVhbSk7aWYoZmQ9PS0xKXtmZD1GUy5uZXh0ZmQoKX1zdHJlYW0uZmQ9ZmQ7RlMuc3RyZWFtc1tmZF09c3RyZWFtO3JldHVybiBzdHJlYW19LGNsb3NlU3RyZWFtKGZkKXtGUy5zdHJlYW1zW2ZkXT1udWxsfSxjaHJkZXZfc3RyZWFtX29wczp7b3BlbihzdHJlYW0pe3ZhciBkZXZpY2U9RlMuZ2V0RGV2aWNlKHN0cmVhbS5ub2RlLnJkZXYpO3N0cmVhbS5zdHJlYW1fb3BzPWRldmljZS5zdHJlYW1fb3BzO2lmKHN0cmVhbS5zdHJlYW1fb3BzLm9wZW4pe3N0cmVhbS5zdHJlYW1fb3BzLm9wZW4oc3RyZWFtKX19LGxsc2Vlaygpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKX19LG1ham9yOmRldj0+ZGV2Pj44LG1pbm9yOmRldj0+ZGV2JjI1NSxtYWtlZGV2OihtYSxtaSk9Pm1hPDw4fG1pLHJlZ2lzdGVyRGV2aWNlKGRldixvcHMpe0ZTLmRldmljZXNbZGV2XT17c3RyZWFtX29wczpvcHN9fSxnZXREZXZpY2U6ZGV2PT5GUy5kZXZpY2VzW2Rldl0sZ2V0TW91bnRzKG1vdW50KXt2YXIgbW91bnRzPVtdO3ZhciBjaGVjaz1bbW91bnRdO3doaWxlKGNoZWNrLmxlbmd0aCl7dmFyIG09Y2hlY2sucG9wKCk7bW91bnRzLnB1c2gobSk7Y2hlY2sucHVzaC5hcHBseShjaGVjayxtLm1vdW50cyl9cmV0dXJuIG1vdW50c30sc3luY2ZzKHBvcHVsYXRlLGNhbGxiYWNrKXtpZih0eXBlb2YgcG9wdWxhdGU9PVwiZnVuY3Rpb25cIil7Y2FsbGJhY2s9cG9wdWxhdGU7cG9wdWxhdGU9ZmFsc2V9RlMuc3luY0ZTUmVxdWVzdHMrKztpZihGUy5zeW5jRlNSZXF1ZXN0cz4xKXtlcnIoYHdhcm5pbmc6ICR7RlMuc3luY0ZTUmVxdWVzdHN9IEZTLnN5bmNmcyBvcGVyYXRpb25zIGluIGZsaWdodCBhdCBvbmNlLCBwcm9iYWJseSBqdXN0IGRvaW5nIGV4dHJhIHdvcmtgKX12YXIgbW91bnRzPUZTLmdldE1vdW50cyhGUy5yb290Lm1vdW50KTt2YXIgY29tcGxldGVkPTA7ZnVuY3Rpb24gZG9DYWxsYmFjayhlcnJDb2RlKXtGUy5zeW5jRlNSZXF1ZXN0cy0tO3JldHVybiBjYWxsYmFjayhlcnJDb2RlKX1mdW5jdGlvbiBkb25lKGVyckNvZGUpe2lmKGVyckNvZGUpe2lmKCFkb25lLmVycm9yZWQpe2RvbmUuZXJyb3JlZD10cnVlO3JldHVybiBkb0NhbGxiYWNrKGVyckNvZGUpfXJldHVybn1pZigrK2NvbXBsZXRlZD49bW91bnRzLmxlbmd0aCl7ZG9DYWxsYmFjayhudWxsKX19bW91bnRzLmZvckVhY2gobW91bnQ9PntpZighbW91bnQudHlwZS5zeW5jZnMpe3JldHVybiBkb25lKG51bGwpfW1vdW50LnR5cGUuc3luY2ZzKG1vdW50LHBvcHVsYXRlLGRvbmUpfSl9LG1vdW50KHR5cGUsb3B0cyxtb3VudHBvaW50KXt2YXIgcm9vdD1tb3VudHBvaW50PT09XCIvXCI7dmFyIHBzZXVkbz0hbW91bnRwb2ludDt2YXIgbm9kZTtpZihyb290JiZGUy5yb290KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCl9ZWxzZSBpZighcm9vdCYmIXBzZXVkbyl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKG1vdW50cG9pbnQse2ZvbGxvd19tb3VudDpmYWxzZX0pO21vdW50cG9pbnQ9bG9va3VwLnBhdGg7bm9kZT1sb29rdXAubm9kZTtpZihGUy5pc01vdW50cG9pbnQobm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKX1pZighRlMuaXNEaXIobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpfX12YXIgbW91bnQ9e3R5cGU6dHlwZSxvcHRzOm9wdHMsbW91bnRwb2ludDptb3VudHBvaW50LG1vdW50czpbXX07dmFyIG1vdW50Um9vdD10eXBlLm1vdW50KG1vdW50KTttb3VudFJvb3QubW91bnQ9bW91bnQ7bW91bnQucm9vdD1tb3VudFJvb3Q7aWYocm9vdCl7RlMucm9vdD1tb3VudFJvb3R9ZWxzZSBpZihub2RlKXtub2RlLm1vdW50ZWQ9bW91bnQ7aWYobm9kZS5tb3VudCl7bm9kZS5tb3VudC5tb3VudHMucHVzaChtb3VudCl9fXJldHVybiBtb3VudFJvb3R9LHVubW91bnQobW91bnRwb2ludCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKG1vdW50cG9pbnQse2ZvbGxvd19tb3VudDpmYWxzZX0pO2lmKCFGUy5pc01vdW50cG9pbnQobG9va3VwLm5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9dmFyIG5vZGU9bG9va3VwLm5vZGU7dmFyIG1vdW50PW5vZGUubW91bnRlZDt2YXIgbW91bnRzPUZTLmdldE1vdW50cyhtb3VudCk7T2JqZWN0LmtleXMoRlMubmFtZVRhYmxlKS5mb3JFYWNoKGhhc2g9Pnt2YXIgY3VycmVudD1GUy5uYW1lVGFibGVbaGFzaF07d2hpbGUoY3VycmVudCl7dmFyIG5leHQ9Y3VycmVudC5uYW1lX25leHQ7aWYobW91bnRzLmluY2x1ZGVzKGN1cnJlbnQubW91bnQpKXtGUy5kZXN0cm95Tm9kZShjdXJyZW50KX1jdXJyZW50PW5leHR9fSk7bm9kZS5tb3VudGVkPW51bGw7dmFyIGlkeD1ub2RlLm1vdW50Lm1vdW50cy5pbmRleE9mKG1vdW50KTtub2RlLm1vdW50Lm1vdW50cy5zcGxpY2UoaWR4LDEpfSxsb29rdXAocGFyZW50LG5hbWUpe3JldHVybiBwYXJlbnQubm9kZV9vcHMubG9va3VwKHBhcmVudCxuYW1lKX0sbWtub2QocGF0aCxtb2RlLGRldil7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse3BhcmVudDp0cnVlfSk7dmFyIHBhcmVudD1sb29rdXAubm9kZTt2YXIgbmFtZT1QQVRILmJhc2VuYW1lKHBhdGgpO2lmKCFuYW1lfHxuYW1lPT09XCIuXCJ8fG5hbWU9PT1cIi4uXCIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX12YXIgZXJyQ29kZT1GUy5tYXlDcmVhdGUocGFyZW50LG5hbWUpO2lmKGVyckNvZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpfWlmKCFwYXJlbnQubm9kZV9vcHMubWtub2Qpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKX1yZXR1cm4gcGFyZW50Lm5vZGVfb3BzLm1rbm9kKHBhcmVudCxuYW1lLG1vZGUsZGV2KX0sY3JlYXRlKHBhdGgsbW9kZSl7bW9kZT1tb2RlIT09dW5kZWZpbmVkP21vZGU6NDM4O21vZGUmPTQwOTU7bW9kZXw9MzI3Njg7cmV0dXJuIEZTLm1rbm9kKHBhdGgsbW9kZSwwKX0sbWtkaXIocGF0aCxtb2RlKXttb2RlPW1vZGUhPT11bmRlZmluZWQ/bW9kZTo1MTE7bW9kZSY9NTExfDUxMjttb2RlfD0xNjM4NDtyZXR1cm4gRlMubWtub2QocGF0aCxtb2RlLDApfSxta2RpclRyZWUocGF0aCxtb2RlKXt2YXIgZGlycz1wYXRoLnNwbGl0KFwiL1wiKTt2YXIgZD1cIlwiO2Zvcih2YXIgaT0wO2k8ZGlycy5sZW5ndGg7KytpKXtpZighZGlyc1tpXSljb250aW51ZTtkKz1cIi9cIitkaXJzW2ldO3RyeXtGUy5ta2RpcihkLG1vZGUpfWNhdGNoKGUpe2lmKGUuZXJybm8hPTIwKXRocm93IGV9fX0sbWtkZXYocGF0aCxtb2RlLGRldil7aWYodHlwZW9mIGRldj09XCJ1bmRlZmluZWRcIil7ZGV2PW1vZGU7bW9kZT00Mzh9bW9kZXw9ODE5MjtyZXR1cm4gRlMubWtub2QocGF0aCxtb2RlLGRldil9LHN5bWxpbmsob2xkcGF0aCxuZXdwYXRoKXtpZighUEFUSF9GUy5yZXNvbHZlKG9sZHBhdGgpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCl9dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKG5ld3BhdGgse3BhcmVudDp0cnVlfSk7dmFyIHBhcmVudD1sb29rdXAubm9kZTtpZighcGFyZW50KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCl9dmFyIG5ld25hbWU9UEFUSC5iYXNlbmFtZShuZXdwYXRoKTt2YXIgZXJyQ29kZT1GUy5tYXlDcmVhdGUocGFyZW50LG5ld25hbWUpO2lmKGVyckNvZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpfWlmKCFwYXJlbnQubm9kZV9vcHMuc3ltbGluayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpfXJldHVybiBwYXJlbnQubm9kZV9vcHMuc3ltbGluayhwYXJlbnQsbmV3bmFtZSxvbGRwYXRoKX0scmVuYW1lKG9sZF9wYXRoLG5ld19wYXRoKXt2YXIgb2xkX2Rpcm5hbWU9UEFUSC5kaXJuYW1lKG9sZF9wYXRoKTt2YXIgbmV3X2Rpcm5hbWU9UEFUSC5kaXJuYW1lKG5ld19wYXRoKTt2YXIgb2xkX25hbWU9UEFUSC5iYXNlbmFtZShvbGRfcGF0aCk7dmFyIG5ld19uYW1lPVBBVEguYmFzZW5hbWUobmV3X3BhdGgpO3ZhciBsb29rdXAsb2xkX2RpcixuZXdfZGlyO2xvb2t1cD1GUy5sb29rdXBQYXRoKG9sZF9wYXRoLHtwYXJlbnQ6dHJ1ZX0pO29sZF9kaXI9bG9va3VwLm5vZGU7bG9va3VwPUZTLmxvb2t1cFBhdGgobmV3X3BhdGgse3BhcmVudDp0cnVlfSk7bmV3X2Rpcj1sb29rdXAubm9kZTtpZighb2xkX2Rpcnx8IW5ld19kaXIpdGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpO2lmKG9sZF9kaXIubW91bnQhPT1uZXdfZGlyLm1vdW50KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3NSl9dmFyIG9sZF9ub2RlPUZTLmxvb2t1cE5vZGUob2xkX2RpcixvbGRfbmFtZSk7dmFyIHJlbGF0aXZlPVBBVEhfRlMucmVsYXRpdmUob2xkX3BhdGgsbmV3X2Rpcm5hbWUpO2lmKHJlbGF0aXZlLmNoYXJBdCgwKSE9PVwiLlwiKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9cmVsYXRpdmU9UEFUSF9GUy5yZWxhdGl2ZShuZXdfcGF0aCxvbGRfZGlybmFtZSk7aWYocmVsYXRpdmUuY2hhckF0KDApIT09XCIuXCIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KX12YXIgbmV3X25vZGU7dHJ5e25ld19ub2RlPUZTLmxvb2t1cE5vZGUobmV3X2RpcixuZXdfbmFtZSl9Y2F0Y2goZSl7fWlmKG9sZF9ub2RlPT09bmV3X25vZGUpe3JldHVybn12YXIgaXNkaXI9RlMuaXNEaXIob2xkX25vZGUubW9kZSk7dmFyIGVyckNvZGU9RlMubWF5RGVsZXRlKG9sZF9kaXIsb2xkX25hbWUsaXNkaXIpO2lmKGVyckNvZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpfWVyckNvZGU9bmV3X25vZGU/RlMubWF5RGVsZXRlKG5ld19kaXIsbmV3X25hbWUsaXNkaXIpOkZTLm1heUNyZWF0ZShuZXdfZGlyLG5ld19uYW1lKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX1pZighb2xkX2Rpci5ub2RlX29wcy5yZW5hbWUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKX1pZihGUy5pc01vdW50cG9pbnQob2xkX25vZGUpfHxuZXdfbm9kZSYmRlMuaXNNb3VudHBvaW50KG5ld19ub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApfWlmKG5ld19kaXIhPT1vbGRfZGlyKXtlcnJDb2RlPUZTLm5vZGVQZXJtaXNzaW9ucyhvbGRfZGlyLFwid1wiKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX19RlMuaGFzaFJlbW92ZU5vZGUob2xkX25vZGUpO3RyeXtvbGRfZGlyLm5vZGVfb3BzLnJlbmFtZShvbGRfbm9kZSxuZXdfZGlyLG5ld19uYW1lKX1jYXRjaChlKXt0aHJvdyBlfWZpbmFsbHl7RlMuaGFzaEFkZE5vZGUob2xkX25vZGUpfX0scm1kaXIocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse3BhcmVudDp0cnVlfSk7dmFyIHBhcmVudD1sb29rdXAubm9kZTt2YXIgbmFtZT1QQVRILmJhc2VuYW1lKHBhdGgpO3ZhciBub2RlPUZTLmxvb2t1cE5vZGUocGFyZW50LG5hbWUpO3ZhciBlcnJDb2RlPUZTLm1heURlbGV0ZShwYXJlbnQsbmFtZSx0cnVlKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX1pZighcGFyZW50Lm5vZGVfb3BzLnJtZGlyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myl9aWYoRlMuaXNNb3VudHBvaW50KG5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCl9cGFyZW50Lm5vZGVfb3BzLnJtZGlyKHBhcmVudCxuYW1lKTtGUy5kZXN0cm95Tm9kZShub2RlKX0scmVhZGRpcihwYXRoKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OnRydWV9KTt2YXIgbm9kZT1sb29rdXAubm9kZTtpZighbm9kZS5ub2RlX29wcy5yZWFkZGlyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCl9cmV0dXJuIG5vZGUubm9kZV9vcHMucmVhZGRpcihub2RlKX0sdW5saW5rKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7aWYoIXBhcmVudCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpfXZhciBuYW1lPVBBVEguYmFzZW5hbWUocGF0aCk7dmFyIG5vZGU9RlMubG9va3VwTm9kZShwYXJlbnQsbmFtZSk7dmFyIGVyckNvZGU9RlMubWF5RGVsZXRlKHBhcmVudCxuYW1lLGZhbHNlKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX1pZighcGFyZW50Lm5vZGVfb3BzLnVubGluayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpfWlmKEZTLmlzTW91bnRwb2ludChub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApfXBhcmVudC5ub2RlX29wcy51bmxpbmsocGFyZW50LG5hbWUpO0ZTLmRlc3Ryb3lOb2RlKG5vZGUpfSxyZWFkbGluayhwYXRoKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCk7dmFyIGxpbms9bG9va3VwLm5vZGU7aWYoIWxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KX1pZighbGluay5ub2RlX29wcy5yZWFkbGluayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfXJldHVybiBQQVRIX0ZTLnJlc29sdmUoRlMuZ2V0UGF0aChsaW5rLnBhcmVudCksbGluay5ub2RlX29wcy5yZWFkbGluayhsaW5rKSl9LHN0YXQocGF0aCxkb250Rm9sbG93KXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250Rm9sbG93fSk7dmFyIG5vZGU9bG9va3VwLm5vZGU7aWYoIW5vZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KX1pZighbm9kZS5ub2RlX29wcy5nZXRhdHRyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myl9cmV0dXJuIG5vZGUubm9kZV9vcHMuZ2V0YXR0cihub2RlKX0sbHN0YXQocGF0aCl7cmV0dXJuIEZTLnN0YXQocGF0aCx0cnVlKX0sY2htb2QocGF0aCxtb2RlLGRvbnRGb2xsb3cpe3ZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT1cInN0cmluZ1wiKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250Rm9sbG93fSk7bm9kZT1sb29rdXAubm9kZX1lbHNle25vZGU9cGF0aH1pZighbm9kZS5ub2RlX29wcy5zZXRhdHRyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myl9bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse21vZGU6bW9kZSY0MDk1fG5vZGUubW9kZSZ+NDA5NSx0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSxsY2htb2QocGF0aCxtb2RlKXtGUy5jaG1vZChwYXRoLG1vZGUsdHJ1ZSl9LGZjaG1vZChmZCxtb2RlKXt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO0ZTLmNobW9kKHN0cmVhbS5ub2RlLG1vZGUpfSxjaG93bihwYXRoLHVpZCxnaWQsZG9udEZvbGxvdyl7dmFyIG5vZGU7aWYodHlwZW9mIHBhdGg9PVwic3RyaW5nXCIpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6IWRvbnRGb2xsb3d9KTtub2RlPWxvb2t1cC5ub2RlfWVsc2V7bm9kZT1wYXRofWlmKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKX1ub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSx7dGltZXN0YW1wOkRhdGUubm93KCl9KX0sbGNob3duKHBhdGgsdWlkLGdpZCl7RlMuY2hvd24ocGF0aCx1aWQsZ2lkLHRydWUpfSxmY2hvd24oZmQsdWlkLGdpZCl7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtGUy5jaG93bihzdHJlYW0ubm9kZSx1aWQsZ2lkKX0sdHJ1bmNhdGUocGF0aCxsZW4pe2lmKGxlbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9dmFyIG5vZGU7aWYodHlwZW9mIHBhdGg9PVwic3RyaW5nXCIpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtmb2xsb3c6dHJ1ZX0pO25vZGU9bG9va3VwLm5vZGV9ZWxzZXtub2RlPXBhdGh9aWYoIW5vZGUubm9kZV9vcHMuc2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpfWlmKEZTLmlzRGlyKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKX1pZighRlMuaXNGaWxlKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX12YXIgZXJyQ29kZT1GUy5ub2RlUGVybWlzc2lvbnMobm9kZSxcIndcIik7aWYoZXJyQ29kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSl9bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse3NpemU6bGVuLHRpbWVzdGFtcDpEYXRlLm5vdygpfSl9LGZ0cnVuY2F0ZShmZCxsZW4pe3ZhciBzdHJlYW09RlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7aWYoKHN0cmVhbS5mbGFncyYyMDk3MTU1KT09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX1GUy50cnVuY2F0ZShzdHJlYW0ubm9kZSxsZW4pfSx1dGltZShwYXRoLGF0aW1lLG10aW1lKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OnRydWV9KTt2YXIgbm9kZT1sb29rdXAubm9kZTtub2RlLm5vZGVfb3BzLnNldGF0dHIobm9kZSx7dGltZXN0YW1wOk1hdGgubWF4KGF0aW1lLG10aW1lKX0pfSxvcGVuKHBhdGgsZmxhZ3MsbW9kZSl7aWYocGF0aD09PVwiXCIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KX1mbGFncz10eXBlb2YgZmxhZ3M9PVwic3RyaW5nXCI/RlNfbW9kZVN0cmluZ1RvRmxhZ3MoZmxhZ3MpOmZsYWdzO21vZGU9dHlwZW9mIG1vZGU9PVwidW5kZWZpbmVkXCI/NDM4Om1vZGU7aWYoZmxhZ3MmNjQpe21vZGU9bW9kZSY0MDk1fDMyNzY4fWVsc2V7bW9kZT0wfXZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT1cIm9iamVjdFwiKXtub2RlPXBhdGh9ZWxzZXtwYXRoPVBBVEgubm9ybWFsaXplKHBhdGgpO3RyeXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiEoZmxhZ3MmMTMxMDcyKX0pO25vZGU9bG9va3VwLm5vZGV9Y2F0Y2goZSl7fX12YXIgY3JlYXRlZD1mYWxzZTtpZihmbGFncyY2NCl7aWYobm9kZSl7aWYoZmxhZ3MmMTI4KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyMCl9fWVsc2V7bm9kZT1GUy5ta25vZChwYXRoLG1vZGUsMCk7Y3JlYXRlZD10cnVlfX1pZighbm9kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpfWlmKEZTLmlzQ2hyZGV2KG5vZGUubW9kZSkpe2ZsYWdzJj1+NTEyfWlmKGZsYWdzJjY1NTM2JiYhRlMuaXNEaXIobm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpfWlmKCFjcmVhdGVkKXt2YXIgZXJyQ29kZT1GUy5tYXlPcGVuKG5vZGUsZmxhZ3MpO2lmKGVyckNvZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpfX1pZihmbGFncyY1MTImJiFjcmVhdGVkKXtGUy50cnVuY2F0ZShub2RlLDApfWZsYWdzJj1+KDEyOHw1MTJ8MTMxMDcyKTt2YXIgc3RyZWFtPUZTLmNyZWF0ZVN0cmVhbSh7bm9kZTpub2RlLHBhdGg6RlMuZ2V0UGF0aChub2RlKSxmbGFnczpmbGFncyxzZWVrYWJsZTp0cnVlLHBvc2l0aW9uOjAsc3RyZWFtX29wczpub2RlLnN0cmVhbV9vcHMsdW5nb3R0ZW46W10sZXJyb3I6ZmFsc2V9KTtpZihzdHJlYW0uc3RyZWFtX29wcy5vcGVuKXtzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSl9aWYoTW9kdWxlW1wibG9nUmVhZEZpbGVzXCJdJiYhKGZsYWdzJjEpKXtpZighRlMucmVhZEZpbGVzKUZTLnJlYWRGaWxlcz17fTtpZighKHBhdGggaW4gRlMucmVhZEZpbGVzKSl7RlMucmVhZEZpbGVzW3BhdGhdPTF9fXJldHVybiBzdHJlYW19LGNsb3NlKHN0cmVhbSl7aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCl9aWYoc3RyZWFtLmdldGRlbnRzKXN0cmVhbS5nZXRkZW50cz1udWxsO3RyeXtpZihzdHJlYW0uc3RyZWFtX29wcy5jbG9zZSl7c3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Uoc3RyZWFtKX19Y2F0Y2goZSl7dGhyb3cgZX1maW5hbGx5e0ZTLmNsb3NlU3RyZWFtKHN0cmVhbS5mZCl9c3RyZWFtLmZkPW51bGx9LGlzQ2xvc2VkKHN0cmVhbSl7cmV0dXJuIHN0cmVhbS5mZD09PW51bGx9LGxsc2VlayhzdHJlYW0sb2Zmc2V0LHdoZW5jZSl7aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCl9aWYoIXN0cmVhbS5zZWVrYWJsZXx8IXN0cmVhbS5zdHJlYW1fb3BzLmxsc2Vlayl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzApfWlmKHdoZW5jZSE9MCYmd2hlbmNlIT0xJiZ3aGVuY2UhPTIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX1zdHJlYW0ucG9zaXRpb249c3RyZWFtLnN0cmVhbV9vcHMubGxzZWVrKHN0cmVhbSxvZmZzZXQsd2hlbmNlKTtzdHJlYW0udW5nb3R0ZW49W107cmV0dXJuIHN0cmVhbS5wb3NpdGlvbn0scmVhZChzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe2lmKGxlbmd0aDwwfHxwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCl9aWYoKHN0cmVhbS5mbGFncyYyMDk3MTU1KT09PTEpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpfWlmKEZTLmlzRGlyKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSl9aWYoIXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX12YXIgc2Vla2luZz10eXBlb2YgcG9zaXRpb24hPVwidW5kZWZpbmVkXCI7aWYoIXNlZWtpbmcpe3Bvc2l0aW9uPXN0cmVhbS5wb3NpdGlvbn1lbHNlIGlmKCFzdHJlYW0uc2Vla2FibGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKX12YXIgYnl0ZXNSZWFkPXN0cmVhbS5zdHJlYW1fb3BzLnJlYWQoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKTtpZighc2Vla2luZylzdHJlYW0ucG9zaXRpb24rPWJ5dGVzUmVhZDtyZXR1cm4gYnl0ZXNSZWFkfSx3cml0ZShzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24sY2FuT3duKXtpZihsZW5ndGg8MHx8cG9zaXRpb248MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfWlmKEZTLmlzQ2xvc2VkKHN0cmVhbSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpfWlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KX1pZihGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpfWlmKCFzdHJlYW0uc3RyZWFtX29wcy53cml0ZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfWlmKHN0cmVhbS5zZWVrYWJsZSYmc3RyZWFtLmZsYWdzJjEwMjQpe0ZTLmxsc2VlayhzdHJlYW0sMCwyKX12YXIgc2Vla2luZz10eXBlb2YgcG9zaXRpb24hPVwidW5kZWZpbmVkXCI7aWYoIXNlZWtpbmcpe3Bvc2l0aW9uPXN0cmVhbS5wb3NpdGlvbn1lbHNlIGlmKCFzdHJlYW0uc2Vla2FibGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKX12YXIgYnl0ZXNXcml0dGVuPXN0cmVhbS5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixjYW5Pd24pO2lmKCFzZWVraW5nKXN0cmVhbS5wb3NpdGlvbis9Ynl0ZXNXcml0dGVuO3JldHVybiBieXRlc1dyaXR0ZW59LGFsbG9jYXRlKHN0cmVhbSxvZmZzZXQsbGVuZ3RoKXtpZihGUy5pc0Nsb3NlZChzdHJlYW0pKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KX1pZihvZmZzZXQ8MHx8bGVuZ3RoPD0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9aWYoKHN0cmVhbS5mbGFncyYyMDk3MTU1KT09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpfWlmKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkmJiFGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpfWlmKCFzdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTM4KX1zdHJlYW0uc3RyZWFtX29wcy5hbGxvY2F0ZShzdHJlYW0sb2Zmc2V0LGxlbmd0aCl9LG1tYXAoc3RyZWFtLGxlbmd0aCxwb3NpdGlvbixwcm90LGZsYWdzKXtpZigocHJvdCYyKSE9PTAmJihmbGFncyYyKT09PTAmJihzdHJlYW0uZmxhZ3MmMjA5NzE1NSkhPT0yKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyKX1pZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMil9aWYoIXN0cmVhbS5zdHJlYW1fb3BzLm1tYXApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKX1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubW1hcChzdHJlYW0sbGVuZ3RoLHBvc2l0aW9uLHByb3QsZmxhZ3MpfSxtc3luYyhzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgsbW1hcEZsYWdzKXtpZighc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMpe3JldHVybiAwfXJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5tc3luYyhzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgsbW1hcEZsYWdzKX0sbXVubWFwOnN0cmVhbT0+MCxpb2N0bChzdHJlYW0sY21kLGFyZyl7aWYoIXN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1OSl9cmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLmlvY3RsKHN0cmVhbSxjbWQsYXJnKX0scmVhZEZpbGUocGF0aCxvcHRzPXt9KXtvcHRzLmZsYWdzPW9wdHMuZmxhZ3N8fDA7b3B0cy5lbmNvZGluZz1vcHRzLmVuY29kaW5nfHxcImJpbmFyeVwiO2lmKG9wdHMuZW5jb2RpbmchPT1cInV0ZjhcIiYmb3B0cy5lbmNvZGluZyE9PVwiYmluYXJ5XCIpe3Rocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbmNvZGluZyB0eXBlIFwiJHtvcHRzLmVuY29kaW5nfVwiYCl9dmFyIHJldDt2YXIgc3RyZWFtPUZTLm9wZW4ocGF0aCxvcHRzLmZsYWdzKTt2YXIgc3RhdD1GUy5zdGF0KHBhdGgpO3ZhciBsZW5ndGg9c3RhdC5zaXplO3ZhciBidWY9bmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtGUy5yZWFkKHN0cmVhbSxidWYsMCxsZW5ndGgsMCk7aWYob3B0cy5lbmNvZGluZz09PVwidXRmOFwiKXtyZXQ9VVRGOEFycmF5VG9TdHJpbmcoYnVmLDApfWVsc2UgaWYob3B0cy5lbmNvZGluZz09PVwiYmluYXJ5XCIpe3JldD1idWZ9RlMuY2xvc2Uoc3RyZWFtKTtyZXR1cm4gcmV0fSx3cml0ZUZpbGUocGF0aCxkYXRhLG9wdHM9e30pe29wdHMuZmxhZ3M9b3B0cy5mbGFnc3x8NTc3O3ZhciBzdHJlYW09RlMub3BlbihwYXRoLG9wdHMuZmxhZ3Msb3B0cy5tb2RlKTtpZih0eXBlb2YgZGF0YT09XCJzdHJpbmdcIil7dmFyIGJ1Zj1uZXcgVWludDhBcnJheShsZW5ndGhCeXRlc1VURjgoZGF0YSkrMSk7dmFyIGFjdHVhbE51bUJ5dGVzPXN0cmluZ1RvVVRGOEFycmF5KGRhdGEsYnVmLDAsYnVmLmxlbmd0aCk7RlMud3JpdGUoc3RyZWFtLGJ1ZiwwLGFjdHVhbE51bUJ5dGVzLHVuZGVmaW5lZCxvcHRzLmNhbk93bil9ZWxzZSBpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpe0ZTLndyaXRlKHN0cmVhbSxkYXRhLDAsZGF0YS5ieXRlTGVuZ3RoLHVuZGVmaW5lZCxvcHRzLmNhbk93bil9ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBkYXRhIHR5cGVcIil9RlMuY2xvc2Uoc3RyZWFtKX0sY3dkOigpPT5GUy5jdXJyZW50UGF0aCxjaGRpcihwYXRoKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OnRydWV9KTtpZihsb29rdXAubm9kZT09PW51bGwpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KX1pZighRlMuaXNEaXIobG9va3VwLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KX12YXIgZXJyQ29kZT1GUy5ub2RlUGVybWlzc2lvbnMobG9va3VwLm5vZGUsXCJ4XCIpO2lmKGVyckNvZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpfUZTLmN1cnJlbnRQYXRoPWxvb2t1cC5wYXRofSxjcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKXtGUy5ta2RpcihcIi90bXBcIik7RlMubWtkaXIoXCIvaG9tZVwiKTtGUy5ta2RpcihcIi9ob21lL3dlYl91c2VyXCIpfSxjcmVhdGVEZWZhdWx0RGV2aWNlcygpe0ZTLm1rZGlyKFwiL2RldlwiKTtGUy5yZWdpc3RlckRldmljZShGUy5tYWtlZGV2KDEsMykse3JlYWQ6KCk9PjAsd3JpdGU6KHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3MpPT5sZW5ndGh9KTtGUy5ta2RldihcIi9kZXYvbnVsbFwiLEZTLm1ha2VkZXYoMSwzKSk7VFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNSwwKSxUVFkuZGVmYXVsdF90dHlfb3BzKTtUVFkucmVnaXN0ZXIoRlMubWFrZWRldig2LDApLFRUWS5kZWZhdWx0X3R0eTFfb3BzKTtGUy5ta2RldihcIi9kZXYvdHR5XCIsRlMubWFrZWRldig1LDApKTtGUy5ta2RldihcIi9kZXYvdHR5MVwiLEZTLm1ha2VkZXYoNiwwKSk7dmFyIHJhbmRvbUJ1ZmZlcj1uZXcgVWludDhBcnJheSgxMDI0KSxyYW5kb21MZWZ0PTA7dmFyIHJhbmRvbUJ5dGU9KCk9PntpZihyYW5kb21MZWZ0PT09MCl7cmFuZG9tTGVmdD1yYW5kb21GaWxsKHJhbmRvbUJ1ZmZlcikuYnl0ZUxlbmd0aH1yZXR1cm4gcmFuZG9tQnVmZmVyWy0tcmFuZG9tTGVmdF19O0ZTLmNyZWF0ZURldmljZShcIi9kZXZcIixcInJhbmRvbVwiLHJhbmRvbUJ5dGUpO0ZTLmNyZWF0ZURldmljZShcIi9kZXZcIixcInVyYW5kb21cIixyYW5kb21CeXRlKTtGUy5ta2RpcihcIi9kZXYvc2htXCIpO0ZTLm1rZGlyKFwiL2Rldi9zaG0vdG1wXCIpfSxjcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMoKXtGUy5ta2RpcihcIi9wcm9jXCIpO3ZhciBwcm9jX3NlbGY9RlMubWtkaXIoXCIvcHJvYy9zZWxmXCIpO0ZTLm1rZGlyKFwiL3Byb2Mvc2VsZi9mZFwiKTtGUy5tb3VudCh7bW91bnQoKXt2YXIgbm9kZT1GUy5jcmVhdGVOb2RlKHByb2Nfc2VsZixcImZkXCIsMTYzODR8NTExLDczKTtub2RlLm5vZGVfb3BzPXtsb29rdXAocGFyZW50LG5hbWUpe3ZhciBmZD0rbmFtZTt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO3ZhciByZXQ9e3BhcmVudDpudWxsLG1vdW50Onttb3VudHBvaW50OlwiZmFrZVwifSxub2RlX29wczp7cmVhZGxpbms6KCk9PnN0cmVhbS5wYXRofX07cmV0LnBhcmVudD1yZXQ7cmV0dXJuIHJldH19O3JldHVybiBub2RlfX0se30sXCIvcHJvYy9zZWxmL2ZkXCIpfSxjcmVhdGVTdGFuZGFyZFN0cmVhbXMoKXtpZihNb2R1bGVbXCJzdGRpblwiXSl7RlMuY3JlYXRlRGV2aWNlKFwiL2RldlwiLFwic3RkaW5cIixNb2R1bGVbXCJzdGRpblwiXSl9ZWxzZXtGUy5zeW1saW5rKFwiL2Rldi90dHlcIixcIi9kZXYvc3RkaW5cIil9aWYoTW9kdWxlW1wic3Rkb3V0XCJdKXtGUy5jcmVhdGVEZXZpY2UoXCIvZGV2XCIsXCJzdGRvdXRcIixudWxsLE1vZHVsZVtcInN0ZG91dFwiXSl9ZWxzZXtGUy5zeW1saW5rKFwiL2Rldi90dHlcIixcIi9kZXYvc3Rkb3V0XCIpfWlmKE1vZHVsZVtcInN0ZGVyclwiXSl7RlMuY3JlYXRlRGV2aWNlKFwiL2RldlwiLFwic3RkZXJyXCIsbnVsbCxNb2R1bGVbXCJzdGRlcnJcIl0pfWVsc2V7RlMuc3ltbGluayhcIi9kZXYvdHR5MVwiLFwiL2Rldi9zdGRlcnJcIil9dmFyIHN0ZGluPUZTLm9wZW4oXCIvZGV2L3N0ZGluXCIsMCk7dmFyIHN0ZG91dD1GUy5vcGVuKFwiL2Rldi9zdGRvdXRcIiwxKTt2YXIgc3RkZXJyPUZTLm9wZW4oXCIvZGV2L3N0ZGVyclwiLDEpfSxlbnN1cmVFcnJub0Vycm9yKCl7aWYoRlMuRXJybm9FcnJvcilyZXR1cm47RlMuRXJybm9FcnJvcj1mdW5jdGlvbiBFcnJub0Vycm9yKGVycm5vLG5vZGUpe3RoaXMubmFtZT1cIkVycm5vRXJyb3JcIjt0aGlzLm5vZGU9bm9kZTt0aGlzLnNldEVycm5vPWZ1bmN0aW9uKGVycm5vKXt0aGlzLmVycm5vPWVycm5vfTt0aGlzLnNldEVycm5vKGVycm5vKTt0aGlzLm1lc3NhZ2U9XCJGUyBlcnJvclwifTtGUy5FcnJub0Vycm9yLnByb3RvdHlwZT1uZXcgRXJyb3I7RlMuRXJybm9FcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3I9RlMuRXJybm9FcnJvcjtbNDRdLmZvckVhY2goY29kZT0+e0ZTLmdlbmVyaWNFcnJvcnNbY29kZV09bmV3IEZTLkVycm5vRXJyb3IoY29kZSk7RlMuZ2VuZXJpY0Vycm9yc1tjb2RlXS5zdGFjaz1cIjxnZW5lcmljIGVycm9yLCBubyBzdGFjaz5cIn0pfSxzdGF0aWNJbml0KCl7RlMuZW5zdXJlRXJybm9FcnJvcigpO0ZTLm5hbWVUYWJsZT1uZXcgQXJyYXkoNDA5Nik7RlMubW91bnQoTUVNRlMse30sXCIvXCIpO0ZTLmNyZWF0ZURlZmF1bHREaXJlY3RvcmllcygpO0ZTLmNyZWF0ZURlZmF1bHREZXZpY2VzKCk7RlMuY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCk7RlMuZmlsZXN5c3RlbXM9e1wiTUVNRlNcIjpNRU1GU319LGluaXQoaW5wdXQsb3V0cHV0LGVycm9yKXtGUy5pbml0LmluaXRpYWxpemVkPXRydWU7RlMuZW5zdXJlRXJybm9FcnJvcigpO01vZHVsZVtcInN0ZGluXCJdPWlucHV0fHxNb2R1bGVbXCJzdGRpblwiXTtNb2R1bGVbXCJzdGRvdXRcIl09b3V0cHV0fHxNb2R1bGVbXCJzdGRvdXRcIl07TW9kdWxlW1wic3RkZXJyXCJdPWVycm9yfHxNb2R1bGVbXCJzdGRlcnJcIl07RlMuY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCl9LHF1aXQoKXtGUy5pbml0LmluaXRpYWxpemVkPWZhbHNlO2Zvcih2YXIgaT0wO2k8RlMuc3RyZWFtcy5sZW5ndGg7aSsrKXt2YXIgc3RyZWFtPUZTLnN0cmVhbXNbaV07aWYoIXN0cmVhbSl7Y29udGludWV9RlMuY2xvc2Uoc3RyZWFtKX19LGZpbmRPYmplY3QocGF0aCxkb250UmVzb2x2ZUxhc3RMaW5rKXt2YXIgcmV0PUZTLmFuYWx5emVQYXRoKHBhdGgsZG9udFJlc29sdmVMYXN0TGluayk7aWYoIXJldC5leGlzdHMpe3JldHVybiBudWxsfXJldHVybiByZXQub2JqZWN0fSxhbmFseXplUGF0aChwYXRoLGRvbnRSZXNvbHZlTGFzdExpbmspe3RyeXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250UmVzb2x2ZUxhc3RMaW5rfSk7cGF0aD1sb29rdXAucGF0aH1jYXRjaChlKXt9dmFyIHJldD17aXNSb290OmZhbHNlLGV4aXN0czpmYWxzZSxlcnJvcjowLG5hbWU6bnVsbCxwYXRoOm51bGwsb2JqZWN0Om51bGwscGFyZW50RXhpc3RzOmZhbHNlLHBhcmVudFBhdGg6bnVsbCxwYXJlbnRPYmplY3Q6bnVsbH07dHJ5e3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3JldC5wYXJlbnRFeGlzdHM9dHJ1ZTtyZXQucGFyZW50UGF0aD1sb29rdXAucGF0aDtyZXQucGFyZW50T2JqZWN0PWxvb2t1cC5ub2RlO3JldC5uYW1lPVBBVEguYmFzZW5hbWUocGF0aCk7bG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250UmVzb2x2ZUxhc3RMaW5rfSk7cmV0LmV4aXN0cz10cnVlO3JldC5wYXRoPWxvb2t1cC5wYXRoO3JldC5vYmplY3Q9bG9va3VwLm5vZGU7cmV0Lm5hbWU9bG9va3VwLm5vZGUubmFtZTtyZXQuaXNSb290PWxvb2t1cC5wYXRoPT09XCIvXCJ9Y2F0Y2goZSl7cmV0LmVycm9yPWUuZXJybm99cmV0dXJuIHJldH0sY3JlYXRlUGF0aChwYXJlbnQscGF0aCxjYW5SZWFkLGNhbldyaXRlKXtwYXJlbnQ9dHlwZW9mIHBhcmVudD09XCJzdHJpbmdcIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpO3ZhciBwYXJ0cz1wYXRoLnNwbGl0KFwiL1wiKS5yZXZlcnNlKCk7d2hpbGUocGFydHMubGVuZ3RoKXt2YXIgcGFydD1wYXJ0cy5wb3AoKTtpZighcGFydCljb250aW51ZTt2YXIgY3VycmVudD1QQVRILmpvaW4yKHBhcmVudCxwYXJ0KTt0cnl7RlMubWtkaXIoY3VycmVudCl9Y2F0Y2goZSl7fXBhcmVudD1jdXJyZW50fXJldHVybiBjdXJyZW50fSxjcmVhdGVGaWxlKHBhcmVudCxuYW1lLHByb3BlcnRpZXMsY2FuUmVhZCxjYW5Xcml0ZSl7dmFyIHBhdGg9UEFUSC5qb2luMih0eXBlb2YgcGFyZW50PT1cInN0cmluZ1wiP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7dmFyIG1vZGU9RlNfZ2V0TW9kZShjYW5SZWFkLGNhbldyaXRlKTtyZXR1cm4gRlMuY3JlYXRlKHBhdGgsbW9kZSl9LGNyZWF0ZURhdGFGaWxlKHBhcmVudCxuYW1lLGRhdGEsY2FuUmVhZCxjYW5Xcml0ZSxjYW5Pd24pe3ZhciBwYXRoPW5hbWU7aWYocGFyZW50KXtwYXJlbnQ9dHlwZW9mIHBhcmVudD09XCJzdHJpbmdcIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpO3BhdGg9bmFtZT9QQVRILmpvaW4yKHBhcmVudCxuYW1lKTpwYXJlbnR9dmFyIG1vZGU9RlNfZ2V0TW9kZShjYW5SZWFkLGNhbldyaXRlKTt2YXIgbm9kZT1GUy5jcmVhdGUocGF0aCxtb2RlKTtpZihkYXRhKXtpZih0eXBlb2YgZGF0YT09XCJzdHJpbmdcIil7dmFyIGFycj1uZXcgQXJyYXkoZGF0YS5sZW5ndGgpO2Zvcih2YXIgaT0wLGxlbj1kYXRhLmxlbmd0aDtpPGxlbjsrK2kpYXJyW2ldPWRhdGEuY2hhckNvZGVBdChpKTtkYXRhPWFycn1GUy5jaG1vZChub2RlLG1vZGV8MTQ2KTt2YXIgc3RyZWFtPUZTLm9wZW4obm9kZSw1NzcpO0ZTLndyaXRlKHN0cmVhbSxkYXRhLDAsZGF0YS5sZW5ndGgsMCxjYW5Pd24pO0ZTLmNsb3NlKHN0cmVhbSk7RlMuY2htb2Qobm9kZSxtb2RlKX1yZXR1cm4gbm9kZX0sY3JlYXRlRGV2aWNlKHBhcmVudCxuYW1lLGlucHV0LG91dHB1dCl7dmFyIHBhdGg9UEFUSC5qb2luMih0eXBlb2YgcGFyZW50PT1cInN0cmluZ1wiP3BhcmVudDpGUy5nZXRQYXRoKHBhcmVudCksbmFtZSk7dmFyIG1vZGU9RlNfZ2V0TW9kZSghIWlucHV0LCEhb3V0cHV0KTtpZighRlMuY3JlYXRlRGV2aWNlLm1ham9yKUZTLmNyZWF0ZURldmljZS5tYWpvcj02NDt2YXIgZGV2PUZTLm1ha2VkZXYoRlMuY3JlYXRlRGV2aWNlLm1ham9yKyssMCk7RlMucmVnaXN0ZXJEZXZpY2UoZGV2LHtvcGVuKHN0cmVhbSl7c3RyZWFtLnNlZWthYmxlPWZhbHNlfSxjbG9zZShzdHJlYW0pe2lmKG91dHB1dCYmb3V0cHV0LmJ1ZmZlciYmb3V0cHV0LmJ1ZmZlci5sZW5ndGgpe291dHB1dCgxMCl9fSxyZWFkKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe3ZhciBieXRlc1JlYWQ9MDtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3ZhciByZXN1bHQ7dHJ5e3Jlc3VsdD1pbnB1dCgpfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KX1pZihyZXN1bHQ9PT11bmRlZmluZWQmJmJ5dGVzUmVhZD09PTApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYpfWlmKHJlc3VsdD09PW51bGx8fHJlc3VsdD09PXVuZGVmaW5lZClicmVhaztieXRlc1JlYWQrKztidWZmZXJbb2Zmc2V0K2ldPXJlc3VsdH1pZihieXRlc1JlYWQpe3N0cmVhbS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpfXJldHVybiBieXRlc1JlYWR9LHdyaXRlKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7dHJ5e291dHB1dChidWZmZXJbb2Zmc2V0K2ldKX1jYXRjaChlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOSl9fWlmKGxlbmd0aCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCl9cmV0dXJuIGl9fSk7cmV0dXJuIEZTLm1rZGV2KHBhdGgsbW9kZSxkZXYpfSxmb3JjZUxvYWRGaWxlKG9iail7aWYob2JqLmlzRGV2aWNlfHxvYmouaXNGb2xkZXJ8fG9iai5saW5rfHxvYmouY29udGVudHMpcmV0dXJuIHRydWU7aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0IT1cInVuZGVmaW5lZFwiKXt0aHJvdyBuZXcgRXJyb3IoXCJMYXp5IGxvYWRpbmcgc2hvdWxkIGhhdmUgYmVlbiBwZXJmb3JtZWQgKGNvbnRlbnRzIHNldCkgaW4gY3JlYXRlTGF6eUZpbGUsIGJ1dCBpdCB3YXMgbm90LiBMYXp5IGxvYWRpbmcgb25seSB3b3JrcyBpbiB3ZWIgd29ya2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjIG9uIHRoZSBtYWluIHRocmVhZC5cIil9ZWxzZSBpZihyZWFkXyl7dHJ5e29iai5jb250ZW50cz1pbnRBcnJheUZyb21TdHJpbmcocmVhZF8ob2JqLnVybCksdHJ1ZSk7b2JqLnVzZWRCeXRlcz1vYmouY29udGVudHMubGVuZ3RofWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KX19ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC5cIil9fSxjcmVhdGVMYXp5RmlsZShwYXJlbnQsbmFtZSx1cmwsY2FuUmVhZCxjYW5Xcml0ZSl7ZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXkoKXt0aGlzLmxlbmd0aEtub3duPWZhbHNlO3RoaXMuY2h1bmtzPVtdfUxhenlVaW50OEFycmF5LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfZ2V0KGlkeCl7aWYoaWR4PnRoaXMubGVuZ3RoLTF8fGlkeDwwKXtyZXR1cm4gdW5kZWZpbmVkfXZhciBjaHVua09mZnNldD1pZHgldGhpcy5jaHVua1NpemU7dmFyIGNodW5rTnVtPWlkeC90aGlzLmNodW5rU2l6ZXwwO3JldHVybiB0aGlzLmdldHRlcihjaHVua051bSlbY2h1bmtPZmZzZXRdfTtMYXp5VWludDhBcnJheS5wcm90b3R5cGUuc2V0RGF0YUdldHRlcj1mdW5jdGlvbiBMYXp5VWludDhBcnJheV9zZXREYXRhR2V0dGVyKGdldHRlcil7dGhpcy5nZXR0ZXI9Z2V0dGVyfTtMYXp5VWludDhBcnJheS5wcm90b3R5cGUuY2FjaGVMZW5ndGg9ZnVuY3Rpb24gTGF6eVVpbnQ4QXJyYXlfY2FjaGVMZW5ndGgoKXt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkhFQURcIix1cmwsZmFsc2UpO3hoci5zZW5kKG51bGwpO2lmKCEoeGhyLnN0YXR1cz49MjAwJiZ4aHIuc3RhdHVzPDMwMHx8eGhyLnN0YXR1cz09PTMwNCkpdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIit1cmwrXCIuIFN0YXR1czogXCIreGhyLnN0YXR1cyk7dmFyIGRhdGFsZW5ndGg9TnVtYmVyKHhoci5nZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtbGVuZ3RoXCIpKTt2YXIgaGVhZGVyO3ZhciBoYXNCeXRlU2VydmluZz0oaGVhZGVyPXhoci5nZXRSZXNwb25zZUhlYWRlcihcIkFjY2VwdC1SYW5nZXNcIikpJiZoZWFkZXI9PT1cImJ5dGVzXCI7dmFyIHVzZXNHemlwPShoZWFkZXI9eGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1FbmNvZGluZ1wiKSkmJmhlYWRlcj09PVwiZ3ppcFwiO3ZhciBjaHVua1NpemU9MTAyNCoxMDI0O2lmKCFoYXNCeXRlU2VydmluZyljaHVua1NpemU9ZGF0YWxlbmd0aDt2YXIgZG9YSFI9KGZyb20sdG8pPT57aWYoZnJvbT50byl0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHJhbmdlIChcIitmcm9tK1wiLCBcIit0bytcIikgb3Igbm8gYnl0ZXMgcmVxdWVzdGVkIVwiKTtpZih0bz5kYXRhbGVuZ3RoLTEpdGhyb3cgbmV3IEVycm9yKFwib25seSBcIitkYXRhbGVuZ3RoK1wiIGJ5dGVzIGF2YWlsYWJsZSEgcHJvZ3JhbW1lciBlcnJvciFcIik7dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO2lmKGRhdGFsZW5ndGghPT1jaHVua1NpemUpeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLFwiYnl0ZXM9XCIrZnJvbStcIi1cIit0byk7eGhyLnJlc3BvbnNlVHlwZT1cImFycmF5YnVmZmVyXCI7aWYoeGhyLm92ZXJyaWRlTWltZVR5cGUpe3hoci5vdmVycmlkZU1pbWVUeXBlKFwidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZFwiKX14aHIuc2VuZChudWxsKTtpZighKHhoci5zdGF0dXM+PTIwMCYmeGhyLnN0YXR1czwzMDB8fHhoci5zdGF0dXM9PT0zMDQpKXRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGxvYWQgXCIrdXJsK1wiLiBTdGF0dXM6IFwiK3hoci5zdGF0dXMpO2lmKHhoci5yZXNwb25zZSE9PXVuZGVmaW5lZCl7cmV0dXJuIG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZXx8W10pfXJldHVybiBpbnRBcnJheUZyb21TdHJpbmcoeGhyLnJlc3BvbnNlVGV4dHx8XCJcIix0cnVlKX07dmFyIGxhenlBcnJheT10aGlzO2xhenlBcnJheS5zZXREYXRhR2V0dGVyKGNodW5rTnVtPT57dmFyIHN0YXJ0PWNodW5rTnVtKmNodW5rU2l6ZTt2YXIgZW5kPShjaHVua051bSsxKSpjaHVua1NpemUtMTtlbmQ9TWF0aC5taW4oZW5kLGRhdGFsZW5ndGgtMSk7aWYodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPT1cInVuZGVmaW5lZFwiKXtsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXT1kb1hIUihzdGFydCxlbmQpfWlmKHR5cGVvZiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXT09XCJ1bmRlZmluZWRcIil0aHJvdyBuZXcgRXJyb3IoXCJkb1hIUiBmYWlsZWQhXCIpO3JldHVybiBsYXp5QXJyYXkuY2h1bmtzW2NodW5rTnVtXX0pO2lmKHVzZXNHemlwfHwhZGF0YWxlbmd0aCl7Y2h1bmtTaXplPWRhdGFsZW5ndGg9MTtkYXRhbGVuZ3RoPXRoaXMuZ2V0dGVyKDApLmxlbmd0aDtjaHVua1NpemU9ZGF0YWxlbmd0aDtvdXQoXCJMYXp5RmlsZXMgb24gZ3ppcCBmb3JjZXMgZG93bmxvYWQgb2YgdGhlIHdob2xlIGZpbGUgd2hlbiBsZW5ndGggaXMgYWNjZXNzZWRcIil9dGhpcy5fbGVuZ3RoPWRhdGFsZW5ndGg7dGhpcy5fY2h1bmtTaXplPWNodW5rU2l6ZTt0aGlzLmxlbmd0aEtub3duPXRydWV9O2lmKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCE9XCJ1bmRlZmluZWRcIil7aWYoIUVOVklST05NRU5UX0lTX1dPUktFUil0aHJvd1wiQ2Fubm90IGRvIHN5bmNocm9ub3VzIGJpbmFyeSBYSFJzIG91dHNpZGUgd2Vid29ya2VycyBpbiBtb2Rlcm4gYnJvd3NlcnMuIFVzZSAtLWVtYmVkLWZpbGUgb3IgLS1wcmVsb2FkLWZpbGUgaW4gZW1jY1wiO3ZhciBsYXp5QXJyYXk9bmV3IExhenlVaW50OEFycmF5O09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGxhenlBcnJheSx7bGVuZ3RoOntnZXQ6ZnVuY3Rpb24oKXtpZighdGhpcy5sZW5ndGhLbm93bil7dGhpcy5jYWNoZUxlbmd0aCgpfXJldHVybiB0aGlzLl9sZW5ndGh9fSxjaHVua1NpemU6e2dldDpmdW5jdGlvbigpe2lmKCF0aGlzLmxlbmd0aEtub3duKXt0aGlzLmNhY2hlTGVuZ3RoKCl9cmV0dXJuIHRoaXMuX2NodW5rU2l6ZX19fSk7dmFyIHByb3BlcnRpZXM9e2lzRGV2aWNlOmZhbHNlLGNvbnRlbnRzOmxhenlBcnJheX19ZWxzZXt2YXIgcHJvcGVydGllcz17aXNEZXZpY2U6ZmFsc2UsdXJsOnVybH19dmFyIG5vZGU9RlMuY3JlYXRlRmlsZShwYXJlbnQsbmFtZSxwcm9wZXJ0aWVzLGNhblJlYWQsY2FuV3JpdGUpO2lmKHByb3BlcnRpZXMuY29udGVudHMpe25vZGUuY29udGVudHM9cHJvcGVydGllcy5jb250ZW50c31lbHNlIGlmKHByb3BlcnRpZXMudXJsKXtub2RlLmNvbnRlbnRzPW51bGw7bm9kZS51cmw9cHJvcGVydGllcy51cmx9T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobm9kZSx7dXNlZEJ5dGVzOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZW50cy5sZW5ndGh9fX0pO3ZhciBzdHJlYW1fb3BzPXt9O3ZhciBrZXlzPU9iamVjdC5rZXlzKG5vZGUuc3RyZWFtX29wcyk7a2V5cy5mb3JFYWNoKGtleT0+e3ZhciBmbj1ub2RlLnN0cmVhbV9vcHNba2V5XTtzdHJlYW1fb3BzW2tleV09ZnVuY3Rpb24gZm9yY2VMb2FkTGF6eUZpbGUoKXtGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO3JldHVybiBmbi5hcHBseShudWxsLGFyZ3VtZW50cyl9fSk7ZnVuY3Rpb24gd3JpdGVDaHVua3Moc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXt2YXIgY29udGVudHM9c3RyZWFtLm5vZGUuY29udGVudHM7aWYocG9zaXRpb24+PWNvbnRlbnRzLmxlbmd0aClyZXR1cm4gMDt2YXIgc2l6ZT1NYXRoLm1pbihjb250ZW50cy5sZW5ndGgtcG9zaXRpb24sbGVuZ3RoKTtpZihjb250ZW50cy5zbGljZSl7Zm9yKHZhciBpPTA7aTxzaXplO2krKyl7YnVmZmVyW29mZnNldCtpXT1jb250ZW50c1twb3NpdGlvbitpXX19ZWxzZXtmb3IodmFyIGk9MDtpPHNpemU7aSsrKXtidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzLmdldChwb3NpdGlvbitpKX19cmV0dXJuIHNpemV9c3RyZWFtX29wcy5yZWFkPShzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pPT57RlMuZm9yY2VMb2FkRmlsZShub2RlKTtyZXR1cm4gd3JpdGVDaHVua3Moc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKX07c3RyZWFtX29wcy5tbWFwPShzdHJlYW0sbGVuZ3RoLHBvc2l0aW9uLHByb3QsZmxhZ3MpPT57RlMuZm9yY2VMb2FkRmlsZShub2RlKTt2YXIgcHRyPW1tYXBBbGxvYyhsZW5ndGgpO2lmKCFwdHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ4KX13cml0ZUNodW5rcyhzdHJlYW0sSEVBUDgscHRyLGxlbmd0aCxwb3NpdGlvbik7cmV0dXJue3B0cjpwdHIsYWxsb2NhdGVkOnRydWV9fTtub2RlLnN0cmVhbV9vcHM9c3RyZWFtX29wcztyZXR1cm4gbm9kZX19O3ZhciBTWVNDQUxMUz17REVGQVVMVF9QT0xMTUFTSzo1LGNhbGN1bGF0ZUF0KGRpcmZkLHBhdGgsYWxsb3dFbXB0eSl7aWYoUEFUSC5pc0FicyhwYXRoKSl7cmV0dXJuIHBhdGh9dmFyIGRpcjtpZihkaXJmZD09PS0xMDApe2Rpcj1GUy5jd2QoKX1lbHNle3ZhciBkaXJzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGRpcmZkKTtkaXI9ZGlyc3RyZWFtLnBhdGh9aWYocGF0aC5sZW5ndGg9PTApe2lmKCFhbGxvd0VtcHR5KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCl9cmV0dXJuIGRpcn1yZXR1cm4gUEFUSC5qb2luMihkaXIscGF0aCl9LGRvU3RhdChmdW5jLHBhdGgsYnVmKXt0cnl7dmFyIHN0YXQ9ZnVuYyhwYXRoKX1jYXRjaChlKXtpZihlJiZlLm5vZGUmJlBBVEgubm9ybWFsaXplKHBhdGgpIT09UEFUSC5ub3JtYWxpemUoRlMuZ2V0UGF0aChlLm5vZGUpKSl7cmV0dXJuLTU0fXRocm93IGV9SEVBUDMyW2J1Zj4+Ml09c3RhdC5kZXY7SEVBUDMyW2J1Zis0Pj4yXT1zdGF0Lm1vZGU7SEVBUFUzMltidWYrOD4+Ml09c3RhdC5ubGluaztIRUFQMzJbYnVmKzEyPj4yXT1zdGF0LnVpZDtIRUFQMzJbYnVmKzE2Pj4yXT1zdGF0LmdpZDtIRUFQMzJbYnVmKzIwPj4yXT1zdGF0LnJkZXY7dGVtcEk2ND1bc3RhdC5zaXplPj4+MCwodGVtcERvdWJsZT1zdGF0LnNpemUsK01hdGguYWJzKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8rTWF0aC5mbG9vcih0ZW1wRG91YmxlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUtKyh+fnRlbXBEb3VibGU+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApXSxIRUFQMzJbYnVmKzI0Pj4yXT10ZW1wSTY0WzBdLEhFQVAzMltidWYrMjg+PjJdPXRlbXBJNjRbMV07SEVBUDMyW2J1ZiszMj4+Ml09NDA5NjtIRUFQMzJbYnVmKzM2Pj4yXT1zdGF0LmJsb2Nrczt2YXIgYXRpbWU9c3RhdC5hdGltZS5nZXRUaW1lKCk7dmFyIG10aW1lPXN0YXQubXRpbWUuZ2V0VGltZSgpO3ZhciBjdGltZT1zdGF0LmN0aW1lLmdldFRpbWUoKTt0ZW1wSTY0PVtNYXRoLmZsb29yKGF0aW1lLzFlMyk+Pj4wLCh0ZW1wRG91YmxlPU1hdGguZmxvb3IoYXRpbWUvMWUzKSwrTWF0aC5hYnModGVtcERvdWJsZSk+PTE/dGVtcERvdWJsZT4wPytNYXRoLmZsb29yKHRlbXBEb3VibGUvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgodGVtcERvdWJsZS0rKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltidWYrNDA+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW2J1Zis0ND4+Ml09dGVtcEk2NFsxXTtIRUFQVTMyW2J1Zis0OD4+Ml09YXRpbWUlMWUzKjFlMzt0ZW1wSTY0PVtNYXRoLmZsb29yKG10aW1lLzFlMyk+Pj4wLCh0ZW1wRG91YmxlPU1hdGguZmxvb3IobXRpbWUvMWUzKSwrTWF0aC5hYnModGVtcERvdWJsZSk+PTE/dGVtcERvdWJsZT4wPytNYXRoLmZsb29yKHRlbXBEb3VibGUvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgodGVtcERvdWJsZS0rKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltidWYrNTY+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW2J1Zis2MD4+Ml09dGVtcEk2NFsxXTtIRUFQVTMyW2J1Zis2ND4+Ml09bXRpbWUlMWUzKjFlMzt0ZW1wSTY0PVtNYXRoLmZsb29yKGN0aW1lLzFlMyk+Pj4wLCh0ZW1wRG91YmxlPU1hdGguZmxvb3IoY3RpbWUvMWUzKSwrTWF0aC5hYnModGVtcERvdWJsZSk+PTE/dGVtcERvdWJsZT4wPytNYXRoLmZsb29yKHRlbXBEb3VibGUvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgodGVtcERvdWJsZS0rKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltidWYrNzI+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW2J1Zis3Nj4+Ml09dGVtcEk2NFsxXTtIRUFQVTMyW2J1Zis4MD4+Ml09Y3RpbWUlMWUzKjFlMzt0ZW1wSTY0PVtzdGF0Lmlubz4+PjAsKHRlbXBEb3VibGU9c3RhdC5pbm8sK01hdGguYWJzKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8rTWF0aC5mbG9vcih0ZW1wRG91YmxlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUtKyh+fnRlbXBEb3VibGU+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApXSxIRUFQMzJbYnVmKzg4Pj4yXT10ZW1wSTY0WzBdLEhFQVAzMltidWYrOTI+PjJdPXRlbXBJNjRbMV07cmV0dXJuIDB9LGRvTXN5bmMoYWRkcixzdHJlYW0sbGVuLGZsYWdzLG9mZnNldCl7aWYoIUZTLmlzRmlsZShzdHJlYW0ubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDMpfWlmKGZsYWdzJjIpe3JldHVybiAwfXZhciBidWZmZXI9SEVBUFU4LnNsaWNlKGFkZHIsYWRkcitsZW4pO0ZTLm1zeW5jKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbixmbGFncyl9LHZhcmFyZ3M6dW5kZWZpbmVkLGdldCgpe3ZhciByZXQ9SEVBUDMyWytTWVNDQUxMUy52YXJhcmdzPj4yXTtTWVNDQUxMUy52YXJhcmdzKz00O3JldHVybiByZXR9LGdldHAoKXtyZXR1cm4gU1lTQ0FMTFMuZ2V0KCl9LGdldFN0cihwdHIpe3ZhciByZXQ9VVRGOFRvU3RyaW5nKHB0cik7cmV0dXJuIHJldH0sZ2V0U3RyZWFtRnJvbUZEKGZkKXt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO3JldHVybiBzdHJlYW19fTt2YXIgX2Vudmlyb25fZ2V0PShfX2Vudmlyb24sZW52aXJvbl9idWYpPT57dmFyIGJ1ZlNpemU9MDtnZXRFbnZTdHJpbmdzKCkuZm9yRWFjaCgoc3RyaW5nLGkpPT57dmFyIHB0cj1lbnZpcm9uX2J1ZitidWZTaXplO0hFQVBVMzJbX19lbnZpcm9uK2kqND4+Ml09cHRyO3N0cmluZ1RvQXNjaWkoc3RyaW5nLHB0cik7YnVmU2l6ZSs9c3RyaW5nLmxlbmd0aCsxfSk7cmV0dXJuIDB9O3ZhciBfZW52aXJvbl9zaXplc19nZXQ9KHBlbnZpcm9uX2NvdW50LHBlbnZpcm9uX2J1Zl9zaXplKT0+e3ZhciBzdHJpbmdzPWdldEVudlN0cmluZ3MoKTtIRUFQVTMyW3BlbnZpcm9uX2NvdW50Pj4yXT1zdHJpbmdzLmxlbmd0aDt2YXIgYnVmU2l6ZT0wO3N0cmluZ3MuZm9yRWFjaChzdHJpbmc9PmJ1ZlNpemUrPXN0cmluZy5sZW5ndGgrMSk7SEVBUFUzMltwZW52aXJvbl9idWZfc2l6ZT4+Ml09YnVmU2l6ZTtyZXR1cm4gMH07ZnVuY3Rpb24gX2ZkX2Nsb3NlKGZkKXt0cnl7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO0ZTLmNsb3NlKHN0cmVhbSk7cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT1cInVuZGVmaW5lZFwifHwhKGUubmFtZT09PVwiRXJybm9FcnJvclwiKSl0aHJvdyBlO3JldHVybiBlLmVycm5vfX12YXIgZG9SZWFkdj0oc3RyZWFtLGlvdixpb3ZjbnQsb2Zmc2V0KT0+e3ZhciByZXQ9MDtmb3IodmFyIGk9MDtpPGlvdmNudDtpKyspe3ZhciBwdHI9SEVBUFUzMltpb3Y+PjJdO3ZhciBsZW49SEVBUFUzMltpb3YrND4+Ml07aW92Kz04O3ZhciBjdXJyPUZTLnJlYWQoc3RyZWFtLEhFQVA4LHB0cixsZW4sb2Zmc2V0KTtpZihjdXJyPDApcmV0dXJuLTE7cmV0Kz1jdXJyO2lmKGN1cnI8bGVuKWJyZWFrO2lmKHR5cGVvZiBvZmZzZXQhPT1cInVuZGVmaW5lZFwiKXtvZmZzZXQrPWN1cnJ9fXJldHVybiByZXR9O2Z1bmN0aW9uIF9mZF9yZWFkKGZkLGlvdixpb3ZjbnQscG51bSl7dHJ5e3ZhciBzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTt2YXIgbnVtPWRvUmVhZHYoc3RyZWFtLGlvdixpb3ZjbnQpO0hFQVBVMzJbcG51bT4+Ml09bnVtO3JldHVybiAwfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09XCJ1bmRlZmluZWRcInx8IShlLm5hbWU9PT1cIkVycm5vRXJyb3JcIikpdGhyb3cgZTtyZXR1cm4gZS5lcnJub319dmFyIGNvbnZlcnRJMzJQYWlyVG9JNTNDaGVja2VkPShsbyxoaSk9PmhpKzIwOTcxNTI+Pj4wPDQxOTQzMDUtISFsbz8obG8+Pj4wKStoaSo0Mjk0OTY3Mjk2Ok5hTjtmdW5jdGlvbiBfZmRfc2VlayhmZCxvZmZzZXRfbG93LG9mZnNldF9oaWdoLHdoZW5jZSxuZXdPZmZzZXQpe3ZhciBvZmZzZXQ9Y29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWQob2Zmc2V0X2xvdyxvZmZzZXRfaGlnaCk7dHJ5e2lmKGlzTmFOKG9mZnNldCkpcmV0dXJuIDYxO3ZhciBzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTtGUy5sbHNlZWsoc3RyZWFtLG9mZnNldCx3aGVuY2UpO3RlbXBJNjQ9W3N0cmVhbS5wb3NpdGlvbj4+PjAsKHRlbXBEb3VibGU9c3RyZWFtLnBvc2l0aW9uLCtNYXRoLmFicyh0ZW1wRG91YmxlKT49MT90ZW1wRG91YmxlPjA/K01hdGguZmxvb3IodGVtcERvdWJsZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlLSsofn50ZW1wRG91YmxlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sSEVBUDMyW25ld09mZnNldD4+Ml09dGVtcEk2NFswXSxIRUFQMzJbbmV3T2Zmc2V0KzQ+PjJdPXRlbXBJNjRbMV07aWYoc3RyZWFtLmdldGRlbnRzJiZvZmZzZXQ9PT0wJiZ3aGVuY2U9PT0wKXN0cmVhbS5nZXRkZW50cz1udWxsO3JldHVybiAwfWNhdGNoKGUpe2lmKHR5cGVvZiBGUz09XCJ1bmRlZmluZWRcInx8IShlLm5hbWU9PT1cIkVycm5vRXJyb3JcIikpdGhyb3cgZTtyZXR1cm4gZS5lcnJub319dmFyIGRvV3JpdGV2PShzdHJlYW0saW92LGlvdmNudCxvZmZzZXQpPT57dmFyIHJldD0wO2Zvcih2YXIgaT0wO2k8aW92Y250O2krKyl7dmFyIHB0cj1IRUFQVTMyW2lvdj4+Ml07dmFyIGxlbj1IRUFQVTMyW2lvdis0Pj4yXTtpb3YrPTg7dmFyIGN1cnI9RlMud3JpdGUoc3RyZWFtLEhFQVA4LHB0cixsZW4sb2Zmc2V0KTtpZihjdXJyPDApcmV0dXJuLTE7cmV0Kz1jdXJyO2lmKHR5cGVvZiBvZmZzZXQhPT1cInVuZGVmaW5lZFwiKXtvZmZzZXQrPWN1cnJ9fXJldHVybiByZXR9O2Z1bmN0aW9uIF9mZF93cml0ZShmZCxpb3YsaW92Y250LHBudW0pe3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7dmFyIG51bT1kb1dyaXRldihzdHJlYW0saW92LGlvdmNudCk7SEVBUFUzMltwbnVtPj4yXT1udW07cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT1cInVuZGVmaW5lZFwifHwhKGUubmFtZT09PVwiRXJybm9FcnJvclwiKSl0aHJvdyBlO3JldHVybiBlLmVycm5vfX12YXIgaXNMZWFwWWVhcj15ZWFyPT55ZWFyJTQ9PT0wJiYoeWVhciUxMDAhPT0wfHx5ZWFyJTQwMD09PTApO3ZhciBhcnJheVN1bT0oYXJyYXksaW5kZXgpPT57dmFyIHN1bT0wO2Zvcih2YXIgaT0wO2k8PWluZGV4O3N1bSs9YXJyYXlbaSsrXSl7fXJldHVybiBzdW19O3ZhciBNT05USF9EQVlTX0xFQVA9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTt2YXIgTU9OVEhfREFZU19SRUdVTEFSPVszMSwyOCwzMSwzMCwzMSwzMCwzMSwzMSwzMCwzMSwzMCwzMV07dmFyIGFkZERheXM9KGRhdGUsZGF5cyk9Pnt2YXIgbmV3RGF0ZT1uZXcgRGF0ZShkYXRlLmdldFRpbWUoKSk7d2hpbGUoZGF5cz4wKXt2YXIgbGVhcD1pc0xlYXBZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSk7dmFyIGN1cnJlbnRNb250aD1uZXdEYXRlLmdldE1vbnRoKCk7dmFyIGRheXNJbkN1cnJlbnRNb250aD0obGVhcD9NT05USF9EQVlTX0xFQVA6TU9OVEhfREFZU19SRUdVTEFSKVtjdXJyZW50TW9udGhdO2lmKGRheXM+ZGF5c0luQ3VycmVudE1vbnRoLW5ld0RhdGUuZ2V0RGF0ZSgpKXtkYXlzLT1kYXlzSW5DdXJyZW50TW9udGgtbmV3RGF0ZS5nZXREYXRlKCkrMTtuZXdEYXRlLnNldERhdGUoMSk7aWYoY3VycmVudE1vbnRoPDExKXtuZXdEYXRlLnNldE1vbnRoKGN1cnJlbnRNb250aCsxKX1lbHNle25ld0RhdGUuc2V0TW9udGgoMCk7bmV3RGF0ZS5zZXRGdWxsWWVhcihuZXdEYXRlLmdldEZ1bGxZZWFyKCkrMSl9fWVsc2V7bmV3RGF0ZS5zZXREYXRlKG5ld0RhdGUuZ2V0RGF0ZSgpK2RheXMpO3JldHVybiBuZXdEYXRlfX1yZXR1cm4gbmV3RGF0ZX07dmFyIHdyaXRlQXJyYXlUb01lbW9yeT0oYXJyYXksYnVmZmVyKT0+e0hFQVA4LnNldChhcnJheSxidWZmZXIpfTt2YXIgX3N0cmZ0aW1lPShzLG1heHNpemUsZm9ybWF0LHRtKT0+e3ZhciB0bV96b25lPUhFQVBVMzJbdG0rNDA+PjJdO3ZhciBkYXRlPXt0bV9zZWM6SEVBUDMyW3RtPj4yXSx0bV9taW46SEVBUDMyW3RtKzQ+PjJdLHRtX2hvdXI6SEVBUDMyW3RtKzg+PjJdLHRtX21kYXk6SEVBUDMyW3RtKzEyPj4yXSx0bV9tb246SEVBUDMyW3RtKzE2Pj4yXSx0bV95ZWFyOkhFQVAzMlt0bSsyMD4+Ml0sdG1fd2RheTpIRUFQMzJbdG0rMjQ+PjJdLHRtX3lkYXk6SEVBUDMyW3RtKzI4Pj4yXSx0bV9pc2RzdDpIRUFQMzJbdG0rMzI+PjJdLHRtX2dtdG9mZjpIRUFQMzJbdG0rMzY+PjJdLHRtX3pvbmU6dG1fem9uZT9VVEY4VG9TdHJpbmcodG1fem9uZSk6XCJcIn07dmFyIHBhdHRlcm49VVRGOFRvU3RyaW5nKGZvcm1hdCk7dmFyIEVYUEFOU0lPTl9SVUxFU18xPXtcIiVjXCI6XCIlYSAlYiAlZCAlSDolTTolUyAlWVwiLFwiJURcIjpcIiVtLyVkLyV5XCIsXCIlRlwiOlwiJVktJW0tJWRcIixcIiVoXCI6XCIlYlwiLFwiJXJcIjpcIiVJOiVNOiVTICVwXCIsXCIlUlwiOlwiJUg6JU1cIixcIiVUXCI6XCIlSDolTTolU1wiLFwiJXhcIjpcIiVtLyVkLyV5XCIsXCIlWFwiOlwiJUg6JU06JVNcIixcIiVFY1wiOlwiJWNcIixcIiVFQ1wiOlwiJUNcIixcIiVFeFwiOlwiJW0vJWQvJXlcIixcIiVFWFwiOlwiJUg6JU06JVNcIixcIiVFeVwiOlwiJXlcIixcIiVFWVwiOlwiJVlcIixcIiVPZFwiOlwiJWRcIixcIiVPZVwiOlwiJWVcIixcIiVPSFwiOlwiJUhcIixcIiVPSVwiOlwiJUlcIixcIiVPbVwiOlwiJW1cIixcIiVPTVwiOlwiJU1cIixcIiVPU1wiOlwiJVNcIixcIiVPdVwiOlwiJXVcIixcIiVPVVwiOlwiJVVcIixcIiVPVlwiOlwiJVZcIixcIiVPd1wiOlwiJXdcIixcIiVPV1wiOlwiJVdcIixcIiVPeVwiOlwiJXlcIn07Zm9yKHZhciBydWxlIGluIEVYUEFOU0lPTl9SVUxFU18xKXtwYXR0ZXJuPXBhdHRlcm4ucmVwbGFjZShuZXcgUmVnRXhwKHJ1bGUsXCJnXCIpLEVYUEFOU0lPTl9SVUxFU18xW3J1bGVdKX12YXIgV0VFS0RBWVM9W1wiU3VuZGF5XCIsXCJNb25kYXlcIixcIlR1ZXNkYXlcIixcIldlZG5lc2RheVwiLFwiVGh1cnNkYXlcIixcIkZyaWRheVwiLFwiU2F0dXJkYXlcIl07dmFyIE1PTlRIUz1bXCJKYW51YXJ5XCIsXCJGZWJydWFyeVwiLFwiTWFyY2hcIixcIkFwcmlsXCIsXCJNYXlcIixcIkp1bmVcIixcIkp1bHlcIixcIkF1Z3VzdFwiLFwiU2VwdGVtYmVyXCIsXCJPY3RvYmVyXCIsXCJOb3ZlbWJlclwiLFwiRGVjZW1iZXJcIl07ZnVuY3Rpb24gbGVhZGluZ1NvbWV0aGluZyh2YWx1ZSxkaWdpdHMsY2hhcmFjdGVyKXt2YXIgc3RyPXR5cGVvZiB2YWx1ZT09XCJudW1iZXJcIj92YWx1ZS50b1N0cmluZygpOnZhbHVlfHxcIlwiO3doaWxlKHN0ci5sZW5ndGg8ZGlnaXRzKXtzdHI9Y2hhcmFjdGVyWzBdK3N0cn1yZXR1cm4gc3RyfWZ1bmN0aW9uIGxlYWRpbmdOdWxscyh2YWx1ZSxkaWdpdHMpe3JldHVybiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLGRpZ2l0cyxcIjBcIil9ZnVuY3Rpb24gY29tcGFyZUJ5RGF5KGRhdGUxLGRhdGUyKXtmdW5jdGlvbiBzZ24odmFsdWUpe3JldHVybiB2YWx1ZTwwPy0xOnZhbHVlPjA/MTowfXZhciBjb21wYXJlO2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRGdWxsWWVhcigpLWRhdGUyLmdldEZ1bGxZZWFyKCkpKT09PTApe2lmKChjb21wYXJlPXNnbihkYXRlMS5nZXRNb250aCgpLWRhdGUyLmdldE1vbnRoKCkpKT09PTApe2NvbXBhcmU9c2duKGRhdGUxLmdldERhdGUoKS1kYXRlMi5nZXREYXRlKCkpfX1yZXR1cm4gY29tcGFyZX1mdW5jdGlvbiBnZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoKXtzd2l0Y2goamFuRm91cnRoLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMjkpO2Nhc2UgMTpyZXR1cm4gamFuRm91cnRoO2Nhc2UgMjpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMik7Y2FzZSA0OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwzMSk7Y2FzZSA2OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDMwKX19ZnVuY3Rpb24gZ2V0V2Vla0Jhc2VkWWVhcihkYXRlKXt2YXIgdGhpc0RhdGU9YWRkRGF5cyhuZXcgRGF0ZShkYXRlLnRtX3llYXIrMTkwMCwwLDEpLGRhdGUudG1feWRheSk7dmFyIGphbkZvdXJ0aFRoaXNZZWFyPW5ldyBEYXRlKHRoaXNEYXRlLmdldEZ1bGxZZWFyKCksMCw0KTt2YXIgamFuRm91cnRoTmV4dFllYXI9bmV3IERhdGUodGhpc0RhdGUuZ2V0RnVsbFllYXIoKSsxLDAsNCk7dmFyIGZpcnN0V2Vla1N0YXJ0VGhpc1llYXI9Z2V0Rmlyc3RXZWVrU3RhcnREYXRlKGphbkZvdXJ0aFRoaXNZZWFyKTt2YXIgZmlyc3RXZWVrU3RhcnROZXh0WWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoTmV4dFllYXIpO2lmKGNvbXBhcmVCeURheShmaXJzdFdlZWtTdGFydFRoaXNZZWFyLHRoaXNEYXRlKTw9MCl7aWYoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0TmV4dFllYXIsdGhpc0RhdGUpPD0wKXtyZXR1cm4gdGhpc0RhdGUuZ2V0RnVsbFllYXIoKSsxfXJldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpfXJldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpLTF9dmFyIEVYUEFOU0lPTl9SVUxFU18yPXtcIiVhXCI6ZGF0ZT0+V0VFS0RBWVNbZGF0ZS50bV93ZGF5XS5zdWJzdHJpbmcoMCwzKSxcIiVBXCI6ZGF0ZT0+V0VFS0RBWVNbZGF0ZS50bV93ZGF5XSxcIiViXCI6ZGF0ZT0+TU9OVEhTW2RhdGUudG1fbW9uXS5zdWJzdHJpbmcoMCwzKSxcIiVCXCI6ZGF0ZT0+TU9OVEhTW2RhdGUudG1fbW9uXSxcIiVDXCI6ZGF0ZT0+e3ZhciB5ZWFyPWRhdGUudG1feWVhcisxOTAwO3JldHVybiBsZWFkaW5nTnVsbHMoeWVhci8xMDB8MCwyKX0sXCIlZFwiOmRhdGU9PmxlYWRpbmdOdWxscyhkYXRlLnRtX21kYXksMiksXCIlZVwiOmRhdGU9PmxlYWRpbmdTb21ldGhpbmcoZGF0ZS50bV9tZGF5LDIsXCIgXCIpLFwiJWdcIjpkYXRlPT5nZXRXZWVrQmFzZWRZZWFyKGRhdGUpLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJUdcIjpkYXRlPT5nZXRXZWVrQmFzZWRZZWFyKGRhdGUpLFwiJUhcIjpkYXRlPT5sZWFkaW5nTnVsbHMoZGF0ZS50bV9ob3VyLDIpLFwiJUlcIjpkYXRlPT57dmFyIHR3ZWx2ZUhvdXI9ZGF0ZS50bV9ob3VyO2lmKHR3ZWx2ZUhvdXI9PTApdHdlbHZlSG91cj0xMjtlbHNlIGlmKHR3ZWx2ZUhvdXI+MTIpdHdlbHZlSG91ci09MTI7cmV0dXJuIGxlYWRpbmdOdWxscyh0d2VsdmVIb3VyLDIpfSxcIiVqXCI6ZGF0ZT0+bGVhZGluZ051bGxzKGRhdGUudG1fbWRheSthcnJheVN1bShpc0xlYXBZZWFyKGRhdGUudG1feWVhcisxOTAwKT9NT05USF9EQVlTX0xFQVA6TU9OVEhfREFZU19SRUdVTEFSLGRhdGUudG1fbW9uLTEpLDMpLFwiJW1cIjpkYXRlPT5sZWFkaW5nTnVsbHMoZGF0ZS50bV9tb24rMSwyKSxcIiVNXCI6ZGF0ZT0+bGVhZGluZ051bGxzKGRhdGUudG1fbWluLDIpLFwiJW5cIjooKT0+XCJcXG5cIixcIiVwXCI6ZGF0ZT0+e2lmKGRhdGUudG1faG91cj49MCYmZGF0ZS50bV9ob3VyPDEyKXtyZXR1cm5cIkFNXCJ9cmV0dXJuXCJQTVwifSxcIiVTXCI6ZGF0ZT0+bGVhZGluZ051bGxzKGRhdGUudG1fc2VjLDIpLFwiJXRcIjooKT0+XCJcXHRcIixcIiV1XCI6ZGF0ZT0+ZGF0ZS50bV93ZGF5fHw3LFwiJVVcIjpkYXRlPT57dmFyIGRheXM9ZGF0ZS50bV95ZGF5KzctZGF0ZS50bV93ZGF5O3JldHVybiBsZWFkaW5nTnVsbHMoTWF0aC5mbG9vcihkYXlzLzcpLDIpfSxcIiVWXCI6ZGF0ZT0+e3ZhciB2YWw9TWF0aC5mbG9vcigoZGF0ZS50bV95ZGF5KzctKGRhdGUudG1fd2RheSs2KSU3KS83KTtpZigoZGF0ZS50bV93ZGF5KzM3MS1kYXRlLnRtX3lkYXktMiklNzw9Mil7dmFsKyt9aWYoIXZhbCl7dmFsPTUyO3ZhciBkZWMzMT0oZGF0ZS50bV93ZGF5KzctZGF0ZS50bV95ZGF5LTEpJTc7aWYoZGVjMzE9PTR8fGRlYzMxPT01JiZpc0xlYXBZZWFyKGRhdGUudG1feWVhciU0MDAtMSkpe3ZhbCsrfX1lbHNlIGlmKHZhbD09NTMpe3ZhciBqYW4xPShkYXRlLnRtX3dkYXkrMzcxLWRhdGUudG1feWRheSklNztpZihqYW4xIT00JiYoamFuMSE9M3x8IWlzTGVhcFllYXIoZGF0ZS50bV95ZWFyKSkpdmFsPTF9cmV0dXJuIGxlYWRpbmdOdWxscyh2YWwsMil9LFwiJXdcIjpkYXRlPT5kYXRlLnRtX3dkYXksXCIlV1wiOmRhdGU9Pnt2YXIgZGF5cz1kYXRlLnRtX3lkYXkrNy0oZGF0ZS50bV93ZGF5KzYpJTc7cmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmZsb29yKGRheXMvNyksMil9LFwiJXlcIjpkYXRlPT4oZGF0ZS50bV95ZWFyKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpLFwiJVlcIjpkYXRlPT5kYXRlLnRtX3llYXIrMTkwMCxcIiV6XCI6ZGF0ZT0+e3ZhciBvZmY9ZGF0ZS50bV9nbXRvZmY7dmFyIGFoZWFkPW9mZj49MDtvZmY9TWF0aC5hYnMob2ZmKS82MDtvZmY9b2ZmLzYwKjEwMCtvZmYlNjA7cmV0dXJuKGFoZWFkP1wiK1wiOlwiLVwiKStTdHJpbmcoXCIwMDAwXCIrb2ZmKS5zbGljZSgtNCl9LFwiJVpcIjpkYXRlPT5kYXRlLnRtX3pvbmUsXCIlJVwiOigpPT5cIiVcIn07cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UoLyUlL2csXCJcXDBcXDBcIik7Zm9yKHZhciBydWxlIGluIEVYUEFOU0lPTl9SVUxFU18yKXtpZihwYXR0ZXJuLmluY2x1ZGVzKHJ1bGUpKXtwYXR0ZXJuPXBhdHRlcm4ucmVwbGFjZShuZXcgUmVnRXhwKHJ1bGUsXCJnXCIpLEVYUEFOU0lPTl9SVUxFU18yW3J1bGVdKGRhdGUpKX19cGF0dGVybj1wYXR0ZXJuLnJlcGxhY2UoL1xcMFxcMC9nLFwiJVwiKTt2YXIgYnl0ZXM9aW50QXJyYXlGcm9tU3RyaW5nKHBhdHRlcm4sZmFsc2UpO2lmKGJ5dGVzLmxlbmd0aD5tYXhzaXplKXtyZXR1cm4gMH13cml0ZUFycmF5VG9NZW1vcnkoYnl0ZXMscyk7cmV0dXJuIGJ5dGVzLmxlbmd0aC0xfTt2YXIgX3N0cmZ0aW1lX2w9KHMsbWF4c2l6ZSxmb3JtYXQsdG0sbG9jKT0+X3N0cmZ0aW1lKHMsbWF4c2l6ZSxmb3JtYXQsdG0pO3ZhciBnZXRDRnVuYz1pZGVudD0+e3ZhciBmdW5jPU1vZHVsZVtcIl9cIitpZGVudF07cmV0dXJuIGZ1bmN9O3ZhciBzdHJpbmdUb1VURjhPblN0YWNrPXN0cj0+e3ZhciBzaXplPWxlbmd0aEJ5dGVzVVRGOChzdHIpKzE7dmFyIHJldD1zdGFja0FsbG9jKHNpemUpO3N0cmluZ1RvVVRGOChzdHIscmV0LHNpemUpO3JldHVybiByZXR9O3ZhciBjY2FsbD0oaWRlbnQscmV0dXJuVHlwZSxhcmdUeXBlcyxhcmdzLG9wdHMpPT57dmFyIHRvQz17XCJzdHJpbmdcIjpzdHI9Pnt2YXIgcmV0PTA7aWYoc3RyIT09bnVsbCYmc3RyIT09dW5kZWZpbmVkJiZzdHIhPT0wKXtyZXQ9c3RyaW5nVG9VVEY4T25TdGFjayhzdHIpfXJldHVybiByZXR9LFwiYXJyYXlcIjphcnI9Pnt2YXIgcmV0PXN0YWNrQWxsb2MoYXJyLmxlbmd0aCk7d3JpdGVBcnJheVRvTWVtb3J5KGFycixyZXQpO3JldHVybiByZXR9fTtmdW5jdGlvbiBjb252ZXJ0UmV0dXJuVmFsdWUocmV0KXtpZihyZXR1cm5UeXBlPT09XCJzdHJpbmdcIil7cmV0dXJuIFVURjhUb1N0cmluZyhyZXQpfWlmKHJldHVyblR5cGU9PT1cImJvb2xlYW5cIilyZXR1cm4gQm9vbGVhbihyZXQpO3JldHVybiByZXR9dmFyIGZ1bmM9Z2V0Q0Z1bmMoaWRlbnQpO3ZhciBjQXJncz1bXTt2YXIgc3RhY2s9MDtpZihhcmdzKXtmb3IodmFyIGk9MDtpPGFyZ3MubGVuZ3RoO2krKyl7dmFyIGNvbnZlcnRlcj10b0NbYXJnVHlwZXNbaV1dO2lmKGNvbnZlcnRlcil7aWYoc3RhY2s9PT0wKXN0YWNrPXN0YWNrU2F2ZSgpO2NBcmdzW2ldPWNvbnZlcnRlcihhcmdzW2ldKX1lbHNle2NBcmdzW2ldPWFyZ3NbaV19fX12YXIgcmV0PWZ1bmMuYXBwbHkobnVsbCxjQXJncyk7ZnVuY3Rpb24gb25Eb25lKHJldCl7aWYoc3RhY2shPT0wKXN0YWNrUmVzdG9yZShzdGFjayk7cmV0dXJuIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpfXJldD1vbkRvbmUocmV0KTtyZXR1cm4gcmV0fTtJbnRlcm5hbEVycm9yPU1vZHVsZVtcIkludGVybmFsRXJyb3JcIl09Y2xhc3MgSW50ZXJuYWxFcnJvciBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKG1lc3NhZ2Upe3N1cGVyKG1lc3NhZ2UpO3RoaXMubmFtZT1cIkludGVybmFsRXJyb3JcIn19O2VtYmluZF9pbml0X2NoYXJDb2RlcygpO0JpbmRpbmdFcnJvcj1Nb2R1bGVbXCJCaW5kaW5nRXJyb3JcIl09Y2xhc3MgQmluZGluZ0Vycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobWVzc2FnZSl7c3VwZXIobWVzc2FnZSk7dGhpcy5uYW1lPVwiQmluZGluZ0Vycm9yXCJ9fTtpbml0X0NsYXNzSGFuZGxlKCk7aW5pdF9lbWJpbmQoKTtpbml0X1JlZ2lzdGVyZWRQb2ludGVyKCk7VW5ib3VuZFR5cGVFcnJvcj1Nb2R1bGVbXCJVbmJvdW5kVHlwZUVycm9yXCJdPWV4dGVuZEVycm9yKEVycm9yLFwiVW5ib3VuZFR5cGVFcnJvclwiKTtoYW5kbGVBbGxvY2F0b3JJbml0KCk7aW5pdF9lbXZhbCgpO3ZhciBGU05vZGU9ZnVuY3Rpb24ocGFyZW50LG5hbWUsbW9kZSxyZGV2KXtpZighcGFyZW50KXtwYXJlbnQ9dGhpc310aGlzLnBhcmVudD1wYXJlbnQ7dGhpcy5tb3VudD1wYXJlbnQubW91bnQ7dGhpcy5tb3VudGVkPW51bGw7dGhpcy5pZD1GUy5uZXh0SW5vZGUrKzt0aGlzLm5hbWU9bmFtZTt0aGlzLm1vZGU9bW9kZTt0aGlzLm5vZGVfb3BzPXt9O3RoaXMuc3RyZWFtX29wcz17fTt0aGlzLnJkZXY9cmRldn07dmFyIHJlYWRNb2RlPTI5Mnw3Mzt2YXIgd3JpdGVNb2RlPTE0NjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGU05vZGUucHJvdG90eXBlLHtyZWFkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5tb2RlJnJlYWRNb2RlKT09PXJlYWRNb2RlfSxzZXQ6ZnVuY3Rpb24odmFsKXt2YWw/dGhpcy5tb2RlfD1yZWFkTW9kZTp0aGlzLm1vZGUmPX5yZWFkTW9kZX19LHdyaXRlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4odGhpcy5tb2RlJndyaXRlTW9kZSk9PT13cml0ZU1vZGV9LHNldDpmdW5jdGlvbih2YWwpe3ZhbD90aGlzLm1vZGV8PXdyaXRlTW9kZTp0aGlzLm1vZGUmPX53cml0ZU1vZGV9fSxpc0ZvbGRlcjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEZTLmlzRGlyKHRoaXMubW9kZSl9fSxpc0RldmljZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEZTLmlzQ2hyZGV2KHRoaXMubW9kZSl9fX0pO0ZTLkZTTm9kZT1GU05vZGU7RlMuY3JlYXRlUHJlbG9hZGVkRmlsZT1GU19jcmVhdGVQcmVsb2FkZWRGaWxlO0ZTLnN0YXRpY0luaXQoKTt2YXIgd2FzbUltcG9ydHM9e2Q6X19fY3hhX3Rocm93LG46X19lbWJpbmRfZmluYWxpemVfdmFsdWVfYXJyYXksbDpfX2VtYmluZF9maW5hbGl6ZV92YWx1ZV9vYmplY3QsdzpfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQsRzpfX2VtYmluZF9yZWdpc3Rlcl9ib29sLGg6X19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MsZzpfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcixjOl9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uLHE6X19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfcHJvcGVydHksRjpfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCxwOl9fZW1iaW5kX3JlZ2lzdGVyX2VudW0saTpfX2VtYmluZF9yZWdpc3Rlcl9lbnVtX3ZhbHVlLHQ6X19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQsYTpfX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbixqOl9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIsZTpfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldyx1Ol9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcscjpfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZyxvOl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX2FycmF5LGI6X19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfYXJyYXlfZWxlbWVudCxtOl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdCxmOl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX29iamVjdF9maWVsZCxIOl9fZW1iaW5kX3JlZ2lzdGVyX3ZvaWQsSTpfX2VtdmFsX2RlY3JlZixKOl9fZW12YWxfaW5jcmVmLGs6X19lbXZhbF90YWtlX3ZhbHVlLHM6X2Fib3J0LEU6X2Vtc2NyaXB0ZW5fbWVtY3B5X2pzLHk6X2Vtc2NyaXB0ZW5fcmVzaXplX2hlYXAsejpfZW52aXJvbl9nZXQsQTpfZW52aXJvbl9zaXplc19nZXQsQjpfZmRfY2xvc2UsRDpfZmRfcmVhZCx2Ol9mZF9zZWVrLEM6X2ZkX3dyaXRlLHg6X3N0cmZ0aW1lX2x9O3ZhciB3YXNtRXhwb3J0cz1jcmVhdGVXYXNtKCk7dmFyIF9fX3dhc21fY2FsbF9jdG9ycz0oKT0+KF9fX3dhc21fY2FsbF9jdG9ycz13YXNtRXhwb3J0c1tcIkxcIl0pKCk7dmFyIF9tYWxsb2M9TW9kdWxlW1wiX21hbGxvY1wiXT1hMD0+KF9tYWxsb2M9TW9kdWxlW1wiX21hbGxvY1wiXT13YXNtRXhwb3J0c1tcIk1cIl0pKGEwKTt2YXIgX2ZyZWU9TW9kdWxlW1wiX2ZyZWVcIl09YTA9PihfZnJlZT1Nb2R1bGVbXCJfZnJlZVwiXT13YXNtRXhwb3J0c1tcIk5cIl0pKGEwKTt2YXIgX19fZ2V0VHlwZU5hbWU9YTA9PihfX19nZXRUeXBlTmFtZT13YXNtRXhwb3J0c1tcIlBcIl0pKGEwKTt2YXIgX19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncz1Nb2R1bGVbXCJfX2VtYmluZF9pbml0aWFsaXplX2JpbmRpbmdzXCJdPSgpPT4oX19lbWJpbmRfaW5pdGlhbGl6ZV9iaW5kaW5ncz1Nb2R1bGVbXCJfX2VtYmluZF9pbml0aWFsaXplX2JpbmRpbmdzXCJdPXdhc21FeHBvcnRzW1wiUVwiXSkoKTt2YXIgX19fZXJybm9fbG9jYXRpb249KCk9PihfX19lcnJub19sb2NhdGlvbj13YXNtRXhwb3J0c1tcIl9fZXJybm9fbG9jYXRpb25cIl0pKCk7dmFyIHN0YWNrU2F2ZT0oKT0+KHN0YWNrU2F2ZT13YXNtRXhwb3J0c1tcIlJcIl0pKCk7dmFyIHN0YWNrUmVzdG9yZT1hMD0+KHN0YWNrUmVzdG9yZT13YXNtRXhwb3J0c1tcIlNcIl0pKGEwKTt2YXIgc3RhY2tBbGxvYz1hMD0+KHN0YWNrQWxsb2M9d2FzbUV4cG9ydHNbXCJUXCJdKShhMCk7dmFyIF9fX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50PWEwPT4oX19fY3hhX2luY3JlbWVudF9leGNlcHRpb25fcmVmY291bnQ9d2FzbUV4cG9ydHNbXCJfX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50XCJdKShhMCk7dmFyIF9fX2N4YV9pc19wb2ludGVyX3R5cGU9YTA9PihfX19jeGFfaXNfcG9pbnRlcl90eXBlPXdhc21FeHBvcnRzW1wiVVwiXSkoYTApO3ZhciBkeW5DYWxsX2ppamk9TW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdPShhMCxhMSxhMixhMyxhNCk9PihkeW5DYWxsX2ppamk9TW9kdWxlW1wiZHluQ2FsbF9qaWppXCJdPXdhc21FeHBvcnRzW1wiVlwiXSkoYTAsYTEsYTIsYTMsYTQpO3ZhciBkeW5DYWxsX3ZpaWppaT1Nb2R1bGVbXCJkeW5DYWxsX3ZpaWppaVwiXT0oYTAsYTEsYTIsYTMsYTQsYTUsYTYpPT4oZHluQ2FsbF92aWlqaWk9TW9kdWxlW1wiZHluQ2FsbF92aWlqaWlcIl09d2FzbUV4cG9ydHNbXCJXXCJdKShhMCxhMSxhMixhMyxhNCxhNSxhNik7dmFyIGR5bkNhbGxfaWlpaWlqPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlqXCJdPShhMCxhMSxhMixhMyxhNCxhNSxhNik9PihkeW5DYWxsX2lpaWlpaj1Nb2R1bGVbXCJkeW5DYWxsX2lpaWlpalwiXT13YXNtRXhwb3J0c1tcIlhcIl0pKGEwLGExLGEyLGEzLGE0LGE1LGE2KTt2YXIgZHluQ2FsbF9paWlpaWpqPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlqalwiXT0oYTAsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgpPT4oZHluQ2FsbF9paWlpaWpqPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlqalwiXT13YXNtRXhwb3J0c1tcIllcIl0pKGEwLGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4KTt2YXIgZHluQ2FsbF9paWlpaWlqaj1Nb2R1bGVbXCJkeW5DYWxsX2lpaWlpaWpqXCJdPShhMCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSk9PihkeW5DYWxsX2lpaWlpaWpqPU1vZHVsZVtcImR5bkNhbGxfaWlpaWlpampcIl09d2FzbUV4cG9ydHNbXCJaXCJdKShhMCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCxhOSk7TW9kdWxlW1wiY2NhbGxcIl09Y2NhbGw7dmFyIGNhbGxlZFJ1bjtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9ZnVuY3Rpb24gcnVuQ2FsbGVyKCl7aWYoIWNhbGxlZFJ1bilydW4oKTtpZighY2FsbGVkUnVuKWRlcGVuZGVuY2llc0Z1bGZpbGxlZD1ydW5DYWxsZXJ9O2Z1bmN0aW9uIHJ1bigpe2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59cHJlUnVuKCk7aWYocnVuRGVwZW5kZW5jaWVzPjApe3JldHVybn1mdW5jdGlvbiBkb1J1bigpe2lmKGNhbGxlZFJ1bilyZXR1cm47Y2FsbGVkUnVuPXRydWU7TW9kdWxlW1wiY2FsbGVkUnVuXCJdPXRydWU7aWYoQUJPUlQpcmV0dXJuO2luaXRSdW50aW1lKCk7cmVhZHlQcm9taXNlUmVzb2x2ZShNb2R1bGUpO2lmKE1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKU1vZHVsZVtcIm9uUnVudGltZUluaXRpYWxpemVkXCJdKCk7cG9zdFJ1bigpfWlmKE1vZHVsZVtcInNldFN0YXR1c1wiXSl7TW9kdWxlW1wic2V0U3RhdHVzXCJdKFwiUnVubmluZy4uLlwiKTtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlwiKX0sMSk7ZG9SdW4oKX0sMSl9ZWxzZXtkb1J1bigpfX1pZihNb2R1bGVbXCJwcmVJbml0XCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicHJlSW5pdFwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInByZUluaXRcIl09W01vZHVsZVtcInByZUluaXRcIl1dO3doaWxlKE1vZHVsZVtcInByZUluaXRcIl0ubGVuZ3RoPjApe01vZHVsZVtcInByZUluaXRcIl0ucG9wKCkoKX19cnVuKCk7XG5cblxuICByZXR1cm4gbW9kdWxlQXJnLnJlYWR5XG59XG5cbik7XG59KSgpO1xuZXhwb3J0IGRlZmF1bHQgTW9kdWxlOyJdLCJuYW1lcyI6WyJNb2R1bGUiLCJfc2NyaXB0RGlyIiwiZG9jdW1lbnQiLCJjdXJyZW50U2NyaXB0Iiwic3JjIiwidW5kZWZpbmVkIiwibW9kdWxlQXJnIiwicmVhZHlQcm9taXNlUmVzb2x2ZSIsInJlYWR5UHJvbWlzZVJlamVjdCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwibW9kdWxlT3ZlcnJpZGVzIiwiT2JqZWN0IiwiYXNzaWduIiwiYXJndW1lbnRzXyIsInRoaXNQcm9ncmFtIiwicXVpdF8iLCJzdGF0dXMiLCJ0b1Rocm93IiwiRU5WSVJPTk1FTlRfSVNfV0VCIiwiRU5WSVJPTk1FTlRfSVNfV09SS0VSIiwic2NyaXB0RGlyZWN0b3J5IiwibG9jYXRlRmlsZSIsInBhdGgiLCJyZWFkXyIsInJlYWRBc3luYyIsInJlYWRCaW5hcnkiLCJzZWxmIiwibG9jYXRpb24iLCJocmVmIiwiaW5kZXhPZiIsInN1YnN0ciIsInJlcGxhY2UiLCJsYXN0SW5kZXhPZiIsInVybCIsInhociIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNlbmQiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZVR5cGUiLCJVaW50OEFycmF5IiwicmVzcG9uc2UiLCJvbmxvYWQiLCJvbmVycm9yIiwib3V0IiwiY29uc29sZSIsImxvZyIsImJpbmQiLCJlcnIiLCJlcnJvciIsIndhc21CaW5hcnkiLCJub0V4aXRSdW50aW1lIiwiV2ViQXNzZW1ibHkiLCJhYm9ydCIsIndhc21NZW1vcnkiLCJBQk9SVCIsIkVYSVRTVEFUVVMiLCJhc3NlcnQiLCJjb25kaXRpb24iLCJ0ZXh0IiwiSEVBUDgiLCJIRUFQVTgiLCJIRUFQMTYiLCJIRUFQVTE2IiwiSEVBUDMyIiwiSEVBUFUzMiIsIkhFQVBGMzIiLCJIRUFQRjY0IiwidXBkYXRlTWVtb3J5Vmlld3MiLCJiIiwiYnVmZmVyIiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIlVpbnQxNkFycmF5IiwiSW50MzJBcnJheSIsIlVpbnQzMkFycmF5IiwiRmxvYXQzMkFycmF5IiwiRmxvYXQ2NEFycmF5IiwiX19BVFBSRVJVTl9fIiwiX19BVElOSVRfXyIsIl9fQVRQT1NUUlVOX18iLCJydW50aW1lSW5pdGlhbGl6ZWQiLCJwcmVSdW4iLCJsZW5ndGgiLCJhZGRPblByZVJ1biIsInNoaWZ0IiwiY2FsbFJ1bnRpbWVDYWxsYmFja3MiLCJpbml0UnVudGltZSIsIkZTIiwiaW5pdCIsImluaXRpYWxpemVkIiwiaWdub3JlUGVybWlzc2lvbnMiLCJUVFkiLCJwb3N0UnVuIiwiYWRkT25Qb3N0UnVuIiwiY2IiLCJ1bnNoaWZ0IiwiYWRkT25Jbml0IiwicnVuRGVwZW5kZW5jaWVzIiwicnVuRGVwZW5kZW5jeVdhdGNoZXIiLCJkZXBlbmRlbmNpZXNGdWxmaWxsZWQiLCJnZXRVbmlxdWVSdW5EZXBlbmRlbmN5IiwiaWQiLCJhZGRSdW5EZXBlbmRlbmN5IiwicmVtb3ZlUnVuRGVwZW5kZW5jeSIsImNsZWFySW50ZXJ2YWwiLCJjYWxsYmFjayIsIndoYXQiLCJlIiwiUnVudGltZUVycm9yIiwiZGF0YVVSSVByZWZpeCIsImlzRGF0YVVSSSIsImZpbGVuYW1lIiwic3RhcnRzV2l0aCIsIndhc21CaW5hcnlGaWxlIiwiZ2V0QmluYXJ5U3luYyIsImZpbGUiLCJnZXRCaW5hcnlQcm9taXNlIiwiYmluYXJ5RmlsZSIsImZldGNoIiwiY3JlZGVudGlhbHMiLCJ0aGVuIiwiY2F0Y2giLCJpbnN0YW50aWF0ZUFycmF5QnVmZmVyIiwiaW1wb3J0cyIsInJlY2VpdmVyIiwiYmluYXJ5IiwiaW5zdGFudGlhdGUiLCJpbnN0YW5jZSIsInJlYXNvbiIsImluc3RhbnRpYXRlQXN5bmMiLCJpbnN0YW50aWF0ZVN0cmVhbWluZyIsInJlc3VsdCIsImNyZWF0ZVdhc20iLCJpbmZvIiwid2FzbUltcG9ydHMiLCJyZWNlaXZlSW5zdGFuY2UiLCJtb2R1bGUiLCJ3YXNtRXhwb3J0cyIsImV4cG9ydHMiLCJ3YXNtVGFibGUiLCJyZWNlaXZlSW5zdGFudGlhdGlvblJlc3VsdCIsInRlbXBEb3VibGUiLCJ0ZW1wSTY0IiwiY2FsbGJhY2tzIiwiRXhjZXB0aW9uSW5mbyIsImV4Y1B0ciIsInB0ciIsInNldF90eXBlIiwidHlwZSIsImdldF90eXBlIiwic2V0X2Rlc3RydWN0b3IiLCJkZXN0cnVjdG9yIiwiZ2V0X2Rlc3RydWN0b3IiLCJzZXRfY2F1Z2h0IiwiY2F1Z2h0IiwiZ2V0X2NhdWdodCIsInNldF9yZXRocm93biIsInJldGhyb3duIiwiZ2V0X3JldGhyb3duIiwic2V0X2FkanVzdGVkX3B0ciIsImFkanVzdGVkUHRyIiwiZ2V0X2FkanVzdGVkX3B0ciIsImdldF9leGNlcHRpb25fcHRyIiwiaXNQb2ludGVyIiwiX19fY3hhX2lzX3BvaW50ZXJfdHlwZSIsImFkanVzdGVkIiwiZXhjZXB0aW9uTGFzdCIsInVuY2F1Z2h0RXhjZXB0aW9uQ291bnQiLCJfX19jeGFfdGhyb3ciLCJ0dXBsZVJlZ2lzdHJhdGlvbnMiLCJydW5EZXN0cnVjdG9ycyIsImRlc3RydWN0b3JzIiwicG9wIiwiZGVsIiwic2ltcGxlUmVhZFZhbHVlRnJvbVBvaW50ZXIiLCJwb2ludGVyIiwiYXdhaXRpbmdEZXBlbmRlbmNpZXMiLCJyZWdpc3RlcmVkVHlwZXMiLCJ0eXBlRGVwZW5kZW5jaWVzIiwiSW50ZXJuYWxFcnJvciIsInRocm93SW50ZXJuYWxFcnJvciIsIm1lc3NhZ2UiLCJ3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZCIsIm15VHlwZXMiLCJkZXBlbmRlbnRUeXBlcyIsImdldFR5cGVDb252ZXJ0ZXJzIiwiZm9yRWFjaCIsIm9uQ29tcGxldGUiLCJ0eXBlQ29udmVydGVycyIsIm15VHlwZUNvbnZlcnRlcnMiLCJpIiwicmVnaXN0ZXJUeXBlIiwiQXJyYXkiLCJ1bnJlZ2lzdGVyZWRUeXBlcyIsInJlZ2lzdGVyZWQiLCJkdCIsImhhc093blByb3BlcnR5IiwicHVzaCIsIl9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX2FycmF5IiwicmF3VHVwbGVUeXBlIiwicmVnIiwiZWxlbWVudHMiLCJlbGVtZW50c0xlbmd0aCIsImVsZW1lbnRUeXBlcyIsIm1hcCIsImVsdCIsImdldHRlclJldHVyblR5cGUiLCJjb25jYXQiLCJzZXR0ZXJBcmd1bWVudFR5cGUiLCJyYXdDb25zdHJ1Y3RvciIsInJhd0Rlc3RydWN0b3IiLCJnZXR0ZXIiLCJnZXR0ZXJDb250ZXh0Iiwic2V0dGVyIiwic2V0dGVyQ29udGV4dCIsInJlYWQiLCJ3cml0ZSIsIm8iLCJuYW1lIiwicnYiLCJUeXBlRXJyb3IiLCJHZW5lcmljV2lyZVR5cGVTaXplIiwiZGVzdHJ1Y3RvckZ1bmN0aW9uIiwic3RydWN0UmVnaXN0cmF0aW9ucyIsIl9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX29iamVjdCIsInN0cnVjdFR5cGUiLCJmaWVsZFJlY29yZHMiLCJmaWVsZHMiLCJmaWVsZFR5cGVzIiwiZmllbGQiLCJmaWVsZE5hbWUiLCJfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQiLCJwcmltaXRpdmVUeXBlIiwic2l6ZSIsIm1pblJhbmdlIiwibWF4UmFuZ2UiLCJlbWJpbmRfaW5pdF9jaGFyQ29kZXMiLCJjb2RlcyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImVtYmluZF9jaGFyQ29kZXMiLCJyZWFkTGF0aW4xU3RyaW5nIiwicmV0IiwiYyIsIkJpbmRpbmdFcnJvciIsInRocm93QmluZGluZ0Vycm9yIiwic2hhcmVkUmVnaXN0ZXJUeXBlIiwicmF3VHlwZSIsInJlZ2lzdGVyZWRJbnN0YW5jZSIsIm9wdGlvbnMiLCJpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zIiwiX19lbWJpbmRfcmVnaXN0ZXJfYm9vbCIsInRydWVWYWx1ZSIsImZhbHNlVmFsdWUiLCJ3dCIsInNoYWxsb3dDb3B5SW50ZXJuYWxQb2ludGVyIiwiY291bnQiLCJkZWxldGVTY2hlZHVsZWQiLCJwcmVzZXJ2ZVBvaW50ZXJPbkRlbGV0ZSIsInB0clR5cGUiLCJzbWFydFB0ciIsInNtYXJ0UHRyVHlwZSIsInRocm93SW5zdGFuY2VBbHJlYWR5RGVsZXRlZCIsIm9iaiIsImdldEluc3RhbmNlVHlwZU5hbWUiLCJoYW5kbGUiLCIkJCIsInJlZ2lzdGVyZWRDbGFzcyIsImZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiZGV0YWNoRmluYWxpemVyIiwicnVuRGVzdHJ1Y3RvciIsInJlbGVhc2VDbGFzc0hhbmRsZSIsInZhbHVlIiwidG9EZWxldGUiLCJkb3duY2FzdFBvaW50ZXIiLCJwdHJDbGFzcyIsImRlc2lyZWRDbGFzcyIsImJhc2VDbGFzcyIsImRvd25jYXN0IiwicmVnaXN0ZXJlZFBvaW50ZXJzIiwiZ2V0SW5oZXJpdGVkSW5zdGFuY2VDb3VudCIsImtleXMiLCJyZWdpc3RlcmVkSW5zdGFuY2VzIiwiZ2V0TGl2ZUluaGVyaXRlZEluc3RhbmNlcyIsImsiLCJkZWxldGlvblF1ZXVlIiwiZmx1c2hQZW5kaW5nRGVsZXRlcyIsImRlbGF5RnVuY3Rpb24iLCJzZXREZWxheUZ1bmN0aW9uIiwiZm4iLCJpbml0X2VtYmluZCIsImdldEJhc2VzdFBvaW50ZXIiLCJjbGFzc18iLCJ1cGNhc3QiLCJnZXRJbmhlcml0ZWRJbnN0YW5jZSIsIm1ha2VDbGFzc0hhbmRsZSIsInByb3RvdHlwZSIsInJlY29yZCIsImhhc1NtYXJ0UHRyVHlwZSIsImhhc1NtYXJ0UHRyIiwiYXR0YWNoRmluYWxpemVyIiwiY3JlYXRlIiwiUmVnaXN0ZXJlZFBvaW50ZXJfZnJvbVdpcmVUeXBlIiwicmF3UG9pbnRlciIsImdldFBvaW50ZWUiLCJtYWtlRGVmYXVsdEhhbmRsZSIsImlzU21hcnRQb2ludGVyIiwiaW5zdGFuY2VQcm90b3R5cGUiLCJwb2ludGVlVHlwZSIsImFjdHVhbFR5cGUiLCJnZXRBY3R1YWxUeXBlIiwicmVnaXN0ZXJlZFBvaW50ZXJSZWNvcmQiLCJjYWxsIiwidG9UeXBlIiwiaXNDb25zdCIsImNvbnN0UG9pbnRlclR5cGUiLCJwb2ludGVyVHlwZSIsImRwIiwiRmluYWxpemF0aW9uUmVnaXN0cnkiLCJyZWdpc3RlciIsInVucmVnaXN0ZXIiLCJpbml0X0NsYXNzSGFuZGxlIiwiQ2xhc3NIYW5kbGUiLCJvdGhlciIsImxlZnRDbGFzcyIsImxlZnQiLCJyaWdodENsYXNzIiwicmlnaHQiLCJjbG9uZSIsImdldFByb3RvdHlwZU9mIiwiY2hhcl8wIiwiY2hhcl85IiwibWFrZUxlZ2FsRnVuY3Rpb25OYW1lIiwiZiIsImNoYXJDb2RlQXQiLCJjcmVhdGVOYW1lZEZ1bmN0aW9uIiwiYm9keSIsImFwcGx5IiwiYXJndW1lbnRzIiwiZW5zdXJlT3ZlcmxvYWRUYWJsZSIsInByb3RvIiwibWV0aG9kTmFtZSIsImh1bWFuTmFtZSIsIm92ZXJsb2FkVGFibGUiLCJwcmV2RnVuYyIsImFyZ0NvdW50IiwiZXhwb3NlUHVibGljU3ltYm9sIiwibnVtQXJndW1lbnRzIiwiUmVnaXN0ZXJlZENsYXNzIiwiY29uc3RydWN0b3IiLCJwdXJlVmlydHVhbEZ1bmN0aW9ucyIsInVwY2FzdFBvaW50ZXIiLCJjb25zdE5vU21hcnRQdHJSYXdQb2ludGVyVG9XaXJlVHlwZSIsImlzUmVmZXJlbmNlIiwiZW1iaW5kUmVwciIsImhhbmRsZUNsYXNzIiwiZ2VuZXJpY1BvaW50ZXJUb1dpcmVUeXBlIiwic2hhcmluZ1BvbGljeSIsImNsb25lZEhhbmRsZSIsInJhd1NoYXJlIiwiRW12YWwiLCJ0b0hhbmRsZSIsIm5vbkNvbnN0Tm9TbWFydFB0clJhd1BvaW50ZXJUb1dpcmVUeXBlIiwicmVhZFBvaW50ZXIiLCJpbml0X1JlZ2lzdGVyZWRQb2ludGVyIiwiUmVnaXN0ZXJlZFBvaW50ZXIiLCJyYXdHZXRQb2ludGVlIiwicmVwbGFjZVB1YmxpY1N5bWJvbCIsImR5bkNhbGxMZWdhY3kiLCJzaWciLCJhcmdzIiwid2FzbVRhYmxlTWlycm9yIiwiZ2V0V2FzbVRhYmxlRW50cnkiLCJmdW5jUHRyIiwiZnVuYyIsImdldCIsImR5bkNhbGwiLCJpbmNsdWRlcyIsInJ0biIsImdldER5bkNhbGxlciIsImFyZ0NhY2hlIiwiZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24iLCJzaWduYXR1cmUiLCJyYXdGdW5jdGlvbiIsIm1ha2VEeW5DYWxsZXIiLCJmcCIsImV4dGVuZEVycm9yIiwiYmFzZUVycm9yVHlwZSIsImVycm9yTmFtZSIsImVycm9yQ2xhc3MiLCJzdGFjayIsIkVycm9yIiwidG9TdHJpbmciLCJVbmJvdW5kVHlwZUVycm9yIiwiZ2V0VHlwZU5hbWUiLCJfX19nZXRUeXBlTmFtZSIsIl9mcmVlIiwidGhyb3dVbmJvdW5kVHlwZUVycm9yIiwidHlwZXMiLCJ1bmJvdW5kVHlwZXMiLCJzZWVuIiwidmlzaXQiLCJqb2luIiwiX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3MiLCJyYXdQb2ludGVyVHlwZSIsInJhd0NvbnN0UG9pbnRlclR5cGUiLCJiYXNlQ2xhc3NSYXdUeXBlIiwiZ2V0QWN0dWFsVHlwZVNpZ25hdHVyZSIsInVwY2FzdFNpZ25hdHVyZSIsImRvd25jYXN0U2lnbmF0dXJlIiwiZGVzdHJ1Y3RvclNpZ25hdHVyZSIsImxlZ2FsRnVuY3Rpb25OYW1lIiwiYmFzZSIsImJhc2VQcm90b3R5cGUiLCJjb25zdHJ1Y3Rvcl9ib2R5IiwiX19kZXJpdmVkQ2xhc3NlcyIsInJlZmVyZW5jZUNvbnZlcnRlciIsInBvaW50ZXJDb252ZXJ0ZXIiLCJjb25zdFBvaW50ZXJDb252ZXJ0ZXIiLCJoZWFwMzJWZWN0b3JUb0FycmF5IiwiZmlyc3RFbGVtZW50IiwiYXJyYXkiLCJuZXdGdW5jIiwiYXJndW1lbnRMaXN0IiwiRnVuY3Rpb24iLCJkdW1teSIsInIiLCJjcmFmdEludm9rZXJGdW5jdGlvbiIsImFyZ1R5cGVzIiwiY2xhc3NUeXBlIiwiY3BwSW52b2tlckZ1bmMiLCJjcHBUYXJnZXRGdW5jIiwiaXNBc3luYyIsImlzQ2xhc3NNZXRob2RGdW5jIiwibmVlZHNEZXN0cnVjdG9yU3RhY2siLCJyZXR1cm5zIiwiYXJnc0xpc3QiLCJhcmdzTGlzdFdpcmVkIiwiaW52b2tlckZuQm9keSIsImR0b3JTdGFjayIsImFyZ3MxIiwiYXJnczIiLCJwYXJhbU5hbWUiLCJfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvciIsInJhd0NsYXNzVHlwZSIsInJhd0FyZ1R5cGVzQWRkciIsImludm9rZXJTaWduYXR1cmUiLCJpbnZva2VyIiwicmF3QXJnVHlwZXMiLCJzcGxpY2UiLCJfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbiIsInJhd0ludm9rZXIiLCJjb250ZXh0IiwiaXNQdXJlVmlydHVhbCIsIlN5bWJvbCIsInN1YnN0cmluZyIsInVuYm91bmRUeXBlc0hhbmRsZXIiLCJtZXRob2QiLCJjbGFzc05hbWUiLCJtZW1iZXJGdW5jdGlvbiIsInZhbGlkYXRlVGhpcyIsInRoaXNfIiwiX19lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfcHJvcGVydHkiLCJnZXR0ZXJTaWduYXR1cmUiLCJzZXR0ZXJTaWduYXR1cmUiLCJkZXNjIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldCIsInYiLCJkZWZpbmVQcm9wZXJ0eSIsImhhbmRsZUFsbG9jYXRvckluaXQiLCJIYW5kbGVBbGxvY2F0b3IiLCJhbGxvY2F0ZWQiLCJoYXMiLCJhbGxvY2F0ZSIsImZyZWVsaXN0IiwiZnJlZSIsImVtdmFsX2hhbmRsZXMiLCJfX2VtdmFsX2RlY3JlZiIsInJlc2VydmVkIiwicmVmY291bnQiLCJjb3VudF9lbXZhbF9oYW5kbGVzIiwiaW5pdF9lbXZhbCIsInRvVmFsdWUiLCJfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbCIsImVudW1SZWFkVmFsdWVGcm9tUG9pbnRlciIsIndpZHRoIiwic2lnbmVkIiwiX19lbWJpbmRfcmVnaXN0ZXJfZW51bSIsImlzU2lnbmVkIiwiY3RvciIsInZhbHVlcyIsInJlcXVpcmVSZWdpc3RlcmVkVHlwZSIsImltcGwiLCJfX2VtYmluZF9yZWdpc3Rlcl9lbnVtX3ZhbHVlIiwicmF3RW51bVR5cGUiLCJlbnVtVmFsdWUiLCJlbnVtVHlwZSIsIkVudW0iLCJWYWx1ZSIsInQiLCJmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyIiwiX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQiLCJfX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbiIsImludm9rZXJBcmdzQXJyYXkiLCJzbGljZSIsImludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlciIsIl9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIiLCJmcm9tV2lyZVR5cGUiLCJiaXRzaGlmdCIsImlzVW5zaWduZWRUeXBlIiwiY2hlY2tBc3NlcnRpb25zIiwidG9UeXBlTmFtZSIsInRvV2lyZVR5cGUiLCJfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldyIsImRhdGFUeXBlSW5kZXgiLCJ0eXBlTWFwcGluZyIsIlRBIiwiZGVjb2RlTWVtb3J5VmlldyIsImRhdGEiLCJzdHJpbmdUb1VURjhBcnJheSIsInN0ciIsImhlYXAiLCJvdXRJZHgiLCJtYXhCeXRlc1RvV3JpdGUiLCJzdGFydElkeCIsImVuZElkeCIsInUiLCJ1MSIsInN0cmluZ1RvVVRGOCIsIm91dFB0ciIsImxlbmd0aEJ5dGVzVVRGOCIsImxlbiIsIlVURjhEZWNvZGVyIiwiVGV4dERlY29kZXIiLCJVVEY4QXJyYXlUb1N0cmluZyIsImhlYXBPckFycmF5IiwiaWR4IiwibWF4Qnl0ZXNUb1JlYWQiLCJlbmRQdHIiLCJkZWNvZGUiLCJzdWJhcnJheSIsInUwIiwidTIiLCJjaCIsIlVURjhUb1N0cmluZyIsIl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmciLCJzdGRTdHJpbmdJc1VURjgiLCJwYXlsb2FkIiwiZGVjb2RlU3RhcnRQdHIiLCJjdXJyZW50Qnl0ZVB0ciIsIm1heFJlYWQiLCJzdHJpbmdTZWdtZW50IiwiYSIsIkFycmF5QnVmZmVyIiwidmFsdWVJc09mVHlwZVN0cmluZyIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiX21hbGxvYyIsImNoYXJDb2RlIiwiVVRGMTZEZWNvZGVyIiwiVVRGMTZUb1N0cmluZyIsIm1heElkeCIsImNvZGVVbml0Iiwic3RyaW5nVG9VVEYxNiIsInN0YXJ0UHRyIiwibnVtQ2hhcnNUb1dyaXRlIiwibGVuZ3RoQnl0ZXNVVEYxNiIsIlVURjMyVG9TdHJpbmciLCJ1dGYzMiIsInN0cmluZ1RvVVRGMzIiLCJ0cmFpbFN1cnJvZ2F0ZSIsImxlbmd0aEJ5dGVzVVRGMzIiLCJfX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZyIsImNoYXJTaXplIiwiZGVjb2RlU3RyaW5nIiwiZW5jb2RlU3RyaW5nIiwiZ2V0SGVhcCIsImxlbmd0aEJ5dGVzVVRGIiwiSEVBUCIsIm1heFJlYWRCeXRlcyIsIl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX2FycmF5IiwiY29uc3RydWN0b3JTaWduYXR1cmUiLCJfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9hcnJheV9lbGVtZW50IiwiX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0IiwiX19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfb2JqZWN0X2ZpZWxkIiwiX19lbWJpbmRfcmVnaXN0ZXJfdm9pZCIsImlzVm9pZCIsIl9fZW12YWxfaW5jcmVmIiwiX19lbXZhbF90YWtlX3ZhbHVlIiwiYXJnIiwiX2Fib3J0IiwiX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzIiwiZGVzdCIsIm51bSIsImNvcHlXaXRoaW4iLCJnZXRIZWFwTWF4IiwiZ3Jvd01lbW9yeSIsInBhZ2VzIiwiYnl0ZUxlbmd0aCIsImdyb3ciLCJfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCIsInJlcXVlc3RlZFNpemUiLCJvbGRTaXplIiwibWF4SGVhcFNpemUiLCJhbGlnblVwIiwieCIsIm11bHRpcGxlIiwiY3V0RG93biIsIm92ZXJHcm93bkhlYXBTaXplIiwiTWF0aCIsIm1pbiIsIm5ld1NpemUiLCJtYXgiLCJyZXBsYWNlbWVudCIsIkVOViIsImdldEV4ZWN1dGFibGVOYW1lIiwiZ2V0RW52U3RyaW5ncyIsInN0cmluZ3MiLCJsYW5nIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2VzIiwiZW52Iiwic3RyaW5nVG9Bc2NpaSIsIlBBVEgiLCJpc0FicyIsImNoYXJBdCIsInNwbGl0UGF0aCIsInNwbGl0UGF0aFJlIiwiZXhlYyIsIm5vcm1hbGl6ZUFycmF5IiwicGFydHMiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwibGFzdCIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJ0cmFpbGluZ1NsYXNoIiwic3BsaXQiLCJmaWx0ZXIiLCJwIiwiZGlybmFtZSIsInJvb3QiLCJkaXIiLCJiYXNlbmFtZSIsImxhc3RTbGFzaCIsInBhdGhzIiwiam9pbjIiLCJsIiwiaW5pdFJhbmRvbUZpbGwiLCJjcnlwdG8iLCJ2aWV3IiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tRmlsbCIsIlBBVEhfRlMiLCJyZXNvbHZlZFBhdGgiLCJyZXNvbHZlZEFic29sdXRlIiwiY3dkIiwicmVsYXRpdmUiLCJmcm9tIiwidG8iLCJ0cmltIiwiYXJyIiwic3RhcnQiLCJlbmQiLCJmcm9tUGFydHMiLCJ0b1BhcnRzIiwic2FtZVBhcnRzTGVuZ3RoIiwib3V0cHV0UGFydHMiLCJGU19zdGRpbl9nZXRDaGFyX2J1ZmZlciIsImludEFycmF5RnJvbVN0cmluZyIsInN0cmluZ3kiLCJkb250QWRkTnVsbCIsInU4YXJyYXkiLCJudW1CeXRlc1dyaXR0ZW4iLCJGU19zdGRpbl9nZXRDaGFyIiwid2luZG93IiwicHJvbXB0IiwicmVhZGxpbmUiLCJ0dHlzIiwic2h1dGRvd24iLCJkZXYiLCJvcHMiLCJpbnB1dCIsIm91dHB1dCIsInJlZ2lzdGVyRGV2aWNlIiwic3RyZWFtX29wcyIsInN0cmVhbSIsInR0eSIsIm5vZGUiLCJyZGV2IiwiRXJybm9FcnJvciIsInNlZWthYmxlIiwiY2xvc2UiLCJmc3luYyIsIm9mZnNldCIsInBvcyIsImdldF9jaGFyIiwiYnl0ZXNSZWFkIiwidGltZXN0YW1wIiwiRGF0ZSIsIm5vdyIsInB1dF9jaGFyIiwiZGVmYXVsdF90dHlfb3BzIiwidmFsIiwiaW9jdGxfdGNnZXRzIiwiY19pZmxhZyIsImNfb2ZsYWciLCJjX2NmbGFnIiwiY19sZmxhZyIsImNfY2MiLCJpb2N0bF90Y3NldHMiLCJvcHRpb25hbF9hY3Rpb25zIiwiaW9jdGxfdGlvY2d3aW5zeiIsImRlZmF1bHRfdHR5MV9vcHMiLCJtbWFwQWxsb2MiLCJNRU1GUyIsIm9wc190YWJsZSIsIm1vdW50IiwiY3JlYXRlTm9kZSIsInBhcmVudCIsIm1vZGUiLCJpc0Jsa2RldiIsImlzRklGTyIsImdldGF0dHIiLCJub2RlX29wcyIsInNldGF0dHIiLCJsb29rdXAiLCJta25vZCIsInJlbmFtZSIsInVubGluayIsInJtZGlyIiwicmVhZGRpciIsInN5bWxpbmsiLCJsbHNlZWsiLCJtbWFwIiwibXN5bmMiLCJsaW5rIiwicmVhZGxpbmsiLCJjaHJkZXYiLCJjaHJkZXZfc3RyZWFtX29wcyIsImlzRGlyIiwiY29udGVudHMiLCJpc0ZpbGUiLCJ1c2VkQnl0ZXMiLCJpc0xpbmsiLCJpc0NocmRldiIsImdldEZpbGVEYXRhQXNUeXBlZEFycmF5IiwiZXhwYW5kRmlsZVN0b3JhZ2UiLCJuZXdDYXBhY2l0eSIsInByZXZDYXBhY2l0eSIsIkNBUEFDSVRZX0RPVUJMSU5HX01BWCIsIm9sZENvbnRlbnRzIiwicmVzaXplRmlsZVN0b3JhZ2UiLCJhdHRyIiwiaW5vIiwibmxpbmsiLCJ1aWQiLCJnaWQiLCJhdGltZSIsIm10aW1lIiwiY3RpbWUiLCJibGtzaXplIiwiYmxvY2tzIiwiY2VpbCIsImdlbmVyaWNFcnJvcnMiLCJvbGRfbm9kZSIsIm5ld19kaXIiLCJuZXdfbmFtZSIsIm5ld19ub2RlIiwibG9va3VwTm9kZSIsImVudHJpZXMiLCJrZXkiLCJuZXduYW1lIiwib2xkcGF0aCIsInBvc2l0aW9uIiwiY2FuT3duIiwid2hlbmNlIiwicHJvdCIsImZsYWdzIiwiYnl0ZU9mZnNldCIsIm1tYXBGbGFncyIsImFzeW5jTG9hZCIsIm5vUnVuRGVwIiwiZGVwIiwiYXJyYXlCdWZmZXIiLCJldmVudCIsIkZTX2NyZWF0ZURhdGFGaWxlIiwiZmlsZURhdGEiLCJjYW5SZWFkIiwiY2FuV3JpdGUiLCJjcmVhdGVEYXRhRmlsZSIsInByZWxvYWRQbHVnaW5zIiwiRlNfaGFuZGxlZEJ5UHJlbG9hZFBsdWdpbiIsImJ5dGVBcnJheSIsImZ1bGxuYW1lIiwiZmluaXNoIiwiQnJvd3NlciIsImhhbmRsZWQiLCJwbHVnaW4iLCJGU19jcmVhdGVQcmVsb2FkZWRGaWxlIiwiZG9udENyZWF0ZUZpbGUiLCJwcmVGaW5pc2giLCJwcm9jZXNzRGF0YSIsIkZTX21vZGVTdHJpbmdUb0ZsYWdzIiwiZmxhZ01vZGVzIiwiRlNfZ2V0TW9kZSIsIm1vdW50cyIsImRldmljZXMiLCJzdHJlYW1zIiwibmV4dElub2RlIiwibmFtZVRhYmxlIiwiY3VycmVudFBhdGgiLCJmaWxlc3lzdGVtcyIsInN5bmNGU1JlcXVlc3RzIiwibG9va3VwUGF0aCIsIm9wdHMiLCJkZWZhdWx0cyIsImZvbGxvd19tb3VudCIsInJlY3Vyc2VfY291bnQiLCJjdXJyZW50IiwiY3VycmVudF9wYXRoIiwiaXNsYXN0IiwiaXNNb3VudHBvaW50IiwibW91bnRlZCIsImZvbGxvdyIsImdldFBhdGgiLCJpc1Jvb3QiLCJtb3VudHBvaW50IiwiaGFzaE5hbWUiLCJwYXJlbnRpZCIsImhhc2giLCJoYXNoQWRkTm9kZSIsIm5hbWVfbmV4dCIsImhhc2hSZW1vdmVOb2RlIiwiZXJyQ29kZSIsIm1heUxvb2t1cCIsIm5vZGVOYW1lIiwiRlNOb2RlIiwiZGVzdHJveU5vZGUiLCJpc1NvY2tldCIsImZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nIiwiZmxhZyIsInBlcm1zIiwibm9kZVBlcm1pc3Npb25zIiwibWF5Q3JlYXRlIiwibWF5RGVsZXRlIiwiaXNkaXIiLCJlcnJubyIsIm1heU9wZW4iLCJNQVhfT1BFTl9GRFMiLCJuZXh0ZmQiLCJmZCIsImdldFN0cmVhbUNoZWNrZWQiLCJnZXRTdHJlYW0iLCJjcmVhdGVTdHJlYW0iLCJGU1N0cmVhbSIsInNoYXJlZCIsImRlZmluZVByb3BlcnRpZXMiLCJvYmplY3QiLCJpc1JlYWQiLCJpc1dyaXRlIiwiaXNBcHBlbmQiLCJjbG9zZVN0cmVhbSIsImRldmljZSIsImdldERldmljZSIsIm1ham9yIiwibWlub3IiLCJtYWtlZGV2IiwibWEiLCJtaSIsImdldE1vdW50cyIsImNoZWNrIiwibSIsInN5bmNmcyIsInBvcHVsYXRlIiwiY29tcGxldGVkIiwiZG9DYWxsYmFjayIsImRvbmUiLCJlcnJvcmVkIiwicHNldWRvIiwibW91bnRSb290IiwidW5tb3VudCIsIm5leHQiLCJta2RpciIsIm1rZGlyVHJlZSIsImRpcnMiLCJkIiwibWtkZXYiLCJuZXdwYXRoIiwib2xkX3BhdGgiLCJuZXdfcGF0aCIsIm9sZF9kaXJuYW1lIiwibmV3X2Rpcm5hbWUiLCJvbGRfbmFtZSIsIm9sZF9kaXIiLCJzdGF0IiwiZG9udEZvbGxvdyIsImxzdGF0IiwiY2htb2QiLCJsY2htb2QiLCJmY2htb2QiLCJjaG93biIsImxjaG93biIsImZjaG93biIsInRydW5jYXRlIiwiZnRydW5jYXRlIiwidXRpbWUiLCJjcmVhdGVkIiwidW5nb3R0ZW4iLCJyZWFkRmlsZXMiLCJpc0Nsb3NlZCIsImdldGRlbnRzIiwic2Vla2luZyIsImJ5dGVzV3JpdHRlbiIsIm11bm1hcCIsImlvY3RsIiwiY21kIiwicmVhZEZpbGUiLCJlbmNvZGluZyIsImJ1ZiIsIndyaXRlRmlsZSIsImFjdHVhbE51bUJ5dGVzIiwiaXNWaWV3IiwiY2hkaXIiLCJjcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMiLCJjcmVhdGVEZWZhdWx0RGV2aWNlcyIsInJhbmRvbUJ1ZmZlciIsInJhbmRvbUxlZnQiLCJyYW5kb21CeXRlIiwiY3JlYXRlRGV2aWNlIiwiY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzIiwicHJvY19zZWxmIiwiY3JlYXRlU3RhbmRhcmRTdHJlYW1zIiwic3RkaW4iLCJzdGRvdXQiLCJzdGRlcnIiLCJlbnN1cmVFcnJub0Vycm9yIiwic2V0RXJybm8iLCJjb2RlIiwic3RhdGljSW5pdCIsInF1aXQiLCJmaW5kT2JqZWN0IiwiZG9udFJlc29sdmVMYXN0TGluayIsImFuYWx5emVQYXRoIiwiZXhpc3RzIiwicGFyZW50RXhpc3RzIiwicGFyZW50UGF0aCIsInBhcmVudE9iamVjdCIsImNyZWF0ZVBhdGgiLCJyZXZlcnNlIiwicGFydCIsImNyZWF0ZUZpbGUiLCJwcm9wZXJ0aWVzIiwiZm9yY2VMb2FkRmlsZSIsImlzRGV2aWNlIiwiaXNGb2xkZXIiLCJjcmVhdGVMYXp5RmlsZSIsIkxhenlVaW50OEFycmF5IiwibGVuZ3RoS25vd24iLCJjaHVua3MiLCJMYXp5VWludDhBcnJheV9nZXQiLCJjaHVua09mZnNldCIsImNodW5rU2l6ZSIsImNodW5rTnVtIiwic2V0RGF0YUdldHRlciIsIkxhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIiLCJjYWNoZUxlbmd0aCIsIkxhenlVaW50OEFycmF5X2NhY2hlTGVuZ3RoIiwiZGF0YWxlbmd0aCIsIk51bWJlciIsImdldFJlc3BvbnNlSGVhZGVyIiwiaGVhZGVyIiwiaGFzQnl0ZVNlcnZpbmciLCJ1c2VzR3ppcCIsImRvWEhSIiwic2V0UmVxdWVzdEhlYWRlciIsIm92ZXJyaWRlTWltZVR5cGUiLCJsYXp5QXJyYXkiLCJfbGVuZ3RoIiwiX2NodW5rU2l6ZSIsImZvcmNlTG9hZExhenlGaWxlIiwid3JpdGVDaHVua3MiLCJTWVNDQUxMUyIsIkRFRkFVTFRfUE9MTE1BU0siLCJjYWxjdWxhdGVBdCIsImRpcmZkIiwiYWxsb3dFbXB0eSIsImRpcnN0cmVhbSIsImdldFN0cmVhbUZyb21GRCIsImRvU3RhdCIsImFicyIsImZsb29yIiwiZ2V0VGltZSIsImRvTXN5bmMiLCJhZGRyIiwidmFyYXJncyIsImdldHAiLCJnZXRTdHIiLCJfZW52aXJvbl9nZXQiLCJfX2Vudmlyb24iLCJlbnZpcm9uX2J1ZiIsImJ1ZlNpemUiLCJzdHJpbmciLCJfZW52aXJvbl9zaXplc19nZXQiLCJwZW52aXJvbl9jb3VudCIsInBlbnZpcm9uX2J1Zl9zaXplIiwiX2ZkX2Nsb3NlIiwiZG9SZWFkdiIsImlvdiIsImlvdmNudCIsImN1cnIiLCJfZmRfcmVhZCIsInBudW0iLCJjb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZCIsImxvIiwiaGkiLCJOYU4iLCJfZmRfc2VlayIsIm9mZnNldF9sb3ciLCJvZmZzZXRfaGlnaCIsIm5ld09mZnNldCIsImlzTmFOIiwiZG9Xcml0ZXYiLCJfZmRfd3JpdGUiLCJpc0xlYXBZZWFyIiwieWVhciIsImFycmF5U3VtIiwiaW5kZXgiLCJzdW0iLCJNT05USF9EQVlTX0xFQVAiLCJNT05USF9EQVlTX1JFR1VMQVIiLCJhZGREYXlzIiwiZGF0ZSIsImRheXMiLCJuZXdEYXRlIiwibGVhcCIsImdldEZ1bGxZZWFyIiwiY3VycmVudE1vbnRoIiwiZ2V0TW9udGgiLCJkYXlzSW5DdXJyZW50TW9udGgiLCJnZXREYXRlIiwic2V0RGF0ZSIsInNldE1vbnRoIiwic2V0RnVsbFllYXIiLCJ3cml0ZUFycmF5VG9NZW1vcnkiLCJfc3RyZnRpbWUiLCJzIiwibWF4c2l6ZSIsImZvcm1hdCIsInRtIiwidG1fem9uZSIsInRtX3NlYyIsInRtX21pbiIsInRtX2hvdXIiLCJ0bV9tZGF5IiwidG1fbW9uIiwidG1feWVhciIsInRtX3dkYXkiLCJ0bV95ZGF5IiwidG1faXNkc3QiLCJ0bV9nbXRvZmYiLCJwYXR0ZXJuIiwiRVhQQU5TSU9OX1JVTEVTXzEiLCJydWxlIiwiUmVnRXhwIiwiV0VFS0RBWVMiLCJNT05USFMiLCJsZWFkaW5nU29tZXRoaW5nIiwiZGlnaXRzIiwiY2hhcmFjdGVyIiwibGVhZGluZ051bGxzIiwiY29tcGFyZUJ5RGF5IiwiZGF0ZTEiLCJkYXRlMiIsInNnbiIsImNvbXBhcmUiLCJnZXRGaXJzdFdlZWtTdGFydERhdGUiLCJqYW5Gb3VydGgiLCJnZXREYXkiLCJnZXRXZWVrQmFzZWRZZWFyIiwidGhpc0RhdGUiLCJqYW5Gb3VydGhUaGlzWWVhciIsImphbkZvdXJ0aE5leHRZZWFyIiwiZmlyc3RXZWVrU3RhcnRUaGlzWWVhciIsImZpcnN0V2Vla1N0YXJ0TmV4dFllYXIiLCJFWFBBTlNJT05fUlVMRVNfMiIsInR3ZWx2ZUhvdXIiLCJkZWMzMSIsImphbjEiLCJvZmYiLCJhaGVhZCIsImJ5dGVzIiwiX3N0cmZ0aW1lX2wiLCJsb2MiLCJnZXRDRnVuYyIsImlkZW50Iiwic3RyaW5nVG9VVEY4T25TdGFjayIsInN0YWNrQWxsb2MiLCJjY2FsbCIsInJldHVyblR5cGUiLCJ0b0MiLCJjb252ZXJ0UmV0dXJuVmFsdWUiLCJCb29sZWFuIiwiY0FyZ3MiLCJjb252ZXJ0ZXIiLCJzdGFja1NhdmUiLCJvbkRvbmUiLCJzdGFja1Jlc3RvcmUiLCJyZWFkTW9kZSIsIndyaXRlTW9kZSIsImNyZWF0ZVByZWxvYWRlZEZpbGUiLCJuIiwidyIsIkciLCJoIiwiZyIsInEiLCJGIiwiaiIsIkgiLCJJIiwiSiIsIkUiLCJ5IiwieiIsIkEiLCJCIiwiRCIsIkMiLCJfX193YXNtX2NhbGxfY3RvcnMiLCJhMCIsIl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3MiLCJfX19lcnJub19sb2NhdGlvbiIsIl9fX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50IiwiZHluQ2FsbF9qaWppIiwiYTEiLCJhMiIsImEzIiwiYTQiLCJkeW5DYWxsX3ZpaWppaSIsImE1IiwiYTYiLCJkeW5DYWxsX2lpaWlpaiIsImR5bkNhbGxfaWlpaWlqaiIsImE3IiwiYTgiLCJkeW5DYWxsX2lpaWlpaWpqIiwiYTkiLCJjYWxsZWRSdW4iLCJydW5DYWxsZXIiLCJydW4iLCJkb1J1biIsInNldFRpbWVvdXQiLCJyZWFkeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@splinetool/runtime/build/process.js\n"));

/***/ })

}]);