"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_splinetool_runtime_build_boolean_js"],{

/***/ "(app-pages-browser)/./node_modules/@splinetool/runtime/build/boolean.js":
/*!***********************************************************!*\
  !*** ./node_modules/@splinetool/runtime/build/boolean.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar Module = (()=>{\n    var _scriptDir = typeof document !== \"undefined\" && document.currentScript ? document.currentScript.src : undefined;\n    return function() {\n        let moduleArg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n        var Module = moduleArg;\n        var readyPromiseResolve, readyPromiseReject;\n        Module[\"ready\"] = new Promise((resolve, reject)=>{\n            readyPromiseResolve = resolve;\n            readyPromiseReject = reject;\n        });\n        var moduleOverrides = Object.assign({}, Module);\n        var arguments_ = [];\n        var thisProgram = \"./this.program\";\n        var quit_ = (status, toThrow)=>{\n            throw toThrow;\n        };\n        var ENVIRONMENT_IS_WEB = true;\n        var ENVIRONMENT_IS_WORKER = false;\n        var scriptDirectory = \"\";\n        function locateFile(path) {\n            if (Module[\"locateFile\"]) {\n                return Module[\"locateFile\"](path, scriptDirectory);\n            }\n            return scriptDirectory + path;\n        }\n        var read_, readAsync, readBinary;\n        if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n            if (ENVIRONMENT_IS_WORKER) {\n                scriptDirectory = self.location.href;\n            } else if (typeof document != \"undefined\" && document.currentScript) {\n                scriptDirectory = document.currentScript.src;\n            }\n            if (_scriptDir) {\n                scriptDirectory = _scriptDir;\n            }\n            if (scriptDirectory.indexOf(\"blob:\") !== 0) {\n                scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, \"\").lastIndexOf(\"/\") + 1);\n            } else {\n                scriptDirectory = \"\";\n            }\n            {\n                read_ = (url)=>{\n                    var xhr = new XMLHttpRequest;\n                    xhr.open(\"GET\", url, false);\n                    xhr.send(null);\n                    return xhr.responseText;\n                };\n                if (ENVIRONMENT_IS_WORKER) {\n                    readBinary = (url)=>{\n                        var xhr = new XMLHttpRequest;\n                        xhr.open(\"GET\", url, false);\n                        xhr.responseType = \"arraybuffer\";\n                        xhr.send(null);\n                        return new Uint8Array(xhr.response);\n                    };\n                }\n                readAsync = (url, onload, onerror)=>{\n                    var xhr = new XMLHttpRequest;\n                    xhr.open(\"GET\", url, true);\n                    xhr.responseType = \"arraybuffer\";\n                    xhr.onload = ()=>{\n                        if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                            onload(xhr.response);\n                            return;\n                        }\n                        onerror();\n                    };\n                    xhr.onerror = onerror;\n                    xhr.send(null);\n                };\n            }\n        } else {}\n        var out = Module[\"print\"] || console.log.bind(console);\n        var err = Module[\"printErr\"] || console.error.bind(console);\n        Object.assign(Module, moduleOverrides);\n        moduleOverrides = null;\n        if (Module[\"arguments\"]) arguments_ = Module[\"arguments\"];\n        if (Module[\"thisProgram\"]) thisProgram = Module[\"thisProgram\"];\n        if (Module[\"quit\"]) quit_ = Module[\"quit\"];\n        var wasmBinary;\n        if (Module[\"wasmBinary\"]) wasmBinary = Module[\"wasmBinary\"];\n        if (typeof WebAssembly != \"object\") {\n            abort(\"no native wasm support detected\");\n        }\n        var wasmMemory;\n        var ABORT = false;\n        var EXITSTATUS;\n        function assert(condition, text) {\n            if (!condition) {\n                abort(text);\n            }\n        }\n        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;\n        function updateMemoryViews() {\n            var b = wasmMemory.buffer;\n            Module[\"HEAP8\"] = HEAP8 = new Int8Array(b);\n            Module[\"HEAP16\"] = HEAP16 = new Int16Array(b);\n            Module[\"HEAPU8\"] = HEAPU8 = new Uint8Array(b);\n            Module[\"HEAPU16\"] = HEAPU16 = new Uint16Array(b);\n            Module[\"HEAP32\"] = HEAP32 = new Int32Array(b);\n            Module[\"HEAPU32\"] = HEAPU32 = new Uint32Array(b);\n            Module[\"HEAPF32\"] = HEAPF32 = new Float32Array(b);\n            Module[\"HEAPF64\"] = HEAPF64 = new Float64Array(b);\n        }\n        var __ATPRERUN__ = [];\n        var __ATINIT__ = [];\n        var __ATPOSTRUN__ = [];\n        var runtimeInitialized = false;\n        function preRun() {\n            if (Module[\"preRun\"]) {\n                if (typeof Module[\"preRun\"] == \"function\") Module[\"preRun\"] = [\n                    Module[\"preRun\"]\n                ];\n                while(Module[\"preRun\"].length){\n                    addOnPreRun(Module[\"preRun\"].shift());\n                }\n            }\n            callRuntimeCallbacks(__ATPRERUN__);\n        }\n        function initRuntime() {\n            runtimeInitialized = true;\n            if (!Module[\"noFSInit\"] && !FS.init.initialized) FS.init();\n            FS.ignorePermissions = false;\n            TTY.init();\n            callRuntimeCallbacks(__ATINIT__);\n        }\n        function postRun() {\n            if (Module[\"postRun\"]) {\n                if (typeof Module[\"postRun\"] == \"function\") Module[\"postRun\"] = [\n                    Module[\"postRun\"]\n                ];\n                while(Module[\"postRun\"].length){\n                    addOnPostRun(Module[\"postRun\"].shift());\n                }\n            }\n            callRuntimeCallbacks(__ATPOSTRUN__);\n        }\n        function addOnPreRun(cb) {\n            __ATPRERUN__.unshift(cb);\n        }\n        function addOnInit(cb) {\n            __ATINIT__.unshift(cb);\n        }\n        function addOnPostRun(cb) {\n            __ATPOSTRUN__.unshift(cb);\n        }\n        var runDependencies = 0;\n        var runDependencyWatcher = null;\n        var dependenciesFulfilled = null;\n        function getUniqueRunDependency(id) {\n            return id;\n        }\n        function addRunDependency(id) {\n            runDependencies++;\n            if (Module[\"monitorRunDependencies\"]) {\n                Module[\"monitorRunDependencies\"](runDependencies);\n            }\n        }\n        function removeRunDependency(id) {\n            runDependencies--;\n            if (Module[\"monitorRunDependencies\"]) {\n                Module[\"monitorRunDependencies\"](runDependencies);\n            }\n            if (runDependencies == 0) {\n                if (runDependencyWatcher !== null) {\n                    clearInterval(runDependencyWatcher);\n                    runDependencyWatcher = null;\n                }\n                if (dependenciesFulfilled) {\n                    var callback = dependenciesFulfilled;\n                    dependenciesFulfilled = null;\n                    callback();\n                }\n            }\n        }\n        function abort(what) {\n            if (Module[\"onAbort\"]) {\n                Module[\"onAbort\"](what);\n            }\n            what = \"Aborted(\" + what + \")\";\n            err(what);\n            ABORT = true;\n            EXITSTATUS = 1;\n            what += \". Build with -sASSERTIONS for more info.\";\n            var e = new WebAssembly.RuntimeError(what);\n            readyPromiseReject(e);\n            throw e;\n        }\n        var dataURIPrefix = \"data:application/octet-stream;base64,\";\n        var isDataURI = (filename)=>filename.startsWith(dataURIPrefix);\n        var wasmBinaryFile;\n        wasmBinaryFile = \"boolean.wasm\";\n        if (!isDataURI(wasmBinaryFile)) {\n            wasmBinaryFile = locateFile(wasmBinaryFile);\n        }\n        function getBinarySync(file) {\n            if (file == wasmBinaryFile && wasmBinary) {\n                return new Uint8Array(wasmBinary);\n            }\n            if (readBinary) {\n                return readBinary(file);\n            }\n            throw \"both async and sync fetching of the wasm failed\";\n        }\n        function getBinaryPromise(binaryFile) {\n            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {\n                if (typeof fetch == \"function\") {\n                    return fetch(binaryFile, {\n                        credentials: \"same-origin\"\n                    }).then((response)=>{\n                        if (!response[\"ok\"]) {\n                            throw \"failed to load wasm binary file at '\" + binaryFile + \"'\";\n                        }\n                        return response[\"arrayBuffer\"]();\n                    }).catch(()=>getBinarySync(binaryFile));\n                }\n            }\n            return Promise.resolve().then(()=>getBinarySync(binaryFile));\n        }\n        function instantiateArrayBuffer(binaryFile, imports, receiver) {\n            return getBinaryPromise(binaryFile).then((binary)=>WebAssembly.instantiate(binary, imports)).then((instance)=>instance).then(receiver, (reason)=>{\n                err(\"failed to asynchronously prepare wasm: \".concat(reason));\n                abort(reason);\n            });\n        }\n        function instantiateAsync(binary, binaryFile, imports, callback) {\n            if (!binary && typeof WebAssembly.instantiateStreaming == \"function\" && !isDataURI(binaryFile) && typeof fetch == \"function\") {\n                return fetch(binaryFile, {\n                    credentials: \"same-origin\"\n                }).then((response)=>{\n                    var result = WebAssembly.instantiateStreaming(response, imports);\n                    return result.then(callback, function(reason) {\n                        err(\"wasm streaming compile failed: \".concat(reason));\n                        err(\"falling back to ArrayBuffer instantiation\");\n                        return instantiateArrayBuffer(binaryFile, imports, callback);\n                    });\n                });\n            }\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n        }\n        function createWasm() {\n            var info = {\n                \"a\": wasmImports\n            };\n            function receiveInstance(instance, module) {\n                wasmExports = instance.exports;\n                wasmMemory = wasmExports[\"A\"];\n                updateMemoryViews();\n                wasmTable = wasmExports[\"C\"];\n                addOnInit(wasmExports[\"B\"]);\n                removeRunDependency(\"wasm-instantiate\");\n                return wasmExports;\n            }\n            addRunDependency(\"wasm-instantiate\");\n            function receiveInstantiationResult(result) {\n                receiveInstance(result[\"instance\"]);\n            }\n            if (Module[\"instantiateWasm\"]) {\n                try {\n                    return Module[\"instantiateWasm\"](info, receiveInstance);\n                } catch (e) {\n                    err(\"Module.instantiateWasm callback failed with error: \".concat(e));\n                    readyPromiseReject(e);\n                }\n            }\n            instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\n            return {};\n        }\n        var tempDouble;\n        var tempI64;\n        var callRuntimeCallbacks = (callbacks)=>{\n            while(callbacks.length > 0){\n                callbacks.shift()(Module);\n            }\n        };\n        var noExitRuntime = Module[\"noExitRuntime\"] || true;\n        function ExceptionInfo(excPtr) {\n            this.excPtr = excPtr;\n            this.ptr = excPtr - 24;\n            this.set_type = function(type) {\n                HEAPU32[this.ptr + 4 >> 2] = type;\n            };\n            this.get_type = function() {\n                return HEAPU32[this.ptr + 4 >> 2];\n            };\n            this.set_destructor = function(destructor) {\n                HEAPU32[this.ptr + 8 >> 2] = destructor;\n            };\n            this.get_destructor = function() {\n                return HEAPU32[this.ptr + 8 >> 2];\n            };\n            this.set_caught = function(caught) {\n                caught = caught ? 1 : 0;\n                HEAP8[this.ptr + 12 >> 0] = caught;\n            };\n            this.get_caught = function() {\n                return HEAP8[this.ptr + 12 >> 0] != 0;\n            };\n            this.set_rethrown = function(rethrown) {\n                rethrown = rethrown ? 1 : 0;\n                HEAP8[this.ptr + 13 >> 0] = rethrown;\n            };\n            this.get_rethrown = function() {\n                return HEAP8[this.ptr + 13 >> 0] != 0;\n            };\n            this.init = function(type, destructor) {\n                this.set_adjusted_ptr(0);\n                this.set_type(type);\n                this.set_destructor(destructor);\n            };\n            this.set_adjusted_ptr = function(adjustedPtr) {\n                HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n            };\n            this.get_adjusted_ptr = function() {\n                return HEAPU32[this.ptr + 16 >> 2];\n            };\n            this.get_exception_ptr = function() {\n                var isPointer = ___cxa_is_pointer_type(this.get_type());\n                if (isPointer) {\n                    return HEAPU32[this.excPtr >> 2];\n                }\n                var adjusted = this.get_adjusted_ptr();\n                if (adjusted !== 0) return adjusted;\n                return this.excPtr;\n            };\n        }\n        var exceptionLast = 0;\n        var uncaughtExceptionCount = 0;\n        var ___cxa_throw = (ptr, type, destructor)=>{\n            var info = new ExceptionInfo(ptr);\n            info.init(type, destructor);\n            exceptionLast = ptr;\n            uncaughtExceptionCount++;\n            throw exceptionLast;\n        };\n        var tupleRegistrations = {};\n        var runDestructors = (destructors)=>{\n            while(destructors.length){\n                var ptr = destructors.pop();\n                var del = destructors.pop();\n                del(ptr);\n            }\n        };\n        function simpleReadValueFromPointer(pointer) {\n            return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n        }\n        var awaitingDependencies = {};\n        var registeredTypes = {};\n        var typeDependencies = {};\n        var InternalError;\n        var throwInternalError = (message)=>{\n            throw new InternalError(message);\n        };\n        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters)=>{\n            myTypes.forEach(function(type) {\n                typeDependencies[type] = dependentTypes;\n            });\n            function onComplete(typeConverters) {\n                var myTypeConverters = getTypeConverters(typeConverters);\n                if (myTypeConverters.length !== myTypes.length) {\n                    throwInternalError(\"Mismatched type converter count\");\n                }\n                for(var i = 0; i < myTypes.length; ++i){\n                    registerType(myTypes[i], myTypeConverters[i]);\n                }\n            }\n            var typeConverters = new Array(dependentTypes.length);\n            var unregisteredTypes = [];\n            var registered = 0;\n            dependentTypes.forEach((dt, i)=>{\n                if (registeredTypes.hasOwnProperty(dt)) {\n                    typeConverters[i] = registeredTypes[dt];\n                } else {\n                    unregisteredTypes.push(dt);\n                    if (!awaitingDependencies.hasOwnProperty(dt)) {\n                        awaitingDependencies[dt] = [];\n                    }\n                    awaitingDependencies[dt].push(()=>{\n                        typeConverters[i] = registeredTypes[dt];\n                        ++registered;\n                        if (registered === unregisteredTypes.length) {\n                            onComplete(typeConverters);\n                        }\n                    });\n                }\n            });\n            if (0 === unregisteredTypes.length) {\n                onComplete(typeConverters);\n            }\n        };\n        var __embind_finalize_value_array = (rawTupleType)=>{\n            var reg = tupleRegistrations[rawTupleType];\n            delete tupleRegistrations[rawTupleType];\n            var elements = reg.elements;\n            var elementsLength = elements.length;\n            var elementTypes = elements.map((elt)=>elt.getterReturnType).concat(elements.map((elt)=>elt.setterArgumentType));\n            var rawConstructor = reg.rawConstructor;\n            var rawDestructor = reg.rawDestructor;\n            whenDependentTypesAreResolved([\n                rawTupleType\n            ], elementTypes, function(elementTypes) {\n                elements.forEach((elt, i)=>{\n                    var getterReturnType = elementTypes[i];\n                    var getter = elt.getter;\n                    var getterContext = elt.getterContext;\n                    var setterArgumentType = elementTypes[i + elementsLength];\n                    var setter = elt.setter;\n                    var setterContext = elt.setterContext;\n                    elt.read = (ptr)=>getterReturnType[\"fromWireType\"](getter(getterContext, ptr));\n                    elt.write = (ptr, o)=>{\n                        var destructors = [];\n                        setter(setterContext, ptr, setterArgumentType[\"toWireType\"](destructors, o));\n                        runDestructors(destructors);\n                    };\n                });\n                return [\n                    {\n                        name: reg.name,\n                        \"fromWireType\": (ptr)=>{\n                            var rv = new Array(elementsLength);\n                            for(var i = 0; i < elementsLength; ++i){\n                                rv[i] = elements[i].read(ptr);\n                            }\n                            rawDestructor(ptr);\n                            return rv;\n                        },\n                        \"toWireType\": (destructors, o)=>{\n                            if (elementsLength !== o.length) {\n                                throw new TypeError(\"Incorrect number of tuple elements for \".concat(reg.name, \": expected=\").concat(elementsLength, \", actual=\").concat(o.length));\n                            }\n                            var ptr = rawConstructor();\n                            for(var i = 0; i < elementsLength; ++i){\n                                elements[i].write(ptr, o[i]);\n                            }\n                            if (destructors !== null) {\n                                destructors.push(rawDestructor, ptr);\n                            }\n                            return ptr;\n                        },\n                        \"argPackAdvance\": GenericWireTypeSize,\n                        \"readValueFromPointer\": simpleReadValueFromPointer,\n                        destructorFunction: rawDestructor\n                    }\n                ];\n            });\n        };\n        var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange)=>{};\n        var embind_init_charCodes = ()=>{\n            var codes = new Array(256);\n            for(var i = 0; i < 256; ++i){\n                codes[i] = String.fromCharCode(i);\n            }\n            embind_charCodes = codes;\n        };\n        var embind_charCodes;\n        var readLatin1String = (ptr)=>{\n            var ret = \"\";\n            var c = ptr;\n            while(HEAPU8[c]){\n                ret += embind_charCodes[HEAPU8[c++]];\n            }\n            return ret;\n        };\n        var BindingError;\n        var throwBindingError = (message)=>{\n            throw new BindingError(message);\n        };\n        function sharedRegisterType(rawType, registeredInstance) {\n            let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            var name = registeredInstance.name;\n            if (!rawType) {\n                throwBindingError('type \"'.concat(name, '\" must have a positive integer typeid pointer'));\n            }\n            if (registeredTypes.hasOwnProperty(rawType)) {\n                if (options.ignoreDuplicateRegistrations) {\n                    return;\n                } else {\n                    throwBindingError(\"Cannot register type '\".concat(name, \"' twice\"));\n                }\n            }\n            registeredTypes[rawType] = registeredInstance;\n            delete typeDependencies[rawType];\n            if (awaitingDependencies.hasOwnProperty(rawType)) {\n                var callbacks = awaitingDependencies[rawType];\n                delete awaitingDependencies[rawType];\n                callbacks.forEach((cb)=>cb());\n            }\n        }\n        function registerType(rawType, registeredInstance) {\n            let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n            if (!(\"argPackAdvance\" in registeredInstance)) {\n                throw new TypeError(\"registerType registeredInstance requires argPackAdvance\");\n            }\n            return sharedRegisterType(rawType, registeredInstance, options);\n        }\n        var GenericWireTypeSize = 8;\n        var __embind_register_bool = (rawType, name, trueValue, falseValue)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": function(wt) {\n                    return !!wt;\n                },\n                \"toWireType\": function(destructors, o) {\n                    return o ? trueValue : falseValue;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": function(pointer) {\n                    return this[\"fromWireType\"](HEAPU8[pointer]);\n                },\n                destructorFunction: null\n            });\n        };\n        function handleAllocatorInit() {\n            Object.assign(HandleAllocator.prototype, {\n                get (id) {\n                    return this.allocated[id];\n                },\n                has (id) {\n                    return this.allocated[id] !== undefined;\n                },\n                allocate (handle) {\n                    var id = this.freelist.pop() || this.allocated.length;\n                    this.allocated[id] = handle;\n                    return id;\n                },\n                free (id) {\n                    this.allocated[id] = undefined;\n                    this.freelist.push(id);\n                }\n            });\n        }\n        function HandleAllocator() {\n            this.allocated = [\n                undefined\n            ];\n            this.freelist = [];\n        }\n        var emval_handles = new HandleAllocator;\n        var __emval_decref = (handle)=>{\n            if (handle >= emval_handles.reserved && 0 === --emval_handles.get(handle).refcount) {\n                emval_handles.free(handle);\n            }\n        };\n        var count_emval_handles = ()=>{\n            var count = 0;\n            for(var i = emval_handles.reserved; i < emval_handles.allocated.length; ++i){\n                if (emval_handles.allocated[i] !== undefined) {\n                    ++count;\n                }\n            }\n            return count;\n        };\n        var init_emval = ()=>{\n            emval_handles.allocated.push({\n                value: undefined\n            }, {\n                value: null\n            }, {\n                value: true\n            }, {\n                value: false\n            });\n            emval_handles.reserved = emval_handles.allocated.length;\n            Module[\"count_emval_handles\"] = count_emval_handles;\n        };\n        var Emval = {\n            toValue: (handle)=>{\n                if (!handle) {\n                    throwBindingError(\"Cannot use deleted val. handle = \" + handle);\n                }\n                return emval_handles.get(handle).value;\n            },\n            toHandle: (value)=>{\n                switch(value){\n                    case undefined:\n                        return 1;\n                    case null:\n                        return 2;\n                    case true:\n                        return 3;\n                    case false:\n                        return 4;\n                    default:\n                        {\n                            return emval_handles.allocate({\n                                refcount: 1,\n                                value: value\n                            });\n                        }\n                }\n            }\n        };\n        var __embind_register_emval = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (handle)=>{\n                    var rv = Emval.toValue(handle);\n                    __emval_decref(handle);\n                    return rv;\n                },\n                \"toWireType\": (destructors, value)=>Emval.toHandle(value),\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction: null\n            });\n        };\n        var ensureOverloadTable = (proto, methodName, humanName)=>{\n            if (undefined === proto[methodName].overloadTable) {\n                var prevFunc = proto[methodName];\n                proto[methodName] = function() {\n                    if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {\n                        throwBindingError(\"Function '\".concat(humanName, \"' called with an invalid number of arguments (\").concat(arguments.length, \") - expects one of (\").concat(proto[methodName].overloadTable, \")!\"));\n                    }\n                    return proto[methodName].overloadTable[arguments.length].apply(this, arguments);\n                };\n                proto[methodName].overloadTable = [];\n                proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\n            }\n        };\n        var exposePublicSymbol = (name, value, numArguments)=>{\n            if (Module.hasOwnProperty(name)) {\n                if (undefined === numArguments || undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments]) {\n                    throwBindingError(\"Cannot register public name '\".concat(name, \"' twice\"));\n                }\n                ensureOverloadTable(Module, name, name);\n                if (Module.hasOwnProperty(numArguments)) {\n                    throwBindingError(\"Cannot register multiple overloads of a function with the same number of arguments (\".concat(numArguments, \")!\"));\n                }\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                if (undefined !== numArguments) {\n                    Module[name].numArguments = numArguments;\n                }\n            }\n        };\n        var enumReadValueFromPointer = (name, width, signed)=>{\n            switch(width){\n                case 1:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](HEAP8[pointer >> 0]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](HEAPU8[pointer >> 0]);\n                    };\n                case 2:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](HEAP16[pointer >> 1]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](HEAPU16[pointer >> 1]);\n                    };\n                case 4:\n                    return signed ? function(pointer) {\n                        return this[\"fromWireType\"](HEAP32[pointer >> 2]);\n                    } : function(pointer) {\n                        return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n                    };\n                default:\n                    throw new TypeError(\"invalid integer width (\".concat(width, \"): \").concat(name));\n            }\n        };\n        var __embind_register_enum = (rawType, name, size, isSigned)=>{\n            name = readLatin1String(name);\n            function ctor() {}\n            ctor.values = {};\n            registerType(rawType, {\n                name: name,\n                constructor: ctor,\n                \"fromWireType\": function(c) {\n                    return this.constructor.values[c];\n                },\n                \"toWireType\": (destructors, c)=>c.value,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": enumReadValueFromPointer(name, size, isSigned),\n                destructorFunction: null\n            });\n            exposePublicSymbol(name, ctor);\n        };\n        var createNamedFunction = (name, body)=>Object.defineProperty(body, \"name\", {\n                value: name\n            });\n        var getTypeName = (type)=>{\n            var ptr = ___getTypeName(type);\n            var rv = readLatin1String(ptr);\n            _free(ptr);\n            return rv;\n        };\n        var requireRegisteredType = (rawType, humanName)=>{\n            var impl = registeredTypes[rawType];\n            if (undefined === impl) {\n                throwBindingError(humanName + \" has unknown type \" + getTypeName(rawType));\n            }\n            return impl;\n        };\n        var __embind_register_enum_value = (rawEnumType, name, enumValue)=>{\n            var enumType = requireRegisteredType(rawEnumType, \"enum\");\n            name = readLatin1String(name);\n            var Enum = enumType.constructor;\n            var Value = Object.create(enumType.constructor.prototype, {\n                value: {\n                    value: enumValue\n                },\n                constructor: {\n                    value: createNamedFunction(\"\".concat(enumType.name, \"_\").concat(name), function() {})\n                }\n            });\n            Enum.values[enumValue] = Value;\n            Enum[name] = Value;\n        };\n        var floatReadValueFromPointer = (name, width)=>{\n            switch(width){\n                case 4:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF32[pointer >> 2]);\n                    };\n                case 8:\n                    return function(pointer) {\n                        return this[\"fromWireType\"](HEAPF64[pointer >> 3]);\n                    };\n                default:\n                    throw new TypeError(\"invalid float width (\".concat(width, \"): \").concat(name));\n            }\n        };\n        var __embind_register_float = (rawType, name, size)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>value,\n                \"toWireType\": (destructors, value)=>value,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": floatReadValueFromPointer(name, size),\n                destructorFunction: null\n            });\n        };\n        function newFunc(constructor, argumentList) {\n            if (!(constructor instanceof Function)) {\n                throw new TypeError(\"new_ called with constructor type \".concat(typeof constructor, \" which is not a function\"));\n            }\n            var dummy = createNamedFunction(constructor.name || \"unknownFunctionName\", function() {});\n            dummy.prototype = constructor.prototype;\n            var obj = new dummy;\n            var r = constructor.apply(obj, argumentList);\n            return r instanceof Object ? r : obj;\n        }\n        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {\n            var argCount = argTypes.length;\n            if (argCount < 2) {\n                throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\n            }\n            var isClassMethodFunc = argTypes[1] !== null && classType !== null;\n            var needsDestructorStack = false;\n            for(var i = 1; i < argTypes.length; ++i){\n                if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\n                    needsDestructorStack = true;\n                    break;\n                }\n            }\n            var returns = argTypes[0].name !== \"void\";\n            var argsList = \"\";\n            var argsListWired = \"\";\n            for(var i = 0; i < argCount - 2; ++i){\n                argsList += (i !== 0 ? \", \" : \"\") + \"arg\" + i;\n                argsListWired += (i !== 0 ? \", \" : \"\") + \"arg\" + i + \"Wired\";\n            }\n            var invokerFnBody = \"\\n        return function (\".concat(argsList, \") {\\n        if (arguments.length !== \").concat(argCount - 2, \") {\\n          throwBindingError('function \").concat(humanName, \" called with ' + arguments.length + ' arguments, expected \").concat(argCount - 2, \"');\\n        }\");\n            if (needsDestructorStack) {\n                invokerFnBody += \"var destructors = [];\\n\";\n            }\n            var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\n            var args1 = [\n                \"throwBindingError\",\n                \"invoker\",\n                \"fn\",\n                \"runDestructors\",\n                \"retType\",\n                \"classParam\"\n            ];\n            var args2 = [\n                throwBindingError,\n                cppInvokerFunc,\n                cppTargetFunc,\n                runDestructors,\n                argTypes[0],\n                argTypes[1]\n            ];\n            if (isClassMethodFunc) {\n                invokerFnBody += \"var thisWired = classParam.toWireType(\" + dtorStack + \", this);\\n\";\n            }\n            for(var i = 0; i < argCount - 2; ++i){\n                invokerFnBody += \"var arg\" + i + \"Wired = argType\" + i + \".toWireType(\" + dtorStack + \", arg\" + i + \"); // \" + argTypes[i + 2].name + \"\\n\";\n                args1.push(\"argType\" + i);\n                args2.push(argTypes[i + 2]);\n            }\n            if (isClassMethodFunc) {\n                argsListWired = \"thisWired\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired;\n            }\n            invokerFnBody += (returns || isAsync ? \"var rv = \" : \"\") + \"invoker(fn\" + (argsListWired.length > 0 ? \", \" : \"\") + argsListWired + \");\\n\";\n            if (needsDestructorStack) {\n                invokerFnBody += \"runDestructors(destructors);\\n\";\n            } else {\n                for(var i = isClassMethodFunc ? 1 : 2; i < argTypes.length; ++i){\n                    var paramName = i === 1 ? \"thisWired\" : \"arg\" + (i - 2) + \"Wired\";\n                    if (argTypes[i].destructorFunction !== null) {\n                        invokerFnBody += paramName + \"_dtor(\" + paramName + \"); // \" + argTypes[i].name + \"\\n\";\n                        args1.push(paramName + \"_dtor\");\n                        args2.push(argTypes[i].destructorFunction);\n                    }\n                }\n            }\n            if (returns) {\n                invokerFnBody += \"var ret = retType.fromWireType(rv);\\n\" + \"return ret;\\n\";\n            } else {}\n            invokerFnBody += \"}\\n\";\n            args1.push(invokerFnBody);\n            var invokerFn = newFunc(Function, args1).apply(null, args2);\n            return createNamedFunction(humanName, invokerFn);\n        }\n        var heap32VectorToArray = (count, firstElement)=>{\n            var array = [];\n            for(var i = 0; i < count; i++){\n                array.push(HEAPU32[firstElement + i * 4 >> 2]);\n            }\n            return array;\n        };\n        var replacePublicSymbol = (name, value, numArguments)=>{\n            if (!Module.hasOwnProperty(name)) {\n                throwInternalError(\"Replacing nonexistant public symbol\");\n            }\n            if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\n                Module[name].overloadTable[numArguments] = value;\n            } else {\n                Module[name] = value;\n                Module[name].argCount = numArguments;\n            }\n        };\n        var dynCallLegacy = (sig, ptr, args)=>{\n            var f = Module[\"dynCall_\" + sig];\n            return args && args.length ? f.apply(null, [\n                ptr\n            ].concat(args)) : f.call(null, ptr);\n        };\n        var wasmTableMirror = [];\n        var wasmTable;\n        var getWasmTableEntry = (funcPtr)=>{\n            var func = wasmTableMirror[funcPtr];\n            if (!func) {\n                if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\n                wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\n            }\n            return func;\n        };\n        var dynCall = (sig, ptr, args)=>{\n            if (sig.includes(\"j\")) {\n                return dynCallLegacy(sig, ptr, args);\n            }\n            var rtn = getWasmTableEntry(ptr).apply(null, args);\n            return rtn;\n        };\n        var getDynCaller = (sig, ptr)=>{\n            var argCache = [];\n            return function() {\n                argCache.length = 0;\n                Object.assign(argCache, arguments);\n                return dynCall(sig, ptr, argCache);\n            };\n        };\n        var embind__requireFunction = (signature, rawFunction)=>{\n            signature = readLatin1String(signature);\n            function makeDynCaller() {\n                if (signature.includes(\"j\")) {\n                    return getDynCaller(signature, rawFunction);\n                }\n                return getWasmTableEntry(rawFunction);\n            }\n            var fp = makeDynCaller();\n            if (typeof fp != \"function\") {\n                throwBindingError(\"unknown function pointer with signature \".concat(signature, \": \").concat(rawFunction));\n            }\n            return fp;\n        };\n        var extendError = (baseErrorType, errorName)=>{\n            var errorClass = createNamedFunction(errorName, function(message) {\n                this.name = errorName;\n                this.message = message;\n                var stack = new Error(message).stack;\n                if (stack !== undefined) {\n                    this.stack = this.toString() + \"\\n\" + stack.replace(/^Error(:[^\\n]*)?\\n/, \"\");\n                }\n            });\n            errorClass.prototype = Object.create(baseErrorType.prototype);\n            errorClass.prototype.constructor = errorClass;\n            errorClass.prototype.toString = function() {\n                if (this.message === undefined) {\n                    return this.name;\n                } else {\n                    return \"\".concat(this.name, \": \").concat(this.message);\n                }\n            };\n            return errorClass;\n        };\n        var UnboundTypeError;\n        var throwUnboundTypeError = (message, types)=>{\n            var unboundTypes = [];\n            var seen = {};\n            function visit(type) {\n                if (seen[type]) {\n                    return;\n                }\n                if (registeredTypes[type]) {\n                    return;\n                }\n                if (typeDependencies[type]) {\n                    typeDependencies[type].forEach(visit);\n                    return;\n                }\n                unboundTypes.push(type);\n                seen[type] = true;\n            }\n            types.forEach(visit);\n            throw new UnboundTypeError(\"\".concat(message, \": \") + unboundTypes.map(getTypeName).join([\n                \", \"\n            ]));\n        };\n        var getFunctionName = (signature)=>{\n            signature = signature.trim();\n            const argsIndex = signature.indexOf(\"(\");\n            if (argsIndex !== -1) {\n                return signature.substr(0, argsIndex);\n            } else {\n                return signature;\n            }\n        };\n        var __embind_register_function = (name, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync)=>{\n            var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\n            name = readLatin1String(name);\n            name = getFunctionName(name);\n            rawInvoker = embind__requireFunction(signature, rawInvoker);\n            exposePublicSymbol(name, function() {\n                throwUnboundTypeError(\"Cannot call \".concat(name, \" due to unbound types\"), argTypes);\n            }, argCount - 1);\n            whenDependentTypesAreResolved([], argTypes, function(argTypes) {\n                var invokerArgsArray = [\n                    argTypes[0],\n                    null\n                ].concat(argTypes.slice(1));\n                replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);\n                return [];\n            });\n        };\n        var integerReadValueFromPointer = (name, width, signed)=>{\n            switch(width){\n                case 1:\n                    return signed ? (pointer)=>HEAP8[pointer >> 0] : (pointer)=>HEAPU8[pointer >> 0];\n                case 2:\n                    return signed ? (pointer)=>HEAP16[pointer >> 1] : (pointer)=>HEAPU16[pointer >> 1];\n                case 4:\n                    return signed ? (pointer)=>HEAP32[pointer >> 2] : (pointer)=>HEAPU32[pointer >> 2];\n                default:\n                    throw new TypeError(\"invalid integer width (\".concat(width, \"): \").concat(name));\n            }\n        };\n        var __embind_register_integer = (primitiveType, name, size, minRange, maxRange)=>{\n            name = readLatin1String(name);\n            if (maxRange === -1) {\n                maxRange = 4294967295;\n            }\n            var fromWireType = (value)=>value;\n            if (minRange === 0) {\n                var bitshift = 32 - 8 * size;\n                fromWireType = (value)=>value << bitshift >>> bitshift;\n            }\n            var isUnsignedType = name.includes(\"unsigned\");\n            var checkAssertions = (value, toTypeName)=>{};\n            var toWireType;\n            if (isUnsignedType) {\n                toWireType = function(destructors, value) {\n                    checkAssertions(value, this.name);\n                    return value >>> 0;\n                };\n            } else {\n                toWireType = function(destructors, value) {\n                    checkAssertions(value, this.name);\n                    return value;\n                };\n            }\n            registerType(primitiveType, {\n                name: name,\n                \"fromWireType\": fromWireType,\n                \"toWireType\": toWireType,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": integerReadValueFromPointer(name, size, minRange !== 0),\n                destructorFunction: null\n            });\n        };\n        var __embind_register_memory_view = (rawType, dataTypeIndex, name)=>{\n            var typeMapping = [\n                Int8Array,\n                Uint8Array,\n                Int16Array,\n                Uint16Array,\n                Int32Array,\n                Uint32Array,\n                Float32Array,\n                Float64Array\n            ];\n            var TA = typeMapping[dataTypeIndex];\n            function decodeMemoryView(handle) {\n                var size = HEAPU32[handle >> 2];\n                var data = HEAPU32[handle + 4 >> 2];\n                return new TA(HEAP8.buffer, data, size);\n            }\n            name = readLatin1String(name);\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": decodeMemoryView,\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": decodeMemoryView\n            }, {\n                ignoreDuplicateRegistrations: true\n            });\n        };\n        function readPointer(pointer) {\n            return this[\"fromWireType\"](HEAPU32[pointer >> 2]);\n        }\n        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite)=>{\n            if (!(maxBytesToWrite > 0)) return 0;\n            var startIdx = outIdx;\n            var endIdx = outIdx + maxBytesToWrite - 1;\n            for(var i = 0; i < str.length; ++i){\n                var u = str.charCodeAt(i);\n                if (u >= 55296 && u <= 57343) {\n                    var u1 = str.charCodeAt(++i);\n                    u = 65536 + ((u & 1023) << 10) | u1 & 1023;\n                }\n                if (u <= 127) {\n                    if (outIdx >= endIdx) break;\n                    heap[outIdx++] = u;\n                } else if (u <= 2047) {\n                    if (outIdx + 1 >= endIdx) break;\n                    heap[outIdx++] = 192 | u >> 6;\n                    heap[outIdx++] = 128 | u & 63;\n                } else if (u <= 65535) {\n                    if (outIdx + 2 >= endIdx) break;\n                    heap[outIdx++] = 224 | u >> 12;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                } else {\n                    if (outIdx + 3 >= endIdx) break;\n                    heap[outIdx++] = 240 | u >> 18;\n                    heap[outIdx++] = 128 | u >> 12 & 63;\n                    heap[outIdx++] = 128 | u >> 6 & 63;\n                    heap[outIdx++] = 128 | u & 63;\n                }\n            }\n            heap[outIdx] = 0;\n            return outIdx - startIdx;\n        };\n        var stringToUTF8 = (str, outPtr, maxBytesToWrite)=>stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n        var lengthBytesUTF8 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var c = str.charCodeAt(i);\n                if (c <= 127) {\n                    len++;\n                } else if (c <= 2047) {\n                    len += 2;\n                } else if (c >= 55296 && c <= 57343) {\n                    len += 4;\n                    ++i;\n                } else {\n                    len += 3;\n                }\n            }\n            return len;\n        };\n        var UTF8Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf8\") : undefined;\n        var UTF8ArrayToString = (heapOrArray, idx, maxBytesToRead)=>{\n            var endIdx = idx + maxBytesToRead;\n            var endPtr = idx;\n            while(heapOrArray[endPtr] && !(endPtr >= endIdx))++endPtr;\n            if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n                return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n            }\n            var str = \"\";\n            while(idx < endPtr){\n                var u0 = heapOrArray[idx++];\n                if (!(u0 & 128)) {\n                    str += String.fromCharCode(u0);\n                    continue;\n                }\n                var u1 = heapOrArray[idx++] & 63;\n                if ((u0 & 224) == 192) {\n                    str += String.fromCharCode((u0 & 31) << 6 | u1);\n                    continue;\n                }\n                var u2 = heapOrArray[idx++] & 63;\n                if ((u0 & 240) == 224) {\n                    u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n                } else {\n                    u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n                }\n                if (u0 < 65536) {\n                    str += String.fromCharCode(u0);\n                } else {\n                    var ch = u0 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                }\n            }\n            return str;\n        };\n        var UTF8ToString = (ptr, maxBytesToRead)=>ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : \"\";\n        var __embind_register_std_string = (rawType, name)=>{\n            name = readLatin1String(name);\n            var stdStringIsUTF8 = name === \"std::string\";\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\" (value) {\n                    var length = HEAPU32[value >> 2];\n                    var payload = value + 4;\n                    var str;\n                    if (stdStringIsUTF8) {\n                        var decodeStartPtr = payload;\n                        for(var i = 0; i <= length; ++i){\n                            var currentBytePtr = payload + i;\n                            if (i == length || HEAPU8[currentBytePtr] == 0) {\n                                var maxRead = currentBytePtr - decodeStartPtr;\n                                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\n                                if (str === undefined) {\n                                    str = stringSegment;\n                                } else {\n                                    str += String.fromCharCode(0);\n                                    str += stringSegment;\n                                }\n                                decodeStartPtr = currentBytePtr + 1;\n                            }\n                        }\n                    } else {\n                        var a = new Array(length);\n                        for(var i = 0; i < length; ++i){\n                            a[i] = String.fromCharCode(HEAPU8[payload + i]);\n                        }\n                        str = a.join(\"\");\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\" (destructors, value) {\n                    if (value instanceof ArrayBuffer) {\n                        value = new Uint8Array(value);\n                    }\n                    var length;\n                    var valueIsOfTypeString = typeof value == \"string\";\n                    if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\n                        throwBindingError(\"Cannot pass non-string to std::string\");\n                    }\n                    if (stdStringIsUTF8 && valueIsOfTypeString) {\n                        length = lengthBytesUTF8(value);\n                    } else {\n                        length = value.length;\n                    }\n                    var base = _malloc(4 + length + 1);\n                    var ptr = base + 4;\n                    HEAPU32[base >> 2] = length;\n                    if (stdStringIsUTF8 && valueIsOfTypeString) {\n                        stringToUTF8(value, ptr, length + 1);\n                    } else {\n                        if (valueIsOfTypeString) {\n                            for(var i = 0; i < length; ++i){\n                                var charCode = value.charCodeAt(i);\n                                if (charCode > 255) {\n                                    _free(ptr);\n                                    throwBindingError(\"String has UTF-16 code units that do not fit in 8 bits\");\n                                }\n                                HEAPU8[ptr + i] = charCode;\n                            }\n                        } else {\n                            for(var i = 0; i < length; ++i){\n                                HEAPU8[ptr + i] = value[i];\n                            }\n                        }\n                    }\n                    if (destructors !== null) {\n                        destructors.push(_free, base);\n                    }\n                    return base;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": readPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var UTF16Decoder = typeof TextDecoder != \"undefined\" ? new TextDecoder(\"utf-16le\") : undefined;\n        var UTF16ToString = (ptr, maxBytesToRead)=>{\n            var endPtr = ptr;\n            var idx = endPtr >> 1;\n            var maxIdx = idx + maxBytesToRead / 2;\n            while(!(idx >= maxIdx) && HEAPU16[idx])++idx;\n            endPtr = idx << 1;\n            if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\n            var str = \"\";\n            for(var i = 0; !(i >= maxBytesToRead / 2); ++i){\n                var codeUnit = HEAP16[ptr + i * 2 >> 1];\n                if (codeUnit == 0) break;\n                str += String.fromCharCode(codeUnit);\n            }\n            return str;\n        };\n        var stringToUTF16 = (str, outPtr, maxBytesToWrite)=>{\n            if (maxBytesToWrite === undefined) {\n                maxBytesToWrite = 2147483647;\n            }\n            if (maxBytesToWrite < 2) return 0;\n            maxBytesToWrite -= 2;\n            var startPtr = outPtr;\n            var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;\n            for(var i = 0; i < numCharsToWrite; ++i){\n                var codeUnit = str.charCodeAt(i);\n                HEAP16[outPtr >> 1] = codeUnit;\n                outPtr += 2;\n            }\n            HEAP16[outPtr >> 1] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF16 = (str)=>str.length * 2;\n        var UTF32ToString = (ptr, maxBytesToRead)=>{\n            var i = 0;\n            var str = \"\";\n            while(!(i >= maxBytesToRead / 4)){\n                var utf32 = HEAP32[ptr + i * 4 >> 2];\n                if (utf32 == 0) break;\n                ++i;\n                if (utf32 >= 65536) {\n                    var ch = utf32 - 65536;\n                    str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);\n                } else {\n                    str += String.fromCharCode(utf32);\n                }\n            }\n            return str;\n        };\n        var stringToUTF32 = (str, outPtr, maxBytesToWrite)=>{\n            if (maxBytesToWrite === undefined) {\n                maxBytesToWrite = 2147483647;\n            }\n            if (maxBytesToWrite < 4) return 0;\n            var startPtr = outPtr;\n            var endPtr = startPtr + maxBytesToWrite - 4;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) {\n                    var trailSurrogate = str.charCodeAt(++i);\n                    codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;\n                }\n                HEAP32[outPtr >> 2] = codeUnit;\n                outPtr += 4;\n                if (outPtr + 4 > endPtr) break;\n            }\n            HEAP32[outPtr >> 2] = 0;\n            return outPtr - startPtr;\n        };\n        var lengthBytesUTF32 = (str)=>{\n            var len = 0;\n            for(var i = 0; i < str.length; ++i){\n                var codeUnit = str.charCodeAt(i);\n                if (codeUnit >= 55296 && codeUnit <= 57343) ++i;\n                len += 4;\n            }\n            return len;\n        };\n        var __embind_register_std_wstring = (rawType, charSize, name)=>{\n            name = readLatin1String(name);\n            var decodeString, encodeString, getHeap, lengthBytesUTF, shift;\n            if (charSize === 2) {\n                decodeString = UTF16ToString;\n                encodeString = stringToUTF16;\n                lengthBytesUTF = lengthBytesUTF16;\n                getHeap = ()=>HEAPU16;\n                shift = 1;\n            } else if (charSize === 4) {\n                decodeString = UTF32ToString;\n                encodeString = stringToUTF32;\n                lengthBytesUTF = lengthBytesUTF32;\n                getHeap = ()=>HEAPU32;\n                shift = 2;\n            }\n            registerType(rawType, {\n                name: name,\n                \"fromWireType\": (value)=>{\n                    var length = HEAPU32[value >> 2];\n                    var HEAP = getHeap();\n                    var str;\n                    var decodeStartPtr = value + 4;\n                    for(var i = 0; i <= length; ++i){\n                        var currentBytePtr = value + 4 + i * charSize;\n                        if (i == length || HEAP[currentBytePtr >> shift] == 0) {\n                            var maxReadBytes = currentBytePtr - decodeStartPtr;\n                            var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\n                            if (str === undefined) {\n                                str = stringSegment;\n                            } else {\n                                str += String.fromCharCode(0);\n                                str += stringSegment;\n                            }\n                            decodeStartPtr = currentBytePtr + charSize;\n                        }\n                    }\n                    _free(value);\n                    return str;\n                },\n                \"toWireType\": (destructors, value)=>{\n                    if (!(typeof value == \"string\")) {\n                        throwBindingError(\"Cannot pass non-string to C++ string type \".concat(name));\n                    }\n                    var length = lengthBytesUTF(value);\n                    var ptr = _malloc(4 + length + charSize);\n                    HEAPU32[ptr >> 2] = length >> shift;\n                    encodeString(value, ptr + 4, length + charSize);\n                    if (destructors !== null) {\n                        destructors.push(_free, ptr);\n                    }\n                    return ptr;\n                },\n                \"argPackAdvance\": GenericWireTypeSize,\n                \"readValueFromPointer\": simpleReadValueFromPointer,\n                destructorFunction (ptr) {\n                    _free(ptr);\n                }\n            });\n        };\n        var __embind_register_value_array = (rawType, name, constructorSignature, rawConstructor, destructorSignature, rawDestructor)=>{\n            tupleRegistrations[rawType] = {\n                name: readLatin1String(name),\n                rawConstructor: embind__requireFunction(constructorSignature, rawConstructor),\n                rawDestructor: embind__requireFunction(destructorSignature, rawDestructor),\n                elements: []\n            };\n        };\n        var __embind_register_value_array_element = (rawTupleType, getterReturnType, getterSignature, getter, getterContext, setterArgumentType, setterSignature, setter, setterContext)=>{\n            tupleRegistrations[rawTupleType].elements.push({\n                getterReturnType: getterReturnType,\n                getter: embind__requireFunction(getterSignature, getter),\n                getterContext: getterContext,\n                setterArgumentType: setterArgumentType,\n                setter: embind__requireFunction(setterSignature, setter),\n                setterContext: setterContext\n            });\n        };\n        var __embind_register_void = (rawType, name)=>{\n            name = readLatin1String(name);\n            registerType(rawType, {\n                isVoid: true,\n                name: name,\n                \"argPackAdvance\": 0,\n                \"fromWireType\": ()=>undefined,\n                \"toWireType\": (destructors, o)=>undefined\n            });\n        };\n        var _abort = ()=>{\n            abort(\"\");\n        };\n        var _emscripten_memcpy_js = (dest, src, num)=>HEAPU8.copyWithin(dest, src, src + num);\n        var getHeapMax = ()=>2147483648;\n        var growMemory = (size)=>{\n            var b = wasmMemory.buffer;\n            var pages = (size - b.byteLength + 65535) / 65536;\n            try {\n                wasmMemory.grow(pages);\n                updateMemoryViews();\n                return 1;\n            } catch (e) {}\n        };\n        var _emscripten_resize_heap = (requestedSize)=>{\n            var oldSize = HEAPU8.length;\n            requestedSize >>>= 0;\n            var maxHeapSize = getHeapMax();\n            if (requestedSize > maxHeapSize) {\n                return false;\n            }\n            var alignUp = (x, multiple)=>x + (multiple - x % multiple) % multiple;\n            for(var cutDown = 1; cutDown <= 4; cutDown *= 2){\n                var overGrownHeapSize = oldSize * (1 + .2 / cutDown);\n                overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);\n                var newSize = Math.min(maxHeapSize, alignUp(Math.max(requestedSize, overGrownHeapSize), 65536));\n                var replacement = growMemory(newSize);\n                if (replacement) {\n                    return true;\n                }\n            }\n            return false;\n        };\n        var ENV = {};\n        var getExecutableName = ()=>thisProgram || \"./this.program\";\n        var getEnvStrings = ()=>{\n            if (!getEnvStrings.strings) {\n                var lang = (typeof navigator == \"object\" && navigator.languages && navigator.languages[0] || \"C\").replace(\"-\", \"_\") + \".UTF-8\";\n                var env = {\n                    \"USER\": \"web_user\",\n                    \"LOGNAME\": \"web_user\",\n                    \"PATH\": \"/\",\n                    \"PWD\": \"/\",\n                    \"HOME\": \"/home/web_user\",\n                    \"LANG\": lang,\n                    \"_\": getExecutableName()\n                };\n                for(var x in ENV){\n                    if (ENV[x] === undefined) delete env[x];\n                    else env[x] = ENV[x];\n                }\n                var strings = [];\n                for(var x in env){\n                    strings.push(\"\".concat(x, \"=\").concat(env[x]));\n                }\n                getEnvStrings.strings = strings;\n            }\n            return getEnvStrings.strings;\n        };\n        var stringToAscii = (str, buffer)=>{\n            for(var i = 0; i < str.length; ++i){\n                HEAP8[buffer++ >> 0] = str.charCodeAt(i);\n            }\n            HEAP8[buffer >> 0] = 0;\n        };\n        var PATH = {\n            isAbs: (path)=>path.charAt(0) === \"/\",\n            splitPath: (filename)=>{\n                var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n                return splitPathRe.exec(filename).slice(1);\n            },\n            normalizeArray: (parts, allowAboveRoot)=>{\n                var up = 0;\n                for(var i = parts.length - 1; i >= 0; i--){\n                    var last = parts[i];\n                    if (last === \".\") {\n                        parts.splice(i, 1);\n                    } else if (last === \"..\") {\n                        parts.splice(i, 1);\n                        up++;\n                    } else if (up) {\n                        parts.splice(i, 1);\n                        up--;\n                    }\n                }\n                if (allowAboveRoot) {\n                    for(; up; up--){\n                        parts.unshift(\"..\");\n                    }\n                }\n                return parts;\n            },\n            normalize: (path)=>{\n                var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === \"/\";\n                path = PATH.normalizeArray(path.split(\"/\").filter((p)=>!!p), !isAbsolute).join(\"/\");\n                if (!path && !isAbsolute) {\n                    path = \".\";\n                }\n                if (path && trailingSlash) {\n                    path += \"/\";\n                }\n                return (isAbsolute ? \"/\" : \"\") + path;\n            },\n            dirname: (path)=>{\n                var result = PATH.splitPath(path), root = result[0], dir = result[1];\n                if (!root && !dir) {\n                    return \".\";\n                }\n                if (dir) {\n                    dir = dir.substr(0, dir.length - 1);\n                }\n                return root + dir;\n            },\n            basename: (path)=>{\n                if (path === \"/\") return \"/\";\n                path = PATH.normalize(path);\n                path = path.replace(/\\/$/, \"\");\n                var lastSlash = path.lastIndexOf(\"/\");\n                if (lastSlash === -1) return path;\n                return path.substr(lastSlash + 1);\n            },\n            join: function() {\n                var paths = Array.prototype.slice.call(arguments);\n                return PATH.normalize(paths.join(\"/\"));\n            },\n            join2: (l, r)=>PATH.normalize(l + \"/\" + r)\n        };\n        var initRandomFill = ()=>{\n            if (typeof crypto == \"object\" && typeof crypto[\"getRandomValues\"] == \"function\") {\n                return (view)=>crypto.getRandomValues(view);\n            } else abort(\"initRandomDevice\");\n        };\n        var randomFill = (view)=>(randomFill = initRandomFill())(view);\n        var PATH_FS = {\n            resolve: function() {\n                var resolvedPath = \"\", resolvedAbsolute = false;\n                for(var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--){\n                    var path = i >= 0 ? arguments[i] : FS.cwd();\n                    if (typeof path != \"string\") {\n                        throw new TypeError(\"Arguments to path.resolve must be strings\");\n                    } else if (!path) {\n                        return \"\";\n                    }\n                    resolvedPath = path + \"/\" + resolvedPath;\n                    resolvedAbsolute = PATH.isAbs(path);\n                }\n                resolvedPath = PATH.normalizeArray(resolvedPath.split(\"/\").filter((p)=>!!p), !resolvedAbsolute).join(\"/\");\n                return (resolvedAbsolute ? \"/\" : \"\") + resolvedPath || \".\";\n            },\n            relative: (from, to)=>{\n                from = PATH_FS.resolve(from).substr(1);\n                to = PATH_FS.resolve(to).substr(1);\n                function trim(arr) {\n                    var start = 0;\n                    for(; start < arr.length; start++){\n                        if (arr[start] !== \"\") break;\n                    }\n                    var end = arr.length - 1;\n                    for(; end >= 0; end--){\n                        if (arr[end] !== \"\") break;\n                    }\n                    if (start > end) return [];\n                    return arr.slice(start, end - start + 1);\n                }\n                var fromParts = trim(from.split(\"/\"));\n                var toParts = trim(to.split(\"/\"));\n                var length = Math.min(fromParts.length, toParts.length);\n                var samePartsLength = length;\n                for(var i = 0; i < length; i++){\n                    if (fromParts[i] !== toParts[i]) {\n                        samePartsLength = i;\n                        break;\n                    }\n                }\n                var outputParts = [];\n                for(var i = samePartsLength; i < fromParts.length; i++){\n                    outputParts.push(\"..\");\n                }\n                outputParts = outputParts.concat(toParts.slice(samePartsLength));\n                return outputParts.join(\"/\");\n            }\n        };\n        var FS_stdin_getChar_buffer = [];\n        function intArrayFromString(stringy, dontAddNull, length) {\n            var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n            var u8array = new Array(len);\n            var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n            if (dontAddNull) u8array.length = numBytesWritten;\n            return u8array;\n        }\n        var FS_stdin_getChar = ()=>{\n            if (!FS_stdin_getChar_buffer.length) {\n                var result = null;\n                if ( true && typeof window.prompt == \"function\") {\n                    result = window.prompt(\"Input: \");\n                    if (result !== null) {\n                        result += \"\\n\";\n                    }\n                } else if (typeof readline == \"function\") {\n                    result = readline();\n                    if (result !== null) {\n                        result += \"\\n\";\n                    }\n                }\n                if (!result) {\n                    return null;\n                }\n                FS_stdin_getChar_buffer = intArrayFromString(result, true);\n            }\n            return FS_stdin_getChar_buffer.shift();\n        };\n        var TTY = {\n            ttys: [],\n            init () {},\n            shutdown () {},\n            register (dev, ops) {\n                TTY.ttys[dev] = {\n                    input: [],\n                    output: [],\n                    ops: ops\n                };\n                FS.registerDevice(dev, TTY.stream_ops);\n            },\n            stream_ops: {\n                open (stream) {\n                    var tty = TTY.ttys[stream.node.rdev];\n                    if (!tty) {\n                        throw new FS.ErrnoError(43);\n                    }\n                    stream.tty = tty;\n                    stream.seekable = false;\n                },\n                close (stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                fsync (stream) {\n                    stream.tty.ops.fsync(stream.tty);\n                },\n                read (stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.get_char) {\n                        throw new FS.ErrnoError(60);\n                    }\n                    var bytesRead = 0;\n                    for(var i = 0; i < length; i++){\n                        var result;\n                        try {\n                            result = stream.tty.ops.get_char(stream.tty);\n                        } catch (e) {\n                            throw new FS.ErrnoError(29);\n                        }\n                        if (result === undefined && bytesRead === 0) {\n                            throw new FS.ErrnoError(6);\n                        }\n                        if (result === null || result === undefined) break;\n                        bytesRead++;\n                        buffer[offset + i] = result;\n                    }\n                    if (bytesRead) {\n                        stream.node.timestamp = Date.now();\n                    }\n                    return bytesRead;\n                },\n                write (stream, buffer, offset, length, pos) {\n                    if (!stream.tty || !stream.tty.ops.put_char) {\n                        throw new FS.ErrnoError(60);\n                    }\n                    try {\n                        for(var i = 0; i < length; i++){\n                            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n                        }\n                    } catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                    if (length) {\n                        stream.node.timestamp = Date.now();\n                    }\n                    return i;\n                }\n            },\n            default_tty_ops: {\n                get_char (tty) {\n                    return FS_stdin_getChar();\n                },\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else {\n                        if (val != 0) tty.output.push(val);\n                    }\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        out(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                },\n                ioctl_tcgets (tty) {\n                    return {\n                        c_iflag: 25856,\n                        c_oflag: 5,\n                        c_cflag: 191,\n                        c_lflag: 35387,\n                        c_cc: [\n                            3,\n                            28,\n                            127,\n                            21,\n                            4,\n                            0,\n                            1,\n                            0,\n                            17,\n                            19,\n                            26,\n                            0,\n                            18,\n                            15,\n                            23,\n                            22,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0,\n                            0\n                        ]\n                    };\n                },\n                ioctl_tcsets (tty, optional_actions, data) {\n                    return 0;\n                },\n                ioctl_tiocgwinsz (tty) {\n                    return [\n                        24,\n                        80\n                    ];\n                }\n            },\n            default_tty1_ops: {\n                put_char (tty, val) {\n                    if (val === null || val === 10) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    } else {\n                        if (val != 0) tty.output.push(val);\n                    }\n                },\n                fsync (tty) {\n                    if (tty.output && tty.output.length > 0) {\n                        err(UTF8ArrayToString(tty.output, 0));\n                        tty.output = [];\n                    }\n                }\n            }\n        };\n        var mmapAlloc = (size)=>{\n            abort();\n        };\n        var MEMFS = {\n            ops_table: null,\n            mount (mount) {\n                return MEMFS.createNode(null, \"/\", 16384 | 511, 0);\n            },\n            createNode (parent, name, mode, dev) {\n                if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (!MEMFS.ops_table) {\n                    MEMFS.ops_table = {\n                        dir: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr,\n                                lookup: MEMFS.node_ops.lookup,\n                                mknod: MEMFS.node_ops.mknod,\n                                rename: MEMFS.node_ops.rename,\n                                unlink: MEMFS.node_ops.unlink,\n                                rmdir: MEMFS.node_ops.rmdir,\n                                readdir: MEMFS.node_ops.readdir,\n                                symlink: MEMFS.node_ops.symlink\n                            },\n                            stream: {\n                                llseek: MEMFS.stream_ops.llseek\n                            }\n                        },\n                        file: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr\n                            },\n                            stream: {\n                                llseek: MEMFS.stream_ops.llseek,\n                                read: MEMFS.stream_ops.read,\n                                write: MEMFS.stream_ops.write,\n                                allocate: MEMFS.stream_ops.allocate,\n                                mmap: MEMFS.stream_ops.mmap,\n                                msync: MEMFS.stream_ops.msync\n                            }\n                        },\n                        link: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr,\n                                readlink: MEMFS.node_ops.readlink\n                            },\n                            stream: {}\n                        },\n                        chrdev: {\n                            node: {\n                                getattr: MEMFS.node_ops.getattr,\n                                setattr: MEMFS.node_ops.setattr\n                            },\n                            stream: FS.chrdev_stream_ops\n                        }\n                    };\n                }\n                var node = FS.createNode(parent, name, mode, dev);\n                if (FS.isDir(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.dir.node;\n                    node.stream_ops = MEMFS.ops_table.dir.stream;\n                    node.contents = {};\n                } else if (FS.isFile(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.file.node;\n                    node.stream_ops = MEMFS.ops_table.file.stream;\n                    node.usedBytes = 0;\n                    node.contents = null;\n                } else if (FS.isLink(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.link.node;\n                    node.stream_ops = MEMFS.ops_table.link.stream;\n                } else if (FS.isChrdev(node.mode)) {\n                    node.node_ops = MEMFS.ops_table.chrdev.node;\n                    node.stream_ops = MEMFS.ops_table.chrdev.stream;\n                }\n                node.timestamp = Date.now();\n                if (parent) {\n                    parent.contents[name] = node;\n                    parent.timestamp = node.timestamp;\n                }\n                return node;\n            },\n            getFileDataAsTypedArray (node) {\n                if (!node.contents) return new Uint8Array(0);\n                if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);\n                return new Uint8Array(node.contents);\n            },\n            expandFileStorage (node, newCapacity) {\n                var prevCapacity = node.contents ? node.contents.length : 0;\n                if (prevCapacity >= newCapacity) return;\n                var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n                newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);\n                if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);\n                var oldContents = node.contents;\n                node.contents = new Uint8Array(newCapacity);\n                if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);\n            },\n            resizeFileStorage (node, newSize) {\n                if (node.usedBytes == newSize) return;\n                if (newSize == 0) {\n                    node.contents = null;\n                    node.usedBytes = 0;\n                } else {\n                    var oldContents = node.contents;\n                    node.contents = new Uint8Array(newSize);\n                    if (oldContents) {\n                        node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));\n                    }\n                    node.usedBytes = newSize;\n                }\n            },\n            node_ops: {\n                getattr (node) {\n                    var attr = {};\n                    attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n                    attr.ino = node.id;\n                    attr.mode = node.mode;\n                    attr.nlink = 1;\n                    attr.uid = 0;\n                    attr.gid = 0;\n                    attr.rdev = node.rdev;\n                    if (FS.isDir(node.mode)) {\n                        attr.size = 4096;\n                    } else if (FS.isFile(node.mode)) {\n                        attr.size = node.usedBytes;\n                    } else if (FS.isLink(node.mode)) {\n                        attr.size = node.link.length;\n                    } else {\n                        attr.size = 0;\n                    }\n                    attr.atime = new Date(node.timestamp);\n                    attr.mtime = new Date(node.timestamp);\n                    attr.ctime = new Date(node.timestamp);\n                    attr.blksize = 4096;\n                    attr.blocks = Math.ceil(attr.size / attr.blksize);\n                    return attr;\n                },\n                setattr (node, attr) {\n                    if (attr.mode !== undefined) {\n                        node.mode = attr.mode;\n                    }\n                    if (attr.timestamp !== undefined) {\n                        node.timestamp = attr.timestamp;\n                    }\n                    if (attr.size !== undefined) {\n                        MEMFS.resizeFileStorage(node, attr.size);\n                    }\n                },\n                lookup (parent, name) {\n                    throw FS.genericErrors[44];\n                },\n                mknod (parent, name, mode, dev) {\n                    return MEMFS.createNode(parent, name, mode, dev);\n                },\n                rename (old_node, new_dir, new_name) {\n                    if (FS.isDir(old_node.mode)) {\n                        var new_node;\n                        try {\n                            new_node = FS.lookupNode(new_dir, new_name);\n                        } catch (e) {}\n                        if (new_node) {\n                            for(var i in new_node.contents){\n                                throw new FS.ErrnoError(55);\n                            }\n                        }\n                    }\n                    delete old_node.parent.contents[old_node.name];\n                    old_node.parent.timestamp = Date.now();\n                    old_node.name = new_name;\n                    new_dir.contents[new_name] = old_node;\n                    new_dir.timestamp = old_node.parent.timestamp;\n                    old_node.parent = new_dir;\n                },\n                unlink (parent, name) {\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                rmdir (parent, name) {\n                    var node = FS.lookupNode(parent, name);\n                    for(var i in node.contents){\n                        throw new FS.ErrnoError(55);\n                    }\n                    delete parent.contents[name];\n                    parent.timestamp = Date.now();\n                },\n                readdir (node) {\n                    var entries = [\n                        \".\",\n                        \"..\"\n                    ];\n                    for(var key in node.contents){\n                        if (!node.contents.hasOwnProperty(key)) {\n                            continue;\n                        }\n                        entries.push(key);\n                    }\n                    return entries;\n                },\n                symlink (parent, newname, oldpath) {\n                    var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);\n                    node.link = oldpath;\n                    return node;\n                },\n                readlink (node) {\n                    if (!FS.isLink(node.mode)) {\n                        throw new FS.ErrnoError(28);\n                    }\n                    return node.link;\n                }\n            },\n            stream_ops: {\n                read (stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= stream.node.usedBytes) return 0;\n                    var size = Math.min(stream.node.usedBytes - position, length);\n                    if (size > 8 && contents.subarray) {\n                        buffer.set(contents.subarray(position, position + size), offset);\n                    } else {\n                        for(var i = 0; i < size; i++)buffer[offset + i] = contents[position + i];\n                    }\n                    return size;\n                },\n                write (stream, buffer, offset, length, position, canOwn) {\n                    if (buffer.buffer === HEAP8.buffer) {\n                        canOwn = false;\n                    }\n                    if (!length) return 0;\n                    var node = stream.node;\n                    node.timestamp = Date.now();\n                    if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n                        if (canOwn) {\n                            node.contents = buffer.subarray(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (node.usedBytes === 0 && position === 0) {\n                            node.contents = buffer.slice(offset, offset + length);\n                            node.usedBytes = length;\n                            return length;\n                        } else if (position + length <= node.usedBytes) {\n                            node.contents.set(buffer.subarray(offset, offset + length), position);\n                            return length;\n                        }\n                    }\n                    MEMFS.expandFileStorage(node, position + length);\n                    if (node.contents.subarray && buffer.subarray) {\n                        node.contents.set(buffer.subarray(offset, offset + length), position);\n                    } else {\n                        for(var i = 0; i < length; i++){\n                            node.contents[position + i] = buffer[offset + i];\n                        }\n                    }\n                    node.usedBytes = Math.max(node.usedBytes, position + length);\n                    return length;\n                },\n                llseek (stream, offset, whence) {\n                    var position = offset;\n                    if (whence === 1) {\n                        position += stream.position;\n                    } else if (whence === 2) {\n                        if (FS.isFile(stream.node.mode)) {\n                            position += stream.node.usedBytes;\n                        }\n                    }\n                    if (position < 0) {\n                        throw new FS.ErrnoError(28);\n                    }\n                    return position;\n                },\n                allocate (stream, offset, length) {\n                    MEMFS.expandFileStorage(stream.node, offset + length);\n                    stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n                },\n                mmap (stream, length, position, prot, flags) {\n                    if (!FS.isFile(stream.node.mode)) {\n                        throw new FS.ErrnoError(43);\n                    }\n                    var ptr;\n                    var allocated;\n                    var contents = stream.node.contents;\n                    if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n                        allocated = false;\n                        ptr = contents.byteOffset;\n                    } else {\n                        if (position > 0 || position + length < contents.length) {\n                            if (contents.subarray) {\n                                contents = contents.subarray(position, position + length);\n                            } else {\n                                contents = Array.prototype.slice.call(contents, position, position + length);\n                            }\n                        }\n                        allocated = true;\n                        ptr = mmapAlloc(length);\n                        if (!ptr) {\n                            throw new FS.ErrnoError(48);\n                        }\n                        HEAP8.set(contents, ptr);\n                    }\n                    return {\n                        ptr: ptr,\n                        allocated: allocated\n                    };\n                },\n                msync (stream, buffer, offset, length, mmapFlags) {\n                    MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n                    return 0;\n                }\n            }\n        };\n        var asyncLoad = (url, onload, onerror, noRunDep)=>{\n            var dep = !noRunDep ? getUniqueRunDependency(\"al \".concat(url)) : \"\";\n            readAsync(url, (arrayBuffer)=>{\n                assert(arrayBuffer, 'Loading data file \"'.concat(url, '\" failed (no arrayBuffer).'));\n                onload(new Uint8Array(arrayBuffer));\n                if (dep) removeRunDependency(dep);\n            }, (event)=>{\n                if (onerror) {\n                    onerror();\n                } else {\n                    throw 'Loading data file \"'.concat(url, '\" failed.');\n                }\n            });\n            if (dep) addRunDependency(dep);\n        };\n        var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn)=>{\n            FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n        };\n        var preloadPlugins = Module[\"preloadPlugins\"] || [];\n        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror)=>{\n            if (typeof Browser != \"undefined\") Browser.init();\n            var handled = false;\n            preloadPlugins.forEach((plugin)=>{\n                if (handled) return;\n                if (plugin[\"canHandle\"](fullname)) {\n                    plugin[\"handle\"](byteArray, fullname, finish, onerror);\n                    handled = true;\n                }\n            });\n            return handled;\n        };\n        var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish)=>{\n            var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n            var dep = getUniqueRunDependency(\"cp \".concat(fullname));\n            function processData(byteArray) {\n                function finish(byteArray) {\n                    if (preFinish) preFinish();\n                    if (!dontCreateFile) {\n                        FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n                    }\n                    if (onload) onload();\n                    removeRunDependency(dep);\n                }\n                if (FS_handledByPreloadPlugin(byteArray, fullname, finish, ()=>{\n                    if (onerror) onerror();\n                    removeRunDependency(dep);\n                })) {\n                    return;\n                }\n                finish(byteArray);\n            }\n            addRunDependency(dep);\n            if (typeof url == \"string\") {\n                asyncLoad(url, (byteArray)=>processData(byteArray), onerror);\n            } else {\n                processData(url);\n            }\n        };\n        var FS_modeStringToFlags = (str)=>{\n            var flagModes = {\n                \"r\": 0,\n                \"r+\": 2,\n                \"w\": 512 | 64 | 1,\n                \"w+\": 512 | 64 | 2,\n                \"a\": 1024 | 64 | 1,\n                \"a+\": 1024 | 64 | 2\n            };\n            var flags = flagModes[str];\n            if (typeof flags == \"undefined\") {\n                throw new Error(\"Unknown file open mode: \".concat(str));\n            }\n            return flags;\n        };\n        var FS_getMode = (canRead, canWrite)=>{\n            var mode = 0;\n            if (canRead) mode |= 292 | 73;\n            if (canWrite) mode |= 146;\n            return mode;\n        };\n        var FS = {\n            root: null,\n            mounts: [],\n            devices: {},\n            streams: [],\n            nextInode: 1,\n            nameTable: null,\n            currentPath: \"/\",\n            initialized: false,\n            ignorePermissions: true,\n            ErrnoError: null,\n            genericErrors: {},\n            filesystems: null,\n            syncFSRequests: 0,\n            lookupPath (path) {\n                let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                path = PATH_FS.resolve(path);\n                if (!path) return {\n                    path: \"\",\n                    node: null\n                };\n                var defaults = {\n                    follow_mount: true,\n                    recurse_count: 0\n                };\n                opts = Object.assign(defaults, opts);\n                if (opts.recurse_count > 8) {\n                    throw new FS.ErrnoError(32);\n                }\n                var parts = path.split(\"/\").filter((p)=>!!p);\n                var current = FS.root;\n                var current_path = \"/\";\n                for(var i = 0; i < parts.length; i++){\n                    var islast = i === parts.length - 1;\n                    if (islast && opts.parent) {\n                        break;\n                    }\n                    current = FS.lookupNode(current, parts[i]);\n                    current_path = PATH.join2(current_path, parts[i]);\n                    if (FS.isMountpoint(current)) {\n                        if (!islast || islast && opts.follow_mount) {\n                            current = current.mounted.root;\n                        }\n                    }\n                    if (!islast || opts.follow) {\n                        var count = 0;\n                        while(FS.isLink(current.mode)){\n                            var link = FS.readlink(current_path);\n                            current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n                            var lookup = FS.lookupPath(current_path, {\n                                recurse_count: opts.recurse_count + 1\n                            });\n                            current = lookup.node;\n                            if (count++ > 40) {\n                                throw new FS.ErrnoError(32);\n                            }\n                        }\n                    }\n                }\n                return {\n                    path: current_path,\n                    node: current\n                };\n            },\n            getPath (node) {\n                var path;\n                while(true){\n                    if (FS.isRoot(node)) {\n                        var mount = node.mount.mountpoint;\n                        if (!path) return mount;\n                        return mount[mount.length - 1] !== \"/\" ? \"\".concat(mount, \"/\").concat(path) : mount + path;\n                    }\n                    path = path ? \"\".concat(node.name, \"/\").concat(path) : node.name;\n                    node = node.parent;\n                }\n            },\n            hashName (parentid, name) {\n                var hash = 0;\n                for(var i = 0; i < name.length; i++){\n                    hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n                }\n                return (parentid + hash >>> 0) % FS.nameTable.length;\n            },\n            hashAddNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                node.name_next = FS.nameTable[hash];\n                FS.nameTable[hash] = node;\n            },\n            hashRemoveNode (node) {\n                var hash = FS.hashName(node.parent.id, node.name);\n                if (FS.nameTable[hash] === node) {\n                    FS.nameTable[hash] = node.name_next;\n                } else {\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        if (current.name_next === node) {\n                            current.name_next = node.name_next;\n                            break;\n                        }\n                        current = current.name_next;\n                    }\n                }\n            },\n            lookupNode (parent, name) {\n                var errCode = FS.mayLookup(parent);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode, parent);\n                }\n                var hash = FS.hashName(parent.id, name);\n                for(var node = FS.nameTable[hash]; node; node = node.name_next){\n                    var nodeName = node.name;\n                    if (node.parent.id === parent.id && nodeName === name) {\n                        return node;\n                    }\n                }\n                return FS.lookup(parent, name);\n            },\n            createNode (parent, name, mode, rdev) {\n                var node = new FS.FSNode(parent, name, mode, rdev);\n                FS.hashAddNode(node);\n                return node;\n            },\n            destroyNode (node) {\n                FS.hashRemoveNode(node);\n            },\n            isRoot (node) {\n                return node === node.parent;\n            },\n            isMountpoint (node) {\n                return !!node.mounted;\n            },\n            isFile (mode) {\n                return (mode & 61440) === 32768;\n            },\n            isDir (mode) {\n                return (mode & 61440) === 16384;\n            },\n            isLink (mode) {\n                return (mode & 61440) === 40960;\n            },\n            isChrdev (mode) {\n                return (mode & 61440) === 8192;\n            },\n            isBlkdev (mode) {\n                return (mode & 61440) === 24576;\n            },\n            isFIFO (mode) {\n                return (mode & 61440) === 4096;\n            },\n            isSocket (mode) {\n                return (mode & 49152) === 49152;\n            },\n            flagsToPermissionString (flag) {\n                var perms = [\n                    \"r\",\n                    \"w\",\n                    \"rw\"\n                ][flag & 3];\n                if (flag & 512) {\n                    perms += \"w\";\n                }\n                return perms;\n            },\n            nodePermissions (node, perms) {\n                if (FS.ignorePermissions) {\n                    return 0;\n                }\n                if (perms.includes(\"r\") && !(node.mode & 292)) {\n                    return 2;\n                } else if (perms.includes(\"w\") && !(node.mode & 146)) {\n                    return 2;\n                } else if (perms.includes(\"x\") && !(node.mode & 73)) {\n                    return 2;\n                }\n                return 0;\n            },\n            mayLookup (dir) {\n                var errCode = FS.nodePermissions(dir, \"x\");\n                if (errCode) return errCode;\n                if (!dir.node_ops.lookup) return 2;\n                return 0;\n            },\n            mayCreate (dir, name) {\n                try {\n                    var node = FS.lookupNode(dir, name);\n                    return 20;\n                } catch (e) {}\n                return FS.nodePermissions(dir, \"wx\");\n            },\n            mayDelete (dir, name, isdir) {\n                var node;\n                try {\n                    node = FS.lookupNode(dir, name);\n                } catch (e) {\n                    return e.errno;\n                }\n                var errCode = FS.nodePermissions(dir, \"wx\");\n                if (errCode) {\n                    return errCode;\n                }\n                if (isdir) {\n                    if (!FS.isDir(node.mode)) {\n                        return 54;\n                    }\n                    if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n                        return 10;\n                    }\n                } else {\n                    if (FS.isDir(node.mode)) {\n                        return 31;\n                    }\n                }\n                return 0;\n            },\n            mayOpen (node, flags) {\n                if (!node) {\n                    return 44;\n                }\n                if (FS.isLink(node.mode)) {\n                    return 32;\n                } else if (FS.isDir(node.mode)) {\n                    if (FS.flagsToPermissionString(flags) !== \"r\" || flags & 512) {\n                        return 31;\n                    }\n                }\n                return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n            },\n            MAX_OPEN_FDS: 4096,\n            nextfd () {\n                for(var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++){\n                    if (!FS.streams[fd]) {\n                        return fd;\n                    }\n                }\n                throw new FS.ErrnoError(33);\n            },\n            getStreamChecked (fd) {\n                var stream = FS.getStream(fd);\n                if (!stream) {\n                    throw new FS.ErrnoError(8);\n                }\n                return stream;\n            },\n            getStream: (fd)=>FS.streams[fd],\n            createStream (stream) {\n                let fd = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : -1;\n                if (!FS.FSStream) {\n                    FS.FSStream = function() {\n                        this.shared = {};\n                    };\n                    FS.FSStream.prototype = {};\n                    Object.defineProperties(FS.FSStream.prototype, {\n                        object: {\n                            get () {\n                                return this.node;\n                            },\n                            set (val) {\n                                this.node = val;\n                            }\n                        },\n                        isRead: {\n                            get () {\n                                return (this.flags & 2097155) !== 1;\n                            }\n                        },\n                        isWrite: {\n                            get () {\n                                return (this.flags & 2097155) !== 0;\n                            }\n                        },\n                        isAppend: {\n                            get () {\n                                return this.flags & 1024;\n                            }\n                        },\n                        flags: {\n                            get () {\n                                return this.shared.flags;\n                            },\n                            set (val) {\n                                this.shared.flags = val;\n                            }\n                        },\n                        position: {\n                            get () {\n                                return this.shared.position;\n                            },\n                            set (val) {\n                                this.shared.position = val;\n                            }\n                        }\n                    });\n                }\n                stream = Object.assign(new FS.FSStream, stream);\n                if (fd == -1) {\n                    fd = FS.nextfd();\n                }\n                stream.fd = fd;\n                FS.streams[fd] = stream;\n                return stream;\n            },\n            closeStream (fd) {\n                FS.streams[fd] = null;\n            },\n            chrdev_stream_ops: {\n                open (stream) {\n                    var device = FS.getDevice(stream.node.rdev);\n                    stream.stream_ops = device.stream_ops;\n                    if (stream.stream_ops.open) {\n                        stream.stream_ops.open(stream);\n                    }\n                },\n                llseek () {\n                    throw new FS.ErrnoError(70);\n                }\n            },\n            major: (dev)=>dev >> 8,\n            minor: (dev)=>dev & 255,\n            makedev: (ma, mi)=>ma << 8 | mi,\n            registerDevice (dev, ops) {\n                FS.devices[dev] = {\n                    stream_ops: ops\n                };\n            },\n            getDevice: (dev)=>FS.devices[dev],\n            getMounts (mount) {\n                var mounts = [];\n                var check = [\n                    mount\n                ];\n                while(check.length){\n                    var m = check.pop();\n                    mounts.push(m);\n                    check.push.apply(check, m.mounts);\n                }\n                return mounts;\n            },\n            syncfs (populate, callback) {\n                if (typeof populate == \"function\") {\n                    callback = populate;\n                    populate = false;\n                }\n                FS.syncFSRequests++;\n                if (FS.syncFSRequests > 1) {\n                    err(\"warning: \".concat(FS.syncFSRequests, \" FS.syncfs operations in flight at once, probably just doing extra work\"));\n                }\n                var mounts = FS.getMounts(FS.root.mount);\n                var completed = 0;\n                function doCallback(errCode) {\n                    FS.syncFSRequests--;\n                    return callback(errCode);\n                }\n                function done(errCode) {\n                    if (errCode) {\n                        if (!done.errored) {\n                            done.errored = true;\n                            return doCallback(errCode);\n                        }\n                        return;\n                    }\n                    if (++completed >= mounts.length) {\n                        doCallback(null);\n                    }\n                }\n                mounts.forEach((mount)=>{\n                    if (!mount.type.syncfs) {\n                        return done(null);\n                    }\n                    mount.type.syncfs(mount, populate, done);\n                });\n            },\n            mount (type, opts, mountpoint) {\n                var root = mountpoint === \"/\";\n                var pseudo = !mountpoint;\n                var node;\n                if (root && FS.root) {\n                    throw new FS.ErrnoError(10);\n                } else if (!root && !pseudo) {\n                    var lookup = FS.lookupPath(mountpoint, {\n                        follow_mount: false\n                    });\n                    mountpoint = lookup.path;\n                    node = lookup.node;\n                    if (FS.isMountpoint(node)) {\n                        throw new FS.ErrnoError(10);\n                    }\n                    if (!FS.isDir(node.mode)) {\n                        throw new FS.ErrnoError(54);\n                    }\n                }\n                var mount = {\n                    type: type,\n                    opts: opts,\n                    mountpoint: mountpoint,\n                    mounts: []\n                };\n                var mountRoot = type.mount(mount);\n                mountRoot.mount = mount;\n                mount.root = mountRoot;\n                if (root) {\n                    FS.root = mountRoot;\n                } else if (node) {\n                    node.mounted = mount;\n                    if (node.mount) {\n                        node.mount.mounts.push(mount);\n                    }\n                }\n                return mountRoot;\n            },\n            unmount (mountpoint) {\n                var lookup = FS.lookupPath(mountpoint, {\n                    follow_mount: false\n                });\n                if (!FS.isMountpoint(lookup.node)) {\n                    throw new FS.ErrnoError(28);\n                }\n                var node = lookup.node;\n                var mount = node.mounted;\n                var mounts = FS.getMounts(mount);\n                Object.keys(FS.nameTable).forEach((hash)=>{\n                    var current = FS.nameTable[hash];\n                    while(current){\n                        var next = current.name_next;\n                        if (mounts.includes(current.mount)) {\n                            FS.destroyNode(current);\n                        }\n                        current = next;\n                    }\n                });\n                node.mounted = null;\n                var idx = node.mount.mounts.indexOf(mount);\n                node.mount.mounts.splice(idx, 1);\n            },\n            lookup (parent, name) {\n                return parent.node_ops.lookup(parent, name);\n            },\n            mknod (path, mode, dev) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                if (!name || name === \".\" || name === \"..\") {\n                    throw new FS.ErrnoError(28);\n                }\n                var errCode = FS.mayCreate(parent, name);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.mknod) {\n                    throw new FS.ErrnoError(63);\n                }\n                return parent.node_ops.mknod(parent, name, mode, dev);\n            },\n            create (path, mode) {\n                mode = mode !== undefined ? mode : 438;\n                mode &= 4095;\n                mode |= 32768;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdir (path, mode) {\n                mode = mode !== undefined ? mode : 511;\n                mode &= 511 | 512;\n                mode |= 16384;\n                return FS.mknod(path, mode, 0);\n            },\n            mkdirTree (path, mode) {\n                var dirs = path.split(\"/\");\n                var d = \"\";\n                for(var i = 0; i < dirs.length; ++i){\n                    if (!dirs[i]) continue;\n                    d += \"/\" + dirs[i];\n                    try {\n                        FS.mkdir(d, mode);\n                    } catch (e) {\n                        if (e.errno != 20) throw e;\n                    }\n                }\n            },\n            mkdev (path, mode, dev) {\n                if (typeof dev == \"undefined\") {\n                    dev = mode;\n                    mode = 438;\n                }\n                mode |= 8192;\n                return FS.mknod(path, mode, dev);\n            },\n            symlink (oldpath, newpath) {\n                if (!PATH_FS.resolve(oldpath)) {\n                    throw new FS.ErrnoError(44);\n                }\n                var lookup = FS.lookupPath(newpath, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) {\n                    throw new FS.ErrnoError(44);\n                }\n                var newname = PATH.basename(newpath);\n                var errCode = FS.mayCreate(parent, newname);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.symlink) {\n                    throw new FS.ErrnoError(63);\n                }\n                return parent.node_ops.symlink(parent, newname, oldpath);\n            },\n            rename (old_path, new_path) {\n                var old_dirname = PATH.dirname(old_path);\n                var new_dirname = PATH.dirname(new_path);\n                var old_name = PATH.basename(old_path);\n                var new_name = PATH.basename(new_path);\n                var lookup, old_dir, new_dir;\n                lookup = FS.lookupPath(old_path, {\n                    parent: true\n                });\n                old_dir = lookup.node;\n                lookup = FS.lookupPath(new_path, {\n                    parent: true\n                });\n                new_dir = lookup.node;\n                if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n                if (old_dir.mount !== new_dir.mount) {\n                    throw new FS.ErrnoError(75);\n                }\n                var old_node = FS.lookupNode(old_dir, old_name);\n                var relative = PATH_FS.relative(old_path, new_dirname);\n                if (relative.charAt(0) !== \".\") {\n                    throw new FS.ErrnoError(28);\n                }\n                relative = PATH_FS.relative(new_path, old_dirname);\n                if (relative.charAt(0) !== \".\") {\n                    throw new FS.ErrnoError(55);\n                }\n                var new_node;\n                try {\n                    new_node = FS.lookupNode(new_dir, new_name);\n                } catch (e) {}\n                if (old_node === new_node) {\n                    return;\n                }\n                var isdir = FS.isDir(old_node.mode);\n                var errCode = FS.mayDelete(old_dir, old_name, isdir);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!old_dir.node_ops.rename) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                if (new_dir !== old_dir) {\n                    errCode = FS.nodePermissions(old_dir, \"w\");\n                    if (errCode) {\n                        throw new FS.ErrnoError(errCode);\n                    }\n                }\n                FS.hashRemoveNode(old_node);\n                try {\n                    old_dir.node_ops.rename(old_node, new_dir, new_name);\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.hashAddNode(old_node);\n                }\n            },\n            rmdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, true);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.rmdir) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                parent.node_ops.rmdir(parent, name);\n                FS.destroyNode(node);\n            },\n            readdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                if (!node.node_ops.readdir) {\n                    throw new FS.ErrnoError(54);\n                }\n                return node.node_ops.readdir(node);\n            },\n            unlink (path) {\n                var lookup = FS.lookupPath(path, {\n                    parent: true\n                });\n                var parent = lookup.node;\n                if (!parent) {\n                    throw new FS.ErrnoError(44);\n                }\n                var name = PATH.basename(path);\n                var node = FS.lookupNode(parent, name);\n                var errCode = FS.mayDelete(parent, name, false);\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                if (!parent.node_ops.unlink) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isMountpoint(node)) {\n                    throw new FS.ErrnoError(10);\n                }\n                parent.node_ops.unlink(parent, name);\n                FS.destroyNode(node);\n            },\n            readlink (path) {\n                var lookup = FS.lookupPath(path);\n                var link = lookup.node;\n                if (!link) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!link.node_ops.readlink) {\n                    throw new FS.ErrnoError(28);\n                }\n                return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n            },\n            stat (path, dontFollow) {\n                var lookup = FS.lookupPath(path, {\n                    follow: !dontFollow\n                });\n                var node = lookup.node;\n                if (!node) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!node.node_ops.getattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                return node.node_ops.getattr(node);\n            },\n            lstat (path) {\n                return FS.stat(path, true);\n            },\n            chmod (path, mode, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                node.node_ops.setattr(node, {\n                    mode: mode & 4095 | node.mode & ~4095,\n                    timestamp: Date.now()\n                });\n            },\n            lchmod (path, mode) {\n                FS.chmod(path, mode, true);\n            },\n            fchmod (fd, mode) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chmod(stream.node, mode);\n            },\n            chown (path, uid, gid, dontFollow) {\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontFollow\n                    });\n                    node = lookup.node;\n                } else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                node.node_ops.setattr(node, {\n                    timestamp: Date.now()\n                });\n            },\n            lchown (path, uid, gid) {\n                FS.chown(path, uid, gid, true);\n            },\n            fchown (fd, uid, gid) {\n                var stream = FS.getStreamChecked(fd);\n                FS.chown(stream.node, uid, gid);\n            },\n            truncate (path, len) {\n                if (len < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                var node;\n                if (typeof path == \"string\") {\n                    var lookup = FS.lookupPath(path, {\n                        follow: true\n                    });\n                    node = lookup.node;\n                } else {\n                    node = path;\n                }\n                if (!node.node_ops.setattr) {\n                    throw new FS.ErrnoError(63);\n                }\n                if (FS.isDir(node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!FS.isFile(node.mode)) {\n                    throw new FS.ErrnoError(28);\n                }\n                var errCode = FS.nodePermissions(node, \"w\");\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                node.node_ops.setattr(node, {\n                    size: len,\n                    timestamp: Date.now()\n                });\n            },\n            ftruncate (fd, len) {\n                var stream = FS.getStreamChecked(fd);\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                FS.truncate(stream.node, len);\n            },\n            utime (path, atime, mtime) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                var node = lookup.node;\n                node.node_ops.setattr(node, {\n                    timestamp: Math.max(atime, mtime)\n                });\n            },\n            open (path, flags, mode) {\n                if (path === \"\") {\n                    throw new FS.ErrnoError(44);\n                }\n                flags = typeof flags == \"string\" ? FS_modeStringToFlags(flags) : flags;\n                mode = typeof mode == \"undefined\" ? 438 : mode;\n                if (flags & 64) {\n                    mode = mode & 4095 | 32768;\n                } else {\n                    mode = 0;\n                }\n                var node;\n                if (typeof path == \"object\") {\n                    node = path;\n                } else {\n                    path = PATH.normalize(path);\n                    try {\n                        var lookup = FS.lookupPath(path, {\n                            follow: !(flags & 131072)\n                        });\n                        node = lookup.node;\n                    } catch (e) {}\n                }\n                var created = false;\n                if (flags & 64) {\n                    if (node) {\n                        if (flags & 128) {\n                            throw new FS.ErrnoError(20);\n                        }\n                    } else {\n                        node = FS.mknod(path, mode, 0);\n                        created = true;\n                    }\n                }\n                if (!node) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (FS.isChrdev(node.mode)) {\n                    flags &= ~512;\n                }\n                if (flags & 65536 && !FS.isDir(node.mode)) {\n                    throw new FS.ErrnoError(54);\n                }\n                if (!created) {\n                    var errCode = FS.mayOpen(node, flags);\n                    if (errCode) {\n                        throw new FS.ErrnoError(errCode);\n                    }\n                }\n                if (flags & 512 && !created) {\n                    FS.truncate(node, 0);\n                }\n                flags &= ~(128 | 512 | 131072);\n                var stream = FS.createStream({\n                    node: node,\n                    path: FS.getPath(node),\n                    flags: flags,\n                    seekable: true,\n                    position: 0,\n                    stream_ops: node.stream_ops,\n                    ungotten: [],\n                    error: false\n                });\n                if (stream.stream_ops.open) {\n                    stream.stream_ops.open(stream);\n                }\n                if (Module[\"logReadFiles\"] && !(flags & 1)) {\n                    if (!FS.readFiles) FS.readFiles = {};\n                    if (!(path in FS.readFiles)) {\n                        FS.readFiles[path] = 1;\n                    }\n                }\n                return stream;\n            },\n            close (stream) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (stream.getdents) stream.getdents = null;\n                try {\n                    if (stream.stream_ops.close) {\n                        stream.stream_ops.close(stream);\n                    }\n                } catch (e) {\n                    throw e;\n                } finally{\n                    FS.closeStream(stream.fd);\n                }\n                stream.fd = null;\n            },\n            isClosed (stream) {\n                return stream.fd === null;\n            },\n            llseek (stream, offset, whence) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (!stream.seekable || !stream.stream_ops.llseek) {\n                    throw new FS.ErrnoError(70);\n                }\n                if (whence != 0 && whence != 1 && whence != 2) {\n                    throw new FS.ErrnoError(28);\n                }\n                stream.position = stream.stream_ops.llseek(stream, offset, whence);\n                stream.ungotten = [];\n                return stream.position;\n            },\n            read (stream, buffer, offset, length, position) {\n                if (length < 0 || position < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if ((stream.flags & 2097155) === 1) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!stream.stream_ops.read) {\n                    throw new FS.ErrnoError(28);\n                }\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) {\n                    position = stream.position;\n                } else if (!stream.seekable) {\n                    throw new FS.ErrnoError(70);\n                }\n                var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n                if (!seeking) stream.position += bytesRead;\n                return bytesRead;\n            },\n            write (stream, buffer, offset, length, position, canOwn) {\n                if (length < 0 || position < 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(31);\n                }\n                if (!stream.stream_ops.write) {\n                    throw new FS.ErrnoError(28);\n                }\n                if (stream.seekable && stream.flags & 1024) {\n                    FS.llseek(stream, 0, 2);\n                }\n                var seeking = typeof position != \"undefined\";\n                if (!seeking) {\n                    position = stream.position;\n                } else if (!stream.seekable) {\n                    throw new FS.ErrnoError(70);\n                }\n                var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n                if (!seeking) stream.position += bytesWritten;\n                return bytesWritten;\n            },\n            allocate (stream, offset, length) {\n                if (FS.isClosed(stream)) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (offset < 0 || length <= 0) {\n                    throw new FS.ErrnoError(28);\n                }\n                if ((stream.flags & 2097155) === 0) {\n                    throw new FS.ErrnoError(8);\n                }\n                if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n                    throw new FS.ErrnoError(43);\n                }\n                if (!stream.stream_ops.allocate) {\n                    throw new FS.ErrnoError(138);\n                }\n                stream.stream_ops.allocate(stream, offset, length);\n            },\n            mmap (stream, length, position, prot, flags) {\n                if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n                    throw new FS.ErrnoError(2);\n                }\n                if ((stream.flags & 2097155) === 1) {\n                    throw new FS.ErrnoError(2);\n                }\n                if (!stream.stream_ops.mmap) {\n                    throw new FS.ErrnoError(43);\n                }\n                return stream.stream_ops.mmap(stream, length, position, prot, flags);\n            },\n            msync (stream, buffer, offset, length, mmapFlags) {\n                if (!stream.stream_ops.msync) {\n                    return 0;\n                }\n                return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n            },\n            munmap: (stream)=>0,\n            ioctl (stream, cmd, arg) {\n                if (!stream.stream_ops.ioctl) {\n                    throw new FS.ErrnoError(59);\n                }\n                return stream.stream_ops.ioctl(stream, cmd, arg);\n            },\n            readFile (path) {\n                let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n                opts.flags = opts.flags || 0;\n                opts.encoding = opts.encoding || \"binary\";\n                if (opts.encoding !== \"utf8\" && opts.encoding !== \"binary\") {\n                    throw new Error('Invalid encoding type \"'.concat(opts.encoding, '\"'));\n                }\n                var ret;\n                var stream = FS.open(path, opts.flags);\n                var stat = FS.stat(path);\n                var length = stat.size;\n                var buf = new Uint8Array(length);\n                FS.read(stream, buf, 0, length, 0);\n                if (opts.encoding === \"utf8\") {\n                    ret = UTF8ArrayToString(buf, 0);\n                } else if (opts.encoding === \"binary\") {\n                    ret = buf;\n                }\n                FS.close(stream);\n                return ret;\n            },\n            writeFile (path, data) {\n                let opts = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n                opts.flags = opts.flags || 577;\n                var stream = FS.open(path, opts.flags, opts.mode);\n                if (typeof data == \"string\") {\n                    var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n                    var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n                    FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n                } else if (ArrayBuffer.isView(data)) {\n                    FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n                } else {\n                    throw new Error(\"Unsupported data type\");\n                }\n                FS.close(stream);\n            },\n            cwd: ()=>FS.currentPath,\n            chdir (path) {\n                var lookup = FS.lookupPath(path, {\n                    follow: true\n                });\n                if (lookup.node === null) {\n                    throw new FS.ErrnoError(44);\n                }\n                if (!FS.isDir(lookup.node.mode)) {\n                    throw new FS.ErrnoError(54);\n                }\n                var errCode = FS.nodePermissions(lookup.node, \"x\");\n                if (errCode) {\n                    throw new FS.ErrnoError(errCode);\n                }\n                FS.currentPath = lookup.path;\n            },\n            createDefaultDirectories () {\n                FS.mkdir(\"/tmp\");\n                FS.mkdir(\"/home\");\n                FS.mkdir(\"/home/web_user\");\n            },\n            createDefaultDevices () {\n                FS.mkdir(\"/dev\");\n                FS.registerDevice(FS.makedev(1, 3), {\n                    read: ()=>0,\n                    write: (stream, buffer, offset, length, pos)=>length\n                });\n                FS.mkdev(\"/dev/null\", FS.makedev(1, 3));\n                TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n                TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n                FS.mkdev(\"/dev/tty\", FS.makedev(5, 0));\n                FS.mkdev(\"/dev/tty1\", FS.makedev(6, 0));\n                var randomBuffer = new Uint8Array(1024), randomLeft = 0;\n                var randomByte = ()=>{\n                    if (randomLeft === 0) {\n                        randomLeft = randomFill(randomBuffer).byteLength;\n                    }\n                    return randomBuffer[--randomLeft];\n                };\n                FS.createDevice(\"/dev\", \"random\", randomByte);\n                FS.createDevice(\"/dev\", \"urandom\", randomByte);\n                FS.mkdir(\"/dev/shm\");\n                FS.mkdir(\"/dev/shm/tmp\");\n            },\n            createSpecialDirectories () {\n                FS.mkdir(\"/proc\");\n                var proc_self = FS.mkdir(\"/proc/self\");\n                FS.mkdir(\"/proc/self/fd\");\n                FS.mount({\n                    mount () {\n                        var node = FS.createNode(proc_self, \"fd\", 16384 | 511, 73);\n                        node.node_ops = {\n                            lookup (parent, name) {\n                                var fd = +name;\n                                var stream = FS.getStreamChecked(fd);\n                                var ret = {\n                                    parent: null,\n                                    mount: {\n                                        mountpoint: \"fake\"\n                                    },\n                                    node_ops: {\n                                        readlink: ()=>stream.path\n                                    }\n                                };\n                                ret.parent = ret;\n                                return ret;\n                            }\n                        };\n                        return node;\n                    }\n                }, {}, \"/proc/self/fd\");\n            },\n            createStandardStreams () {\n                if (Module[\"stdin\"]) {\n                    FS.createDevice(\"/dev\", \"stdin\", Module[\"stdin\"]);\n                } else {\n                    FS.symlink(\"/dev/tty\", \"/dev/stdin\");\n                }\n                if (Module[\"stdout\"]) {\n                    FS.createDevice(\"/dev\", \"stdout\", null, Module[\"stdout\"]);\n                } else {\n                    FS.symlink(\"/dev/tty\", \"/dev/stdout\");\n                }\n                if (Module[\"stderr\"]) {\n                    FS.createDevice(\"/dev\", \"stderr\", null, Module[\"stderr\"]);\n                } else {\n                    FS.symlink(\"/dev/tty1\", \"/dev/stderr\");\n                }\n                var stdin = FS.open(\"/dev/stdin\", 0);\n                var stdout = FS.open(\"/dev/stdout\", 1);\n                var stderr = FS.open(\"/dev/stderr\", 1);\n            },\n            ensureErrnoError () {\n                if (FS.ErrnoError) return;\n                FS.ErrnoError = function ErrnoError(errno, node) {\n                    this.name = \"ErrnoError\";\n                    this.node = node;\n                    this.setErrno = function(errno) {\n                        this.errno = errno;\n                    };\n                    this.setErrno(errno);\n                    this.message = \"FS error\";\n                };\n                FS.ErrnoError.prototype = new Error;\n                FS.ErrnoError.prototype.constructor = FS.ErrnoError;\n                [\n                    44\n                ].forEach((code)=>{\n                    FS.genericErrors[code] = new FS.ErrnoError(code);\n                    FS.genericErrors[code].stack = \"<generic error, no stack>\";\n                });\n            },\n            staticInit () {\n                FS.ensureErrnoError();\n                FS.nameTable = new Array(4096);\n                FS.mount(MEMFS, {}, \"/\");\n                FS.createDefaultDirectories();\n                FS.createDefaultDevices();\n                FS.createSpecialDirectories();\n                FS.filesystems = {\n                    \"MEMFS\": MEMFS\n                };\n            },\n            init (input, output, error) {\n                FS.init.initialized = true;\n                FS.ensureErrnoError();\n                Module[\"stdin\"] = input || Module[\"stdin\"];\n                Module[\"stdout\"] = output || Module[\"stdout\"];\n                Module[\"stderr\"] = error || Module[\"stderr\"];\n                FS.createStandardStreams();\n            },\n            quit () {\n                FS.init.initialized = false;\n                for(var i = 0; i < FS.streams.length; i++){\n                    var stream = FS.streams[i];\n                    if (!stream) {\n                        continue;\n                    }\n                    FS.close(stream);\n                }\n            },\n            findObject (path, dontResolveLastLink) {\n                var ret = FS.analyzePath(path, dontResolveLastLink);\n                if (!ret.exists) {\n                    return null;\n                }\n                return ret.object;\n            },\n            analyzePath (path, dontResolveLastLink) {\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    path = lookup.path;\n                } catch (e) {}\n                var ret = {\n                    isRoot: false,\n                    exists: false,\n                    error: 0,\n                    name: null,\n                    path: null,\n                    object: null,\n                    parentExists: false,\n                    parentPath: null,\n                    parentObject: null\n                };\n                try {\n                    var lookup = FS.lookupPath(path, {\n                        parent: true\n                    });\n                    ret.parentExists = true;\n                    ret.parentPath = lookup.path;\n                    ret.parentObject = lookup.node;\n                    ret.name = PATH.basename(path);\n                    lookup = FS.lookupPath(path, {\n                        follow: !dontResolveLastLink\n                    });\n                    ret.exists = true;\n                    ret.path = lookup.path;\n                    ret.object = lookup.node;\n                    ret.name = lookup.node.name;\n                    ret.isRoot = lookup.path === \"/\";\n                } catch (e) {\n                    ret.error = e.errno;\n                }\n                return ret;\n            },\n            createPath (parent, path, canRead, canWrite) {\n                parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                var parts = path.split(\"/\").reverse();\n                while(parts.length){\n                    var part = parts.pop();\n                    if (!part) continue;\n                    var current = PATH.join2(parent, part);\n                    try {\n                        FS.mkdir(current);\n                    } catch (e) {}\n                    parent = current;\n                }\n                return current;\n            },\n            createFile (parent, name, properties, canRead, canWrite) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(canRead, canWrite);\n                return FS.create(path, mode);\n            },\n            createDataFile (parent, name, data, canRead, canWrite, canOwn) {\n                var path = name;\n                if (parent) {\n                    parent = typeof parent == \"string\" ? parent : FS.getPath(parent);\n                    path = name ? PATH.join2(parent, name) : parent;\n                }\n                var mode = FS_getMode(canRead, canWrite);\n                var node = FS.create(path, mode);\n                if (data) {\n                    if (typeof data == \"string\") {\n                        var arr = new Array(data.length);\n                        for(var i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i);\n                        data = arr;\n                    }\n                    FS.chmod(node, mode | 146);\n                    var stream = FS.open(node, 577);\n                    FS.write(stream, data, 0, data.length, 0, canOwn);\n                    FS.close(stream);\n                    FS.chmod(node, mode);\n                }\n            },\n            createDevice (parent, name, input, output) {\n                var path = PATH.join2(typeof parent == \"string\" ? parent : FS.getPath(parent), name);\n                var mode = FS_getMode(!!input, !!output);\n                if (!FS.createDevice.major) FS.createDevice.major = 64;\n                var dev = FS.makedev(FS.createDevice.major++, 0);\n                FS.registerDevice(dev, {\n                    open (stream) {\n                        stream.seekable = false;\n                    },\n                    close (stream) {\n                        if (output && output.buffer && output.buffer.length) {\n                            output(10);\n                        }\n                    },\n                    read (stream, buffer, offset, length, pos) {\n                        var bytesRead = 0;\n                        for(var i = 0; i < length; i++){\n                            var result;\n                            try {\n                                result = input();\n                            } catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                            if (result === undefined && bytesRead === 0) {\n                                throw new FS.ErrnoError(6);\n                            }\n                            if (result === null || result === undefined) break;\n                            bytesRead++;\n                            buffer[offset + i] = result;\n                        }\n                        if (bytesRead) {\n                            stream.node.timestamp = Date.now();\n                        }\n                        return bytesRead;\n                    },\n                    write (stream, buffer, offset, length, pos) {\n                        for(var i = 0; i < length; i++){\n                            try {\n                                output(buffer[offset + i]);\n                            } catch (e) {\n                                throw new FS.ErrnoError(29);\n                            }\n                        }\n                        if (length) {\n                            stream.node.timestamp = Date.now();\n                        }\n                        return i;\n                    }\n                });\n                return FS.mkdev(path, mode, dev);\n            },\n            forceLoadFile (obj) {\n                if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n                if (typeof XMLHttpRequest != \"undefined\") {\n                    throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n                } else if (read_) {\n                    try {\n                        obj.contents = intArrayFromString(read_(obj.url), true);\n                        obj.usedBytes = obj.contents.length;\n                    } catch (e) {\n                        throw new FS.ErrnoError(29);\n                    }\n                } else {\n                    throw new Error(\"Cannot load without read() or XMLHttpRequest.\");\n                }\n            },\n            createLazyFile (parent, name, url, canRead, canWrite) {\n                function LazyUint8Array() {\n                    this.lengthKnown = false;\n                    this.chunks = [];\n                }\n                LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) {\n                    if (idx > this.length - 1 || idx < 0) {\n                        return undefined;\n                    }\n                    var chunkOffset = idx % this.chunkSize;\n                    var chunkNum = idx / this.chunkSize | 0;\n                    return this.getter(chunkNum)[chunkOffset];\n                };\n                LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {\n                    this.getter = getter;\n                };\n                LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {\n                    var xhr = new XMLHttpRequest;\n                    xhr.open(\"HEAD\", url, false);\n                    xhr.send(null);\n                    if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                    var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n                    var header;\n                    var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n                    var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n                    var chunkSize = 1024 * 1024;\n                    if (!hasByteServing) chunkSize = datalength;\n                    var doXHR = (from, to)=>{\n                        if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n                        if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n                        var xhr = new XMLHttpRequest;\n                        xhr.open(\"GET\", url, false);\n                        if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n                        xhr.responseType = \"arraybuffer\";\n                        if (xhr.overrideMimeType) {\n                            xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\n                        }\n                        xhr.send(null);\n                        if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                        if (xhr.response !== undefined) {\n                            return new Uint8Array(xhr.response || []);\n                        }\n                        return intArrayFromString(xhr.responseText || \"\", true);\n                    };\n                    var lazyArray = this;\n                    lazyArray.setDataGetter((chunkNum)=>{\n                        var start = chunkNum * chunkSize;\n                        var end = (chunkNum + 1) * chunkSize - 1;\n                        end = Math.min(end, datalength - 1);\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") {\n                            lazyArray.chunks[chunkNum] = doXHR(start, end);\n                        }\n                        if (typeof lazyArray.chunks[chunkNum] == \"undefined\") throw new Error(\"doXHR failed!\");\n                        return lazyArray.chunks[chunkNum];\n                    });\n                    if (usesGzip || !datalength) {\n                        chunkSize = datalength = 1;\n                        datalength = this.getter(0).length;\n                        chunkSize = datalength;\n                        out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n                    }\n                    this._length = datalength;\n                    this._chunkSize = chunkSize;\n                    this.lengthKnown = true;\n                };\n                if (typeof XMLHttpRequest != \"undefined\") {\n                    if (!ENVIRONMENT_IS_WORKER) throw \"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc\";\n                    var lazyArray = new LazyUint8Array;\n                    Object.defineProperties(lazyArray, {\n                        length: {\n                            get: function() {\n                                if (!this.lengthKnown) {\n                                    this.cacheLength();\n                                }\n                                return this._length;\n                            }\n                        },\n                        chunkSize: {\n                            get: function() {\n                                if (!this.lengthKnown) {\n                                    this.cacheLength();\n                                }\n                                return this._chunkSize;\n                            }\n                        }\n                    });\n                    var properties = {\n                        isDevice: false,\n                        contents: lazyArray\n                    };\n                } else {\n                    var properties = {\n                        isDevice: false,\n                        url: url\n                    };\n                }\n                var node = FS.createFile(parent, name, properties, canRead, canWrite);\n                if (properties.contents) {\n                    node.contents = properties.contents;\n                } else if (properties.url) {\n                    node.contents = null;\n                    node.url = properties.url;\n                }\n                Object.defineProperties(node, {\n                    usedBytes: {\n                        get: function() {\n                            return this.contents.length;\n                        }\n                    }\n                });\n                var stream_ops = {};\n                var keys = Object.keys(node.stream_ops);\n                keys.forEach((key)=>{\n                    var fn = node.stream_ops[key];\n                    stream_ops[key] = function forceLoadLazyFile() {\n                        FS.forceLoadFile(node);\n                        return fn.apply(null, arguments);\n                    };\n                });\n                function writeChunks(stream, buffer, offset, length, position) {\n                    var contents = stream.node.contents;\n                    if (position >= contents.length) return 0;\n                    var size = Math.min(contents.length - position, length);\n                    if (contents.slice) {\n                        for(var i = 0; i < size; i++){\n                            buffer[offset + i] = contents[position + i];\n                        }\n                    } else {\n                        for(var i = 0; i < size; i++){\n                            buffer[offset + i] = contents.get(position + i);\n                        }\n                    }\n                    return size;\n                }\n                stream_ops.read = (stream, buffer, offset, length, position)=>{\n                    FS.forceLoadFile(node);\n                    return writeChunks(stream, buffer, offset, length, position);\n                };\n                stream_ops.mmap = (stream, length, position, prot, flags)=>{\n                    FS.forceLoadFile(node);\n                    var ptr = mmapAlloc(length);\n                    if (!ptr) {\n                        throw new FS.ErrnoError(48);\n                    }\n                    writeChunks(stream, HEAP8, ptr, length, position);\n                    return {\n                        ptr: ptr,\n                        allocated: true\n                    };\n                };\n                node.stream_ops = stream_ops;\n                return node;\n            }\n        };\n        var SYSCALLS = {\n            DEFAULT_POLLMASK: 5,\n            calculateAt (dirfd, path, allowEmpty) {\n                if (PATH.isAbs(path)) {\n                    return path;\n                }\n                var dir;\n                if (dirfd === -100) {\n                    dir = FS.cwd();\n                } else {\n                    var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n                    dir = dirstream.path;\n                }\n                if (path.length == 0) {\n                    if (!allowEmpty) {\n                        throw new FS.ErrnoError(44);\n                    }\n                    return dir;\n                }\n                return PATH.join2(dir, path);\n            },\n            doStat (func, path, buf) {\n                try {\n                    var stat = func(path);\n                } catch (e) {\n                    if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {\n                        return -54;\n                    }\n                    throw e;\n                }\n                HEAP32[buf >> 2] = stat.dev;\n                HEAP32[buf + 4 >> 2] = stat.mode;\n                HEAPU32[buf + 8 >> 2] = stat.nlink;\n                HEAP32[buf + 12 >> 2] = stat.uid;\n                HEAP32[buf + 16 >> 2] = stat.gid;\n                HEAP32[buf + 20 >> 2] = stat.rdev;\n                tempI64 = [\n                    stat.size >>> 0,\n                    (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];\n                HEAP32[buf + 32 >> 2] = 4096;\n                HEAP32[buf + 36 >> 2] = stat.blocks;\n                var atime = stat.atime.getTime();\n                var mtime = stat.mtime.getTime();\n                var ctime = stat.ctime.getTime();\n                tempI64 = [\n                    Math.floor(atime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n                HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3;\n                tempI64 = [\n                    Math.floor(mtime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];\n                HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3;\n                tempI64 = [\n                    Math.floor(ctime / 1e3) >>> 0,\n                    (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];\n                HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3;\n                tempI64 = [\n                    stat.ino >>> 0,\n                    (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];\n                return 0;\n            },\n            doMsync (addr, stream, len, flags, offset) {\n                if (!FS.isFile(stream.node.mode)) {\n                    throw new FS.ErrnoError(43);\n                }\n                if (flags & 2) {\n                    return 0;\n                }\n                var buffer = HEAPU8.slice(addr, addr + len);\n                FS.msync(stream, buffer, offset, len, flags);\n            },\n            varargs: undefined,\n            get () {\n                var ret = HEAP32[+SYSCALLS.varargs >> 2];\n                SYSCALLS.varargs += 4;\n                return ret;\n            },\n            getp () {\n                return SYSCALLS.get();\n            },\n            getStr (ptr) {\n                var ret = UTF8ToString(ptr);\n                return ret;\n            },\n            getStreamFromFD (fd) {\n                var stream = FS.getStreamChecked(fd);\n                return stream;\n            }\n        };\n        var _environ_get = (__environ, environ_buf)=>{\n            var bufSize = 0;\n            getEnvStrings().forEach((string, i)=>{\n                var ptr = environ_buf + bufSize;\n                HEAPU32[__environ + i * 4 >> 2] = ptr;\n                stringToAscii(string, ptr);\n                bufSize += string.length + 1;\n            });\n            return 0;\n        };\n        var _environ_sizes_get = (penviron_count, penviron_buf_size)=>{\n            var strings = getEnvStrings();\n            HEAPU32[penviron_count >> 2] = strings.length;\n            var bufSize = 0;\n            strings.forEach((string)=>bufSize += string.length + 1);\n            HEAPU32[penviron_buf_size >> 2] = bufSize;\n            return 0;\n        };\n        function _fd_close(fd) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.close(stream);\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var doReadv = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = HEAPU32[iov >> 2];\n                var len = HEAPU32[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.read(stream, HEAP8, ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (curr < len) break;\n                if (typeof offset !== \"undefined\") {\n                    offset += curr;\n                }\n            }\n            return ret;\n        };\n        function _fd_read(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doReadv(stream, iov, iovcnt);\n                HEAPU32[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var convertI32PairToI53Checked = (lo, hi)=>hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n        function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n            var offset = convertI32PairToI53Checked(offset_low, offset_high);\n            try {\n                if (isNaN(offset)) return 61;\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                FS.llseek(stream, offset, whence);\n                tempI64 = [\n                    stream.position >>> 0,\n                    (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)\n                ], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n                if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var doWritev = (stream, iov, iovcnt, offset)=>{\n            var ret = 0;\n            for(var i = 0; i < iovcnt; i++){\n                var ptr = HEAPU32[iov >> 2];\n                var len = HEAPU32[iov + 4 >> 2];\n                iov += 8;\n                var curr = FS.write(stream, HEAP8, ptr, len, offset);\n                if (curr < 0) return -1;\n                ret += curr;\n                if (typeof offset !== \"undefined\") {\n                    offset += curr;\n                }\n            }\n            return ret;\n        };\n        function _fd_write(fd, iov, iovcnt, pnum) {\n            try {\n                var stream = SYSCALLS.getStreamFromFD(fd);\n                var num = doWritev(stream, iov, iovcnt);\n                HEAPU32[pnum >> 2] = num;\n                return 0;\n            } catch (e) {\n                if (typeof FS == \"undefined\" || !(e.name === \"ErrnoError\")) throw e;\n                return e.errno;\n            }\n        }\n        var isLeapYear = (year)=>year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n        var arraySum = (array, index)=>{\n            var sum = 0;\n            for(var i = 0; i <= index; sum += array[i++]){}\n            return sum;\n        };\n        var MONTH_DAYS_LEAP = [\n            31,\n            29,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var MONTH_DAYS_REGULAR = [\n            31,\n            28,\n            31,\n            30,\n            31,\n            30,\n            31,\n            31,\n            30,\n            31,\n            30,\n            31\n        ];\n        var addDays = (date, days)=>{\n            var newDate = new Date(date.getTime());\n            while(days > 0){\n                var leap = isLeapYear(newDate.getFullYear());\n                var currentMonth = newDate.getMonth();\n                var daysInCurrentMonth = (leap ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR)[currentMonth];\n                if (days > daysInCurrentMonth - newDate.getDate()) {\n                    days -= daysInCurrentMonth - newDate.getDate() + 1;\n                    newDate.setDate(1);\n                    if (currentMonth < 11) {\n                        newDate.setMonth(currentMonth + 1);\n                    } else {\n                        newDate.setMonth(0);\n                        newDate.setFullYear(newDate.getFullYear() + 1);\n                    }\n                } else {\n                    newDate.setDate(newDate.getDate() + days);\n                    return newDate;\n                }\n            }\n            return newDate;\n        };\n        var writeArrayToMemory = (array, buffer)=>{\n            HEAP8.set(array, buffer);\n        };\n        var _strftime = (s, maxsize, format, tm)=>{\n            var tm_zone = HEAPU32[tm + 40 >> 2];\n            var date = {\n                tm_sec: HEAP32[tm >> 2],\n                tm_min: HEAP32[tm + 4 >> 2],\n                tm_hour: HEAP32[tm + 8 >> 2],\n                tm_mday: HEAP32[tm + 12 >> 2],\n                tm_mon: HEAP32[tm + 16 >> 2],\n                tm_year: HEAP32[tm + 20 >> 2],\n                tm_wday: HEAP32[tm + 24 >> 2],\n                tm_yday: HEAP32[tm + 28 >> 2],\n                tm_isdst: HEAP32[tm + 32 >> 2],\n                tm_gmtoff: HEAP32[tm + 36 >> 2],\n                tm_zone: tm_zone ? UTF8ToString(tm_zone) : \"\"\n            };\n            var pattern = UTF8ToString(format);\n            var EXPANSION_RULES_1 = {\n                \"%c\": \"%a %b %d %H:%M:%S %Y\",\n                \"%D\": \"%m/%d/%y\",\n                \"%F\": \"%Y-%m-%d\",\n                \"%h\": \"%b\",\n                \"%r\": \"%I:%M:%S %p\",\n                \"%R\": \"%H:%M\",\n                \"%T\": \"%H:%M:%S\",\n                \"%x\": \"%m/%d/%y\",\n                \"%X\": \"%H:%M:%S\",\n                \"%Ec\": \"%c\",\n                \"%EC\": \"%C\",\n                \"%Ex\": \"%m/%d/%y\",\n                \"%EX\": \"%H:%M:%S\",\n                \"%Ey\": \"%y\",\n                \"%EY\": \"%Y\",\n                \"%Od\": \"%d\",\n                \"%Oe\": \"%e\",\n                \"%OH\": \"%H\",\n                \"%OI\": \"%I\",\n                \"%Om\": \"%m\",\n                \"%OM\": \"%M\",\n                \"%OS\": \"%S\",\n                \"%Ou\": \"%u\",\n                \"%OU\": \"%U\",\n                \"%OV\": \"%V\",\n                \"%Ow\": \"%w\",\n                \"%OW\": \"%W\",\n                \"%Oy\": \"%y\"\n            };\n            for(var rule in EXPANSION_RULES_1){\n                pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_1[rule]);\n            }\n            var WEEKDAYS = [\n                \"Sunday\",\n                \"Monday\",\n                \"Tuesday\",\n                \"Wednesday\",\n                \"Thursday\",\n                \"Friday\",\n                \"Saturday\"\n            ];\n            var MONTHS = [\n                \"January\",\n                \"February\",\n                \"March\",\n                \"April\",\n                \"May\",\n                \"June\",\n                \"July\",\n                \"August\",\n                \"September\",\n                \"October\",\n                \"November\",\n                \"December\"\n            ];\n            function leadingSomething(value, digits, character) {\n                var str = typeof value == \"number\" ? value.toString() : value || \"\";\n                while(str.length < digits){\n                    str = character[0] + str;\n                }\n                return str;\n            }\n            function leadingNulls(value, digits) {\n                return leadingSomething(value, digits, \"0\");\n            }\n            function compareByDay(date1, date2) {\n                function sgn(value) {\n                    return value < 0 ? -1 : value > 0 ? 1 : 0;\n                }\n                var compare;\n                if ((compare = sgn(date1.getFullYear() - date2.getFullYear())) === 0) {\n                    if ((compare = sgn(date1.getMonth() - date2.getMonth())) === 0) {\n                        compare = sgn(date1.getDate() - date2.getDate());\n                    }\n                }\n                return compare;\n            }\n            function getFirstWeekStartDate(janFourth) {\n                switch(janFourth.getDay()){\n                    case 0:\n                        return new Date(janFourth.getFullYear() - 1, 11, 29);\n                    case 1:\n                        return janFourth;\n                    case 2:\n                        return new Date(janFourth.getFullYear(), 0, 3);\n                    case 3:\n                        return new Date(janFourth.getFullYear(), 0, 2);\n                    case 4:\n                        return new Date(janFourth.getFullYear(), 0, 1);\n                    case 5:\n                        return new Date(janFourth.getFullYear() - 1, 11, 31);\n                    case 6:\n                        return new Date(janFourth.getFullYear() - 1, 11, 30);\n                }\n            }\n            function getWeekBasedYear(date) {\n                var thisDate = addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday);\n                var janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4);\n                var janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4);\n                var firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear);\n                var firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear);\n                if (compareByDay(firstWeekStartThisYear, thisDate) <= 0) {\n                    if (compareByDay(firstWeekStartNextYear, thisDate) <= 0) {\n                        return thisDate.getFullYear() + 1;\n                    }\n                    return thisDate.getFullYear();\n                }\n                return thisDate.getFullYear() - 1;\n            }\n            var EXPANSION_RULES_2 = {\n                \"%a\": (date)=>WEEKDAYS[date.tm_wday].substring(0, 3),\n                \"%A\": (date)=>WEEKDAYS[date.tm_wday],\n                \"%b\": (date)=>MONTHS[date.tm_mon].substring(0, 3),\n                \"%B\": (date)=>MONTHS[date.tm_mon],\n                \"%C\": (date)=>{\n                    var year = date.tm_year + 1900;\n                    return leadingNulls(year / 100 | 0, 2);\n                },\n                \"%d\": (date)=>leadingNulls(date.tm_mday, 2),\n                \"%e\": (date)=>leadingSomething(date.tm_mday, 2, \" \"),\n                \"%g\": (date)=>getWeekBasedYear(date).toString().substring(2),\n                \"%G\": (date)=>getWeekBasedYear(date),\n                \"%H\": (date)=>leadingNulls(date.tm_hour, 2),\n                \"%I\": (date)=>{\n                    var twelveHour = date.tm_hour;\n                    if (twelveHour == 0) twelveHour = 12;\n                    else if (twelveHour > 12) twelveHour -= 12;\n                    return leadingNulls(twelveHour, 2);\n                },\n                \"%j\": (date)=>leadingNulls(date.tm_mday + arraySum(isLeapYear(date.tm_year + 1900) ? MONTH_DAYS_LEAP : MONTH_DAYS_REGULAR, date.tm_mon - 1), 3),\n                \"%m\": (date)=>leadingNulls(date.tm_mon + 1, 2),\n                \"%M\": (date)=>leadingNulls(date.tm_min, 2),\n                \"%n\": ()=>\"\\n\",\n                \"%p\": (date)=>{\n                    if (date.tm_hour >= 0 && date.tm_hour < 12) {\n                        return \"AM\";\n                    }\n                    return \"PM\";\n                },\n                \"%S\": (date)=>leadingNulls(date.tm_sec, 2),\n                \"%t\": ()=>\"\t\",\n                \"%u\": (date)=>date.tm_wday || 7,\n                \"%U\": (date)=>{\n                    var days = date.tm_yday + 7 - date.tm_wday;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%V\": (date)=>{\n                    var val = Math.floor((date.tm_yday + 7 - (date.tm_wday + 6) % 7) / 7);\n                    if ((date.tm_wday + 371 - date.tm_yday - 2) % 7 <= 2) {\n                        val++;\n                    }\n                    if (!val) {\n                        val = 52;\n                        var dec31 = (date.tm_wday + 7 - date.tm_yday - 1) % 7;\n                        if (dec31 == 4 || dec31 == 5 && isLeapYear(date.tm_year % 400 - 1)) {\n                            val++;\n                        }\n                    } else if (val == 53) {\n                        var jan1 = (date.tm_wday + 371 - date.tm_yday) % 7;\n                        if (jan1 != 4 && (jan1 != 3 || !isLeapYear(date.tm_year))) val = 1;\n                    }\n                    return leadingNulls(val, 2);\n                },\n                \"%w\": (date)=>date.tm_wday,\n                \"%W\": (date)=>{\n                    var days = date.tm_yday + 7 - (date.tm_wday + 6) % 7;\n                    return leadingNulls(Math.floor(days / 7), 2);\n                },\n                \"%y\": (date)=>(date.tm_year + 1900).toString().substring(2),\n                \"%Y\": (date)=>date.tm_year + 1900,\n                \"%z\": (date)=>{\n                    var off = date.tm_gmtoff;\n                    var ahead = off >= 0;\n                    off = Math.abs(off) / 60;\n                    off = off / 60 * 100 + off % 60;\n                    return (ahead ? \"+\" : \"-\") + String(\"0000\" + off).slice(-4);\n                },\n                \"%Z\": (date)=>date.tm_zone,\n                \"%%\": ()=>\"%\"\n            };\n            pattern = pattern.replace(/%%/g, \"\\x00\\x00\");\n            for(var rule in EXPANSION_RULES_2){\n                if (pattern.includes(rule)) {\n                    pattern = pattern.replace(new RegExp(rule, \"g\"), EXPANSION_RULES_2[rule](date));\n                }\n            }\n            pattern = pattern.replace(/\\0\\0/g, \"%\");\n            var bytes = intArrayFromString(pattern, false);\n            if (bytes.length > maxsize) {\n                return 0;\n            }\n            writeArrayToMemory(bytes, s);\n            return bytes.length - 1;\n        };\n        var _strftime_l = (s, maxsize, format, tm, loc)=>_strftime(s, maxsize, format, tm);\n        var getCFunc = (ident)=>{\n            var func = Module[\"_\" + ident];\n            return func;\n        };\n        var stringToUTF8OnStack = (str)=>{\n            var size = lengthBytesUTF8(str) + 1;\n            var ret = stackAlloc(size);\n            stringToUTF8(str, ret, size);\n            return ret;\n        };\n        var ccall = (ident, returnType, argTypes, args, opts)=>{\n            var toC = {\n                \"string\": (str)=>{\n                    var ret = 0;\n                    if (str !== null && str !== undefined && str !== 0) {\n                        ret = stringToUTF8OnStack(str);\n                    }\n                    return ret;\n                },\n                \"array\": (arr)=>{\n                    var ret = stackAlloc(arr.length);\n                    writeArrayToMemory(arr, ret);\n                    return ret;\n                }\n            };\n            function convertReturnValue(ret) {\n                if (returnType === \"string\") {\n                    return UTF8ToString(ret);\n                }\n                if (returnType === \"boolean\") return Boolean(ret);\n                return ret;\n            }\n            var func = getCFunc(ident);\n            var cArgs = [];\n            var stack = 0;\n            if (args) {\n                for(var i = 0; i < args.length; i++){\n                    var converter = toC[argTypes[i]];\n                    if (converter) {\n                        if (stack === 0) stack = stackSave();\n                        cArgs[i] = converter(args[i]);\n                    } else {\n                        cArgs[i] = args[i];\n                    }\n                }\n            }\n            var ret = func.apply(null, cArgs);\n            function onDone(ret) {\n                if (stack !== 0) stackRestore(stack);\n                return convertReturnValue(ret);\n            }\n            ret = onDone(ret);\n            return ret;\n        };\n        InternalError = Module[\"InternalError\"] = class InternalError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"InternalError\";\n            }\n        };\n        embind_init_charCodes();\n        BindingError = Module[\"BindingError\"] = class BindingError extends Error {\n            constructor(message){\n                super(message);\n                this.name = \"BindingError\";\n            }\n        };\n        handleAllocatorInit();\n        init_emval();\n        UnboundTypeError = Module[\"UnboundTypeError\"] = extendError(Error, \"UnboundTypeError\");\n        var FSNode = function(parent, name, mode, rdev) {\n            if (!parent) {\n                parent = this;\n            }\n            this.parent = parent;\n            this.mount = parent.mount;\n            this.mounted = null;\n            this.id = FS.nextInode++;\n            this.name = name;\n            this.mode = mode;\n            this.node_ops = {};\n            this.stream_ops = {};\n            this.rdev = rdev;\n        };\n        var readMode = 292 | 73;\n        var writeMode = 146;\n        Object.defineProperties(FSNode.prototype, {\n            read: {\n                get: function() {\n                    return (this.mode & readMode) === readMode;\n                },\n                set: function(val) {\n                    val ? this.mode |= readMode : this.mode &= ~readMode;\n                }\n            },\n            write: {\n                get: function() {\n                    return (this.mode & writeMode) === writeMode;\n                },\n                set: function(val) {\n                    val ? this.mode |= writeMode : this.mode &= ~writeMode;\n                }\n            },\n            isFolder: {\n                get: function() {\n                    return FS.isDir(this.mode);\n                }\n            },\n            isDevice: {\n                get: function() {\n                    return FS.isChrdev(this.mode);\n                }\n            }\n        });\n        FS.FSNode = FSNode;\n        FS.createPreloadedFile = FS_createPreloadedFile;\n        FS.staticInit();\n        var wasmImports = {\n            a: ___cxa_throw,\n            m: __embind_finalize_value_array,\n            p: __embind_register_bigint,\n            k: __embind_register_bool,\n            y: __embind_register_emval,\n            z: __embind_register_enum,\n            f: __embind_register_enum_value,\n            j: __embind_register_float,\n            d: __embind_register_function,\n            e: __embind_register_integer,\n            b: __embind_register_memory_view,\n            h: __embind_register_std_string,\n            g: __embind_register_std_wstring,\n            n: __embind_register_value_array,\n            c: __embind_register_value_array_element,\n            l: __embind_register_void,\n            i: _abort,\n            x: _emscripten_memcpy_js,\n            u: _emscripten_resize_heap,\n            r: _environ_get,\n            s: _environ_sizes_get,\n            w: _fd_close,\n            t: _fd_read,\n            o: _fd_seek,\n            v: _fd_write,\n            q: _strftime_l\n        };\n        var wasmExports = createWasm();\n        var ___wasm_call_ctors = ()=>(___wasm_call_ctors = wasmExports[\"B\"])();\n        var ___getTypeName = (a0)=>(___getTypeName = wasmExports[\"D\"])(a0);\n        var ___errno_location = ()=>(___errno_location = wasmExports[\"__errno_location\"])();\n        var _malloc = Module[\"_malloc\"] = (a0)=>(_malloc = Module[\"_malloc\"] = wasmExports[\"E\"])(a0);\n        var _free = Module[\"_free\"] = (a0)=>(_free = Module[\"_free\"] = wasmExports[\"F\"])(a0);\n        var stackSave = ()=>(stackSave = wasmExports[\"G\"])();\n        var stackRestore = (a0)=>(stackRestore = wasmExports[\"H\"])(a0);\n        var stackAlloc = (a0)=>(stackAlloc = wasmExports[\"I\"])(a0);\n        var ___cxa_increment_exception_refcount = (a0)=>(___cxa_increment_exception_refcount = wasmExports[\"__cxa_increment_exception_refcount\"])(a0);\n        var ___cxa_is_pointer_type = (a0)=>(___cxa_is_pointer_type = wasmExports[\"J\"])(a0);\n        var dynCall_jiji = Module[\"dynCall_jiji\"] = (a0, a1, a2, a3, a4)=>(dynCall_jiji = Module[\"dynCall_jiji\"] = wasmExports[\"K\"])(a0, a1, a2, a3, a4);\n        var dynCall_viijii = Module[\"dynCall_viijii\"] = (a0, a1, a2, a3, a4, a5, a6)=>(dynCall_viijii = Module[\"dynCall_viijii\"] = wasmExports[\"L\"])(a0, a1, a2, a3, a4, a5, a6);\n        var dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = (a0, a1, a2, a3, a4, a5, a6)=>(dynCall_iiiiij = Module[\"dynCall_iiiiij\"] = wasmExports[\"M\"])(a0, a1, a2, a3, a4, a5, a6);\n        var dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8)=>(dynCall_iiiiijj = Module[\"dynCall_iiiiijj\"] = wasmExports[\"N\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n        var dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9)=>(dynCall_iiiiiijj = Module[\"dynCall_iiiiiijj\"] = wasmExports[\"O\"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n        Module[\"ccall\"] = ccall;\n        var calledRun;\n        dependenciesFulfilled = function runCaller() {\n            if (!calledRun) run();\n            if (!calledRun) dependenciesFulfilled = runCaller;\n        };\n        function run() {\n            if (runDependencies > 0) {\n                return;\n            }\n            preRun();\n            if (runDependencies > 0) {\n                return;\n            }\n            function doRun() {\n                if (calledRun) return;\n                calledRun = true;\n                Module[\"calledRun\"] = true;\n                if (ABORT) return;\n                initRuntime();\n                readyPromiseResolve(Module);\n                if (Module[\"onRuntimeInitialized\"]) Module[\"onRuntimeInitialized\"]();\n                postRun();\n            }\n            if (Module[\"setStatus\"]) {\n                Module[\"setStatus\"](\"Running...\");\n                setTimeout(function() {\n                    setTimeout(function() {\n                        Module[\"setStatus\"](\"\");\n                    }, 1);\n                    doRun();\n                }, 1);\n            } else {\n                doRun();\n            }\n        }\n        if (Module[\"preInit\"]) {\n            if (typeof Module[\"preInit\"] == \"function\") Module[\"preInit\"] = [\n                Module[\"preInit\"]\n            ];\n            while(Module[\"preInit\"].length > 0){\n                Module[\"preInit\"].pop()();\n            }\n        }\n        run();\n        return moduleArg.ready;\n    };\n})();\n;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Module);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac3BsaW5ldG9vbC9ydW50aW1lL2J1aWxkL2Jvb2xlYW4uanMiLCJtYXBwaW5ncyI6IjtBQUNBLElBQUlBLFNBQVMsQ0FBQztJQUNaLElBQUlDLGFBQWEsT0FBT0MsYUFBYSxlQUFlQSxTQUFTQyxhQUFhLEdBQUdELFNBQVNDLGFBQWEsQ0FBQ0MsR0FBRyxHQUFHQztJQUUxRyxPQUNGO1lBQVNDLFlBQUFBLGlFQUFZLENBQUM7UUFFdEIsSUFBSU4sU0FBT007UUFBVSxJQUFJQyxxQkFBb0JDO1FBQW1CUixNQUFNLENBQUMsUUFBUSxHQUFDLElBQUlTLFFBQVEsQ0FBQ0MsU0FBUUM7WUFBVUosc0JBQW9CRztZQUFRRixxQkFBbUJHO1FBQU07UUFBRyxJQUFJQyxrQkFBZ0JDLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUVkO1FBQVEsSUFBSWUsYUFBVyxFQUFFO1FBQUMsSUFBSUMsY0FBWTtRQUFpQixJQUFJQyxRQUFNLENBQUNDLFFBQU9DO1lBQVcsTUFBTUE7UUFBTztRQUFFLElBQUlDLHFCQUFtQjtRQUFLLElBQUlDLHdCQUFzQjtRQUFNLElBQUlDLGtCQUFnQjtRQUFHLFNBQVNDLFdBQVdDLElBQUk7WUFBRSxJQUFHeEIsTUFBTSxDQUFDLGFBQWEsRUFBQztnQkFBQyxPQUFPQSxNQUFNLENBQUMsYUFBYSxDQUFDd0IsTUFBS0Y7WUFBZ0I7WUFBQyxPQUFPQSxrQkFBZ0JFO1FBQUk7UUFBQyxJQUFJQyxPQUFNQyxXQUFVQztRQUFXLElBQUdQLHNCQUFvQkMsdUJBQXNCO1lBQUMsSUFBR0EsdUJBQXNCO2dCQUFDQyxrQkFBZ0JNLEtBQUtDLFFBQVEsQ0FBQ0MsSUFBSTtZQUFBLE9BQU0sSUFBRyxPQUFPNUIsWUFBVSxlQUFhQSxTQUFTQyxhQUFhLEVBQUM7Z0JBQUNtQixrQkFBZ0JwQixTQUFTQyxhQUFhLENBQUNDLEdBQUc7WUFBQTtZQUFDLElBQUdILFlBQVc7Z0JBQUNxQixrQkFBZ0JyQjtZQUFVO1lBQUMsSUFBR3FCLGdCQUFnQlMsT0FBTyxDQUFDLGFBQVcsR0FBRTtnQkFBQ1Qsa0JBQWdCQSxnQkFBZ0JVLE1BQU0sQ0FBQyxHQUFFVixnQkFBZ0JXLE9BQU8sQ0FBQyxVQUFTLElBQUlDLFdBQVcsQ0FBQyxPQUFLO1lBQUUsT0FBSztnQkFBQ1osa0JBQWdCO1lBQUU7WUFBQztnQkFBQ0csUUFBTVUsQ0FBQUE7b0JBQU0sSUFBSUMsTUFBSSxJQUFJQztvQkFBZUQsSUFBSUUsSUFBSSxDQUFDLE9BQU1ILEtBQUk7b0JBQU9DLElBQUlHLElBQUksQ0FBQztvQkFBTSxPQUFPSCxJQUFJSSxZQUFZO2dCQUFBO2dCQUFFLElBQUduQix1QkFBc0I7b0JBQUNNLGFBQVdRLENBQUFBO3dCQUFNLElBQUlDLE1BQUksSUFBSUM7d0JBQWVELElBQUlFLElBQUksQ0FBQyxPQUFNSCxLQUFJO3dCQUFPQyxJQUFJSyxZQUFZLEdBQUM7d0JBQWNMLElBQUlHLElBQUksQ0FBQzt3QkFBTSxPQUFPLElBQUlHLFdBQVdOLElBQUlPLFFBQVE7b0JBQUM7Z0JBQUM7Z0JBQUNqQixZQUFVLENBQUNTLEtBQUlTLFFBQU9DO29CQUFXLElBQUlULE1BQUksSUFBSUM7b0JBQWVELElBQUlFLElBQUksQ0FBQyxPQUFNSCxLQUFJO29CQUFNQyxJQUFJSyxZQUFZLEdBQUM7b0JBQWNMLElBQUlRLE1BQU0sR0FBQzt3QkFBSyxJQUFHUixJQUFJbEIsTUFBTSxJQUFFLE9BQUtrQixJQUFJbEIsTUFBTSxJQUFFLEtBQUdrQixJQUFJTyxRQUFRLEVBQUM7NEJBQUNDLE9BQU9SLElBQUlPLFFBQVE7NEJBQUU7d0JBQU07d0JBQUNFO29CQUFTO29CQUFFVCxJQUFJUyxPQUFPLEdBQUNBO29CQUFRVCxJQUFJRyxJQUFJLENBQUM7Z0JBQUs7WUFBQztRQUFDLE9BQUssQ0FBQztRQUFDLElBQUlPLE1BQUk5QyxNQUFNLENBQUMsUUFBUSxJQUFFK0MsUUFBUUMsR0FBRyxDQUFDQyxJQUFJLENBQUNGO1FBQVMsSUFBSUcsTUFBSWxELE1BQU0sQ0FBQyxXQUFXLElBQUUrQyxRQUFRSSxLQUFLLENBQUNGLElBQUksQ0FBQ0Y7UUFBU2xDLE9BQU9DLE1BQU0sQ0FBQ2QsUUFBT1k7UUFBaUJBLGtCQUFnQjtRQUFLLElBQUdaLE1BQU0sQ0FBQyxZQUFZLEVBQUNlLGFBQVdmLE1BQU0sQ0FBQyxZQUFZO1FBQUMsSUFBR0EsTUFBTSxDQUFDLGNBQWMsRUFBQ2dCLGNBQVloQixNQUFNLENBQUMsY0FBYztRQUFDLElBQUdBLE1BQU0sQ0FBQyxPQUFPLEVBQUNpQixRQUFNakIsTUFBTSxDQUFDLE9BQU87UUFBQyxJQUFJb0Q7UUFBVyxJQUFHcEQsTUFBTSxDQUFDLGFBQWEsRUFBQ29ELGFBQVdwRCxNQUFNLENBQUMsYUFBYTtRQUFDLElBQUcsT0FBT3FELGVBQWEsVUFBUztZQUFDQyxNQUFNO1FBQWtDO1FBQUMsSUFBSUM7UUFBVyxJQUFJQyxRQUFNO1FBQU0sSUFBSUM7UUFBVyxTQUFTQyxPQUFPQyxTQUFTLEVBQUNDLElBQUk7WUFBRSxJQUFHLENBQUNELFdBQVU7Z0JBQUNMLE1BQU1NO1lBQUs7UUFBQztRQUFDLElBQUlDLE9BQU1DLFFBQU9DLFFBQU9DLFNBQVFDLFFBQU9DLFNBQVFDLFNBQVFDO1FBQVEsU0FBU0M7WUFBb0IsSUFBSUMsSUFBRWYsV0FBV2dCLE1BQU07WUFBQ3ZFLE1BQU0sQ0FBQyxRQUFRLEdBQUM2RCxRQUFNLElBQUlXLFVBQVVGO1lBQUd0RSxNQUFNLENBQUMsU0FBUyxHQUFDK0QsU0FBTyxJQUFJVSxXQUFXSDtZQUFHdEUsTUFBTSxDQUFDLFNBQVMsR0FBQzhELFNBQU8sSUFBSXBCLFdBQVc0QjtZQUFHdEUsTUFBTSxDQUFDLFVBQVUsR0FBQ2dFLFVBQVEsSUFBSVUsWUFBWUo7WUFBR3RFLE1BQU0sQ0FBQyxTQUFTLEdBQUNpRSxTQUFPLElBQUlVLFdBQVdMO1lBQUd0RSxNQUFNLENBQUMsVUFBVSxHQUFDa0UsVUFBUSxJQUFJVSxZQUFZTjtZQUFHdEUsTUFBTSxDQUFDLFVBQVUsR0FBQ21FLFVBQVEsSUFBSVUsYUFBYVA7WUFBR3RFLE1BQU0sQ0FBQyxVQUFVLEdBQUNvRSxVQUFRLElBQUlVLGFBQWFSO1FBQUU7UUFBQyxJQUFJUyxlQUFhLEVBQUU7UUFBQyxJQUFJQyxhQUFXLEVBQUU7UUFBQyxJQUFJQyxnQkFBYyxFQUFFO1FBQUMsSUFBSUMscUJBQW1CO1FBQU0sU0FBU0M7WUFBUyxJQUFHbkYsTUFBTSxDQUFDLFNBQVMsRUFBQztnQkFBQyxJQUFHLE9BQU9BLE1BQU0sQ0FBQyxTQUFTLElBQUUsWUFBV0EsTUFBTSxDQUFDLFNBQVMsR0FBQztvQkFBQ0EsTUFBTSxDQUFDLFNBQVM7aUJBQUM7Z0JBQUMsTUFBTUEsTUFBTSxDQUFDLFNBQVMsQ0FBQ29GLE1BQU0sQ0FBQztvQkFBQ0MsWUFBWXJGLE1BQU0sQ0FBQyxTQUFTLENBQUNzRixLQUFLO2dCQUFHO1lBQUM7WUFBQ0MscUJBQXFCUjtRQUFhO1FBQUMsU0FBU1M7WUFBY04scUJBQW1CO1lBQUssSUFBRyxDQUFDbEYsTUFBTSxDQUFDLFdBQVcsSUFBRSxDQUFDeUYsR0FBR0MsSUFBSSxDQUFDQyxXQUFXLEVBQUNGLEdBQUdDLElBQUk7WUFBR0QsR0FBR0csaUJBQWlCLEdBQUM7WUFBTUMsSUFBSUgsSUFBSTtZQUFHSCxxQkFBcUJQO1FBQVc7UUFBQyxTQUFTYztZQUFVLElBQUc5RixNQUFNLENBQUMsVUFBVSxFQUFDO2dCQUFDLElBQUcsT0FBT0EsTUFBTSxDQUFDLFVBQVUsSUFBRSxZQUFXQSxNQUFNLENBQUMsVUFBVSxHQUFDO29CQUFDQSxNQUFNLENBQUMsVUFBVTtpQkFBQztnQkFBQyxNQUFNQSxNQUFNLENBQUMsVUFBVSxDQUFDb0YsTUFBTSxDQUFDO29CQUFDVyxhQUFhL0YsTUFBTSxDQUFDLFVBQVUsQ0FBQ3NGLEtBQUs7Z0JBQUc7WUFBQztZQUFDQyxxQkFBcUJOO1FBQWM7UUFBQyxTQUFTSSxZQUFZVyxFQUFFO1lBQUVqQixhQUFha0IsT0FBTyxDQUFDRDtRQUFHO1FBQUMsU0FBU0UsVUFBVUYsRUFBRTtZQUFFaEIsV0FBV2lCLE9BQU8sQ0FBQ0Q7UUFBRztRQUFDLFNBQVNELGFBQWFDLEVBQUU7WUFBRWYsY0FBY2dCLE9BQU8sQ0FBQ0Q7UUFBRztRQUFDLElBQUlHLGtCQUFnQjtRQUFFLElBQUlDLHVCQUFxQjtRQUFLLElBQUlDLHdCQUFzQjtRQUFLLFNBQVNDLHVCQUF1QkMsRUFBRTtZQUFFLE9BQU9BO1FBQUU7UUFBQyxTQUFTQyxpQkFBaUJELEVBQUU7WUFBRUo7WUFBa0IsSUFBR25HLE1BQU0sQ0FBQyx5QkFBeUIsRUFBQztnQkFBQ0EsTUFBTSxDQUFDLHlCQUF5QixDQUFDbUc7WUFBZ0I7UUFBQztRQUFDLFNBQVNNLG9CQUFvQkYsRUFBRTtZQUFFSjtZQUFrQixJQUFHbkcsTUFBTSxDQUFDLHlCQUF5QixFQUFDO2dCQUFDQSxNQUFNLENBQUMseUJBQXlCLENBQUNtRztZQUFnQjtZQUFDLElBQUdBLG1CQUFpQixHQUFFO2dCQUFDLElBQUdDLHlCQUF1QixNQUFLO29CQUFDTSxjQUFjTjtvQkFBc0JBLHVCQUFxQjtnQkFBSTtnQkFBQyxJQUFHQyx1QkFBc0I7b0JBQUMsSUFBSU0sV0FBU047b0JBQXNCQSx3QkFBc0I7b0JBQUtNO2dCQUFVO1lBQUM7UUFBQztRQUFDLFNBQVNyRCxNQUFNc0QsSUFBSTtZQUFFLElBQUc1RyxNQUFNLENBQUMsVUFBVSxFQUFDO2dCQUFDQSxNQUFNLENBQUMsVUFBVSxDQUFDNEc7WUFBSztZQUFDQSxPQUFLLGFBQVdBLE9BQUs7WUFBSTFELElBQUkwRDtZQUFNcEQsUUFBTTtZQUFLQyxhQUFXO1lBQUVtRCxRQUFNO1lBQTJDLElBQUlDLElBQUUsSUFBSXhELFlBQVl5RCxZQUFZLENBQUNGO1lBQU1wRyxtQkFBbUJxRztZQUFHLE1BQU1BO1FBQUM7UUFBQyxJQUFJRSxnQkFBYztRQUF3QyxJQUFJQyxZQUFVQyxDQUFBQSxXQUFVQSxTQUFTQyxVQUFVLENBQUNIO1FBQWUsSUFBSUk7UUFBZUEsaUJBQWU7UUFBZSxJQUFHLENBQUNILFVBQVVHLGlCQUFnQjtZQUFDQSxpQkFBZTVGLFdBQVc0RjtRQUFlO1FBQUMsU0FBU0MsY0FBY0MsSUFBSTtZQUFFLElBQUdBLFFBQU1GLGtCQUFnQi9ELFlBQVc7Z0JBQUMsT0FBTyxJQUFJVixXQUFXVTtZQUFXO1lBQUMsSUFBR3pCLFlBQVc7Z0JBQUMsT0FBT0EsV0FBVzBGO1lBQUs7WUFBQyxNQUFLO1FBQWlEO1FBQUMsU0FBU0MsaUJBQWlCQyxVQUFVO1lBQUUsSUFBRyxDQUFDbkUsY0FBYWhDLENBQUFBLHNCQUFvQkMscUJBQW9CLEdBQUc7Z0JBQUMsSUFBRyxPQUFPbUcsU0FBTyxZQUFXO29CQUFDLE9BQU9BLE1BQU1ELFlBQVc7d0JBQUNFLGFBQVk7b0JBQWEsR0FBR0MsSUFBSSxDQUFDL0UsQ0FBQUE7d0JBQVcsSUFBRyxDQUFDQSxRQUFRLENBQUMsS0FBSyxFQUFDOzRCQUFDLE1BQUsseUNBQXVDNEUsYUFBVzt3QkFBRzt3QkFBQyxPQUFPNUUsUUFBUSxDQUFDLGNBQWM7b0JBQUUsR0FBR2dGLEtBQUssQ0FBQyxJQUFJUCxjQUFjRztnQkFBWTtZQUFDO1lBQUMsT0FBTzlHLFFBQVFDLE9BQU8sR0FBR2dILElBQUksQ0FBQyxJQUFJTixjQUFjRztRQUFZO1FBQUMsU0FBU0ssdUJBQXVCTCxVQUFVLEVBQUNNLE9BQU8sRUFBQ0MsUUFBUTtZQUFFLE9BQU9SLGlCQUFpQkMsWUFBWUcsSUFBSSxDQUFDSyxDQUFBQSxTQUFRMUUsWUFBWTJFLFdBQVcsQ0FBQ0QsUUFBT0YsVUFBVUgsSUFBSSxDQUFDTyxDQUFBQSxXQUFVQSxVQUFVUCxJQUFJLENBQUNJLFVBQVNJLENBQUFBO2dCQUFTaEYsSUFBSSwwQ0FBaUQsT0FBUGdGO2dCQUFVNUUsTUFBTTRFO1lBQU87UUFBRTtRQUFDLFNBQVNDLGlCQUFpQkosTUFBTSxFQUFDUixVQUFVLEVBQUNNLE9BQU8sRUFBQ2xCLFFBQVE7WUFBRSxJQUFHLENBQUNvQixVQUFRLE9BQU8xRSxZQUFZK0Usb0JBQW9CLElBQUUsY0FBWSxDQUFDcEIsVUFBVU8sZUFBYSxPQUFPQyxTQUFPLFlBQVc7Z0JBQUMsT0FBT0EsTUFBTUQsWUFBVztvQkFBQ0UsYUFBWTtnQkFBYSxHQUFHQyxJQUFJLENBQUMvRSxDQUFBQTtvQkFBVyxJQUFJMEYsU0FBT2hGLFlBQVkrRSxvQkFBb0IsQ0FBQ3pGLFVBQVNrRjtvQkFBUyxPQUFPUSxPQUFPWCxJQUFJLENBQUNmLFVBQVMsU0FBU3VCLE1BQU07d0JBQUVoRixJQUFJLGtDQUF5QyxPQUFQZ0Y7d0JBQVVoRixJQUFJO3dCQUE2QyxPQUFPMEUsdUJBQXVCTCxZQUFXTSxTQUFRbEI7b0JBQVM7Z0JBQUU7WUFBRTtZQUFDLE9BQU9pQix1QkFBdUJMLFlBQVdNLFNBQVFsQjtRQUFTO1FBQUMsU0FBUzJCO1lBQWEsSUFBSUMsT0FBSztnQkFBQyxLQUFJQztZQUFXO1lBQUUsU0FBU0MsZ0JBQWdCUixRQUFRLEVBQUNTLE1BQU07Z0JBQUVDLGNBQVlWLFNBQVNXLE9BQU87Z0JBQUNyRixhQUFXb0YsV0FBVyxDQUFDLElBQUk7Z0JBQUN0RTtnQkFBb0J3RSxZQUFVRixXQUFXLENBQUMsSUFBSTtnQkFBQ3pDLFVBQVV5QyxXQUFXLENBQUMsSUFBSTtnQkFBRWxDLG9CQUFvQjtnQkFBb0IsT0FBT2tDO1lBQVc7WUFBQ25DLGlCQUFpQjtZQUFvQixTQUFTc0MsMkJBQTJCVCxNQUFNO2dCQUFFSSxnQkFBZ0JKLE1BQU0sQ0FBQyxXQUFXO1lBQUM7WUFBQyxJQUFHckksTUFBTSxDQUFDLGtCQUFrQixFQUFDO2dCQUFDLElBQUc7b0JBQUMsT0FBT0EsTUFBTSxDQUFDLGtCQUFrQixDQUFDdUksTUFBS0U7Z0JBQWdCLEVBQUMsT0FBTTVCLEdBQUU7b0JBQUMzRCxJQUFJLHNEQUF3RCxPQUFGMkQ7b0JBQUtyRyxtQkFBbUJxRztnQkFBRTtZQUFDO1lBQUNzQixpQkFBaUIvRSxZQUFXK0QsZ0JBQWVvQixNQUFLTyw0QkFBNEJuQixLQUFLLENBQUNuSDtZQUFvQixPQUFNLENBQUM7UUFBQztRQUFDLElBQUl1STtRQUFXLElBQUlDO1FBQVEsSUFBSXpELHVCQUFxQjBELENBQUFBO1lBQVksTUFBTUEsVUFBVTdELE1BQU0sR0FBQyxFQUFFO2dCQUFDNkQsVUFBVTNELEtBQUssR0FBR3RGO1lBQU87UUFBQztRQUFFLElBQUlrSixnQkFBY2xKLE1BQU0sQ0FBQyxnQkFBZ0IsSUFBRTtRQUFLLFNBQVNtSixjQUFjQyxNQUFNO1lBQUUsSUFBSSxDQUFDQSxNQUFNLEdBQUNBO1lBQU8sSUFBSSxDQUFDQyxHQUFHLEdBQUNELFNBQU87WUFBRyxJQUFJLENBQUNFLFFBQVEsR0FBQyxTQUFTQyxJQUFJO2dCQUFFckYsT0FBTyxDQUFDLElBQUksQ0FBQ21GLEdBQUcsR0FBQyxLQUFHLEVBQUUsR0FBQ0U7WUFBSTtZQUFFLElBQUksQ0FBQ0MsUUFBUSxHQUFDO2dCQUFXLE9BQU90RixPQUFPLENBQUMsSUFBSSxDQUFDbUYsR0FBRyxHQUFDLEtBQUcsRUFBRTtZQUFBO1lBQUUsSUFBSSxDQUFDSSxjQUFjLEdBQUMsU0FBU0MsVUFBVTtnQkFBRXhGLE9BQU8sQ0FBQyxJQUFJLENBQUNtRixHQUFHLEdBQUMsS0FBRyxFQUFFLEdBQUNLO1lBQVU7WUFBRSxJQUFJLENBQUNDLGNBQWMsR0FBQztnQkFBVyxPQUFPekYsT0FBTyxDQUFDLElBQUksQ0FBQ21GLEdBQUcsR0FBQyxLQUFHLEVBQUU7WUFBQTtZQUFFLElBQUksQ0FBQ08sVUFBVSxHQUFDLFNBQVNDLE1BQU07Z0JBQUVBLFNBQU9BLFNBQU8sSUFBRTtnQkFBRWhHLEtBQUssQ0FBQyxJQUFJLENBQUN3RixHQUFHLEdBQUMsTUFBSSxFQUFFLEdBQUNRO1lBQU07WUFBRSxJQUFJLENBQUNDLFVBQVUsR0FBQztnQkFBVyxPQUFPakcsS0FBSyxDQUFDLElBQUksQ0FBQ3dGLEdBQUcsR0FBQyxNQUFJLEVBQUUsSUFBRTtZQUFDO1lBQUUsSUFBSSxDQUFDVSxZQUFZLEdBQUMsU0FBU0MsUUFBUTtnQkFBRUEsV0FBU0EsV0FBUyxJQUFFO2dCQUFFbkcsS0FBSyxDQUFDLElBQUksQ0FBQ3dGLEdBQUcsR0FBQyxNQUFJLEVBQUUsR0FBQ1c7WUFBUTtZQUFFLElBQUksQ0FBQ0MsWUFBWSxHQUFDO2dCQUFXLE9BQU9wRyxLQUFLLENBQUMsSUFBSSxDQUFDd0YsR0FBRyxHQUFDLE1BQUksRUFBRSxJQUFFO1lBQUM7WUFBRSxJQUFJLENBQUMzRCxJQUFJLEdBQUMsU0FBUzZELElBQUksRUFBQ0csVUFBVTtnQkFBRSxJQUFJLENBQUNRLGdCQUFnQixDQUFDO2dCQUFHLElBQUksQ0FBQ1osUUFBUSxDQUFDQztnQkFBTSxJQUFJLENBQUNFLGNBQWMsQ0FBQ0M7WUFBVztZQUFFLElBQUksQ0FBQ1EsZ0JBQWdCLEdBQUMsU0FBU0MsV0FBVztnQkFBRWpHLE9BQU8sQ0FBQyxJQUFJLENBQUNtRixHQUFHLEdBQUMsTUFBSSxFQUFFLEdBQUNjO1lBQVc7WUFBRSxJQUFJLENBQUNDLGdCQUFnQixHQUFDO2dCQUFXLE9BQU9sRyxPQUFPLENBQUMsSUFBSSxDQUFDbUYsR0FBRyxHQUFDLE1BQUksRUFBRTtZQUFBO1lBQUUsSUFBSSxDQUFDZ0IsaUJBQWlCLEdBQUM7Z0JBQVcsSUFBSUMsWUFBVUMsdUJBQXVCLElBQUksQ0FBQ2YsUUFBUTtnQkFBSSxJQUFHYyxXQUFVO29CQUFDLE9BQU9wRyxPQUFPLENBQUMsSUFBSSxDQUFDa0YsTUFBTSxJQUFFLEVBQUU7Z0JBQUE7Z0JBQUMsSUFBSW9CLFdBQVMsSUFBSSxDQUFDSixnQkFBZ0I7Z0JBQUcsSUFBR0ksYUFBVyxHQUFFLE9BQU9BO2dCQUFTLE9BQU8sSUFBSSxDQUFDcEIsTUFBTTtZQUFBO1FBQUM7UUFBQyxJQUFJcUIsZ0JBQWM7UUFBRSxJQUFJQyx5QkFBdUI7UUFBRSxJQUFJQyxlQUFhLENBQUN0QixLQUFJRSxNQUFLRztZQUFjLElBQUluQixPQUFLLElBQUlZLGNBQWNFO1lBQUtkLEtBQUs3QyxJQUFJLENBQUM2RCxNQUFLRztZQUFZZSxnQkFBY3BCO1lBQUlxQjtZQUF5QixNQUFNRDtRQUFhO1FBQUUsSUFBSUcscUJBQW1CLENBQUM7UUFBRSxJQUFJQyxpQkFBZUMsQ0FBQUE7WUFBYyxNQUFNQSxZQUFZMUYsTUFBTSxDQUFDO2dCQUFDLElBQUlpRSxNQUFJeUIsWUFBWUMsR0FBRztnQkFBRyxJQUFJQyxNQUFJRixZQUFZQyxHQUFHO2dCQUFHQyxJQUFJM0I7WUFBSTtRQUFDO1FBQUUsU0FBUzRCLDJCQUEyQkMsT0FBTztZQUFFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQ2pILE1BQU0sQ0FBQ2lILFdBQVMsRUFBRTtRQUFDO1FBQUMsSUFBSUMsdUJBQXFCLENBQUM7UUFBRSxJQUFJQyxrQkFBZ0IsQ0FBQztRQUFFLElBQUlDLG1CQUFpQixDQUFDO1FBQUUsSUFBSUM7UUFBYyxJQUFJQyxxQkFBbUJDLENBQUFBO1lBQVUsTUFBTSxJQUFJRixjQUFjRTtRQUFRO1FBQUUsSUFBSUMsZ0NBQThCLENBQUNDLFNBQVFDLGdCQUFlQztZQUFxQkYsUUFBUUcsT0FBTyxDQUFDLFNBQVN0QyxJQUFJO2dCQUFFOEIsZ0JBQWdCLENBQUM5QixLQUFLLEdBQUNvQztZQUFjO1lBQUcsU0FBU0csV0FBV0MsY0FBYztnQkFBRSxJQUFJQyxtQkFBaUJKLGtCQUFrQkc7Z0JBQWdCLElBQUdDLGlCQUFpQjVHLE1BQU0sS0FBR3NHLFFBQVF0RyxNQUFNLEVBQUM7b0JBQUNtRyxtQkFBbUI7Z0JBQWtDO2dCQUFDLElBQUksSUFBSVUsSUFBRSxHQUFFQSxJQUFFUCxRQUFRdEcsTUFBTSxFQUFDLEVBQUU2RyxFQUFFO29CQUFDQyxhQUFhUixPQUFPLENBQUNPLEVBQUUsRUFBQ0QsZ0JBQWdCLENBQUNDLEVBQUU7Z0JBQUM7WUFBQztZQUFDLElBQUlGLGlCQUFlLElBQUlJLE1BQU1SLGVBQWV2RyxNQUFNO1lBQUUsSUFBSWdILG9CQUFrQixFQUFFO1lBQUMsSUFBSUMsYUFBVztZQUFFVixlQUFlRSxPQUFPLENBQUMsQ0FBQ1MsSUFBR0w7Z0JBQUssSUFBR2IsZ0JBQWdCbUIsY0FBYyxDQUFDRCxLQUFJO29CQUFDUCxjQUFjLENBQUNFLEVBQUUsR0FBQ2IsZUFBZSxDQUFDa0IsR0FBRztnQkFBQSxPQUFLO29CQUFDRixrQkFBa0JJLElBQUksQ0FBQ0Y7b0JBQUksSUFBRyxDQUFDbkIscUJBQXFCb0IsY0FBYyxDQUFDRCxLQUFJO3dCQUFDbkIsb0JBQW9CLENBQUNtQixHQUFHLEdBQUMsRUFBRTtvQkFBQTtvQkFBQ25CLG9CQUFvQixDQUFDbUIsR0FBRyxDQUFDRSxJQUFJLENBQUM7d0JBQUtULGNBQWMsQ0FBQ0UsRUFBRSxHQUFDYixlQUFlLENBQUNrQixHQUFHO3dCQUFDLEVBQUVEO3dCQUFXLElBQUdBLGVBQWFELGtCQUFrQmhILE1BQU0sRUFBQzs0QkFBQzBHLFdBQVdDO3dCQUFlO29CQUFDO2dCQUFFO1lBQUM7WUFBRyxJQUFHLE1BQUlLLGtCQUFrQmhILE1BQU0sRUFBQztnQkFBQzBHLFdBQVdDO1lBQWU7UUFBQztRQUFFLElBQUlVLGdDQUE4QkMsQ0FBQUE7WUFBZSxJQUFJQyxNQUFJL0Isa0JBQWtCLENBQUM4QixhQUFhO1lBQUMsT0FBTzlCLGtCQUFrQixDQUFDOEIsYUFBYTtZQUFDLElBQUlFLFdBQVNELElBQUlDLFFBQVE7WUFBQyxJQUFJQyxpQkFBZUQsU0FBU3hILE1BQU07WUFBQyxJQUFJMEgsZUFBYUYsU0FBU0csR0FBRyxDQUFDQyxDQUFBQSxNQUFLQSxJQUFJQyxnQkFBZ0IsRUFBRUMsTUFBTSxDQUFDTixTQUFTRyxHQUFHLENBQUNDLENBQUFBLE1BQUtBLElBQUlHLGtCQUFrQjtZQUFHLElBQUlDLGlCQUFlVCxJQUFJUyxjQUFjO1lBQUMsSUFBSUMsZ0JBQWNWLElBQUlVLGFBQWE7WUFBQzVCLDhCQUE4QjtnQkFBQ2lCO2FBQWEsRUFBQ0ksY0FBYSxTQUFTQSxZQUFZO2dCQUFFRixTQUFTZixPQUFPLENBQUMsQ0FBQ21CLEtBQUlmO29CQUFLLElBQUlnQixtQkFBaUJILFlBQVksQ0FBQ2IsRUFBRTtvQkFBQyxJQUFJcUIsU0FBT04sSUFBSU0sTUFBTTtvQkFBQyxJQUFJQyxnQkFBY1AsSUFBSU8sYUFBYTtvQkFBQyxJQUFJSixxQkFBbUJMLFlBQVksQ0FBQ2IsSUFBRVksZUFBZTtvQkFBQyxJQUFJVyxTQUFPUixJQUFJUSxNQUFNO29CQUFDLElBQUlDLGdCQUFjVCxJQUFJUyxhQUFhO29CQUFDVCxJQUFJVSxJQUFJLEdBQUNyRSxDQUFBQSxNQUFLNEQsZ0JBQWdCLENBQUMsZUFBZSxDQUFDSyxPQUFPQyxlQUFjbEU7b0JBQU0yRCxJQUFJVyxLQUFLLEdBQUMsQ0FBQ3RFLEtBQUl1RTt3QkFBSyxJQUFJOUMsY0FBWSxFQUFFO3dCQUFDMEMsT0FBT0MsZUFBY3BFLEtBQUk4RCxrQkFBa0IsQ0FBQyxhQUFhLENBQUNyQyxhQUFZOEM7d0JBQUkvQyxlQUFlQztvQkFBWTtnQkFBQztnQkFBRyxPQUFNO29CQUFDO3dCQUFDK0MsTUFBS2xCLElBQUlrQixJQUFJO3dCQUFDLGdCQUFleEUsQ0FBQUE7NEJBQU0sSUFBSXlFLEtBQUcsSUFBSTNCLE1BQU1VOzRCQUFnQixJQUFJLElBQUlaLElBQUUsR0FBRUEsSUFBRVksZ0JBQWUsRUFBRVosRUFBRTtnQ0FBQzZCLEVBQUUsQ0FBQzdCLEVBQUUsR0FBQ1csUUFBUSxDQUFDWCxFQUFFLENBQUN5QixJQUFJLENBQUNyRTs0QkFBSTs0QkFBQ2dFLGNBQWNoRTs0QkFBSyxPQUFPeUU7d0JBQUU7d0JBQUUsY0FBYSxDQUFDaEQsYUFBWThDOzRCQUFLLElBQUdmLG1CQUFpQmUsRUFBRXhJLE1BQU0sRUFBQztnQ0FBQyxNQUFNLElBQUkySSxVQUFVLDBDQUFnRWxCLE9BQXRCRixJQUFJa0IsSUFBSSxFQUFDLGVBQXVDRCxPQUExQmYsZ0JBQWUsYUFBb0IsT0FBVGUsRUFBRXhJLE1BQU07NEJBQUc7NEJBQUMsSUFBSWlFLE1BQUkrRDs0QkFBaUIsSUFBSSxJQUFJbkIsSUFBRSxHQUFFQSxJQUFFWSxnQkFBZSxFQUFFWixFQUFFO2dDQUFDVyxRQUFRLENBQUNYLEVBQUUsQ0FBQzBCLEtBQUssQ0FBQ3RFLEtBQUl1RSxDQUFDLENBQUMzQixFQUFFOzRCQUFDOzRCQUFDLElBQUduQixnQkFBYyxNQUFLO2dDQUFDQSxZQUFZMEIsSUFBSSxDQUFDYSxlQUFjaEU7NEJBQUk7NEJBQUMsT0FBT0E7d0JBQUc7d0JBQUUsa0JBQWlCMkU7d0JBQW9CLHdCQUF1Qi9DO3dCQUEyQmdELG9CQUFtQlo7b0JBQWE7aUJBQUU7WUFBQTtRQUFFO1FBQUUsSUFBSWEsMkJBQXlCLENBQUNDLGVBQWNOLE1BQUtPLE1BQUtDLFVBQVNDLFlBQVk7UUFBRSxJQUFJQyx3QkFBc0I7WUFBSyxJQUFJQyxRQUFNLElBQUlyQyxNQUFNO1lBQUssSUFBSSxJQUFJRixJQUFFLEdBQUVBLElBQUUsS0FBSSxFQUFFQSxFQUFFO2dCQUFDdUMsS0FBSyxDQUFDdkMsRUFBRSxHQUFDd0MsT0FBT0MsWUFBWSxDQUFDekM7WUFBRTtZQUFDMEMsbUJBQWlCSDtRQUFLO1FBQUUsSUFBSUc7UUFBaUIsSUFBSUMsbUJBQWlCdkYsQ0FBQUE7WUFBTSxJQUFJd0YsTUFBSTtZQUFHLElBQUlDLElBQUV6RjtZQUFJLE1BQU12RixNQUFNLENBQUNnTCxFQUFFLENBQUM7Z0JBQUNELE9BQUtGLGdCQUFnQixDQUFDN0ssTUFBTSxDQUFDZ0wsSUFBSSxDQUFDO1lBQUE7WUFBQyxPQUFPRDtRQUFHO1FBQUUsSUFBSUU7UUFBYSxJQUFJQyxvQkFBa0J4RCxDQUFBQTtZQUFVLE1BQU0sSUFBSXVELGFBQWF2RDtRQUFRO1FBQUUsU0FBU3lELG1CQUFtQkMsT0FBTyxFQUFDQyxrQkFBa0I7Z0JBQUNDLFVBQUFBLGlFQUFRLENBQUM7WUFBRyxJQUFJdkIsT0FBS3NCLG1CQUFtQnRCLElBQUk7WUFBQyxJQUFHLENBQUNxQixTQUFRO2dCQUFDRixrQkFBa0IsU0FBYyxPQUFMbkIsTUFBSztZQUErQztZQUFDLElBQUd6QyxnQkFBZ0JtQixjQUFjLENBQUMyQyxVQUFTO2dCQUFDLElBQUdFLFFBQVFDLDRCQUE0QixFQUFDO29CQUFDO2dCQUFNLE9BQUs7b0JBQUNMLGtCQUFrQix5QkFBOEIsT0FBTG5CLE1BQUs7Z0JBQVM7WUFBQztZQUFDekMsZUFBZSxDQUFDOEQsUUFBUSxHQUFDQztZQUFtQixPQUFPOUQsZ0JBQWdCLENBQUM2RCxRQUFRO1lBQUMsSUFBRy9ELHFCQUFxQm9CLGNBQWMsQ0FBQzJDLFVBQVM7Z0JBQUMsSUFBSWpHLFlBQVVrQyxvQkFBb0IsQ0FBQytELFFBQVE7Z0JBQUMsT0FBTy9ELG9CQUFvQixDQUFDK0QsUUFBUTtnQkFBQ2pHLFVBQVU0QyxPQUFPLENBQUM3RixDQUFBQSxLQUFJQTtZQUFLO1FBQUM7UUFBQyxTQUFTa0csYUFBYWdELE9BQU8sRUFBQ0Msa0JBQWtCO2dCQUFDQyxVQUFBQSxpRUFBUSxDQUFDO1lBQUcsSUFBRyxDQUFFLHFCQUFtQkQsa0JBQWlCLEdBQUc7Z0JBQUMsTUFBTSxJQUFJcEIsVUFBVTtZQUEwRDtZQUFDLE9BQU9rQixtQkFBbUJDLFNBQVFDLG9CQUFtQkM7UUFBUTtRQUFDLElBQUlwQixzQkFBb0I7UUFBRSxJQUFJc0IseUJBQXVCLENBQUNKLFNBQVFyQixNQUFLMEIsV0FBVUM7WUFBYzNCLE9BQUtlLGlCQUFpQmY7WUFBTTNCLGFBQWFnRCxTQUFRO2dCQUFDckIsTUFBS0E7Z0JBQUssZ0JBQWUsU0FBUzRCLEVBQUU7b0JBQUUsT0FBTSxDQUFDLENBQUNBO2dCQUFFO2dCQUFFLGNBQWEsU0FBUzNFLFdBQVcsRUFBQzhDLENBQUM7b0JBQUUsT0FBT0EsSUFBRTJCLFlBQVVDO2dCQUFVO2dCQUFFLGtCQUFpQnhCO2dCQUFvQix3QkFBdUIsU0FBUzlDLE9BQU87b0JBQUUsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDcEgsTUFBTSxDQUFDb0gsUUFBUTtnQkFBQztnQkFBRStDLG9CQUFtQjtZQUFJO1FBQUU7UUFBRSxTQUFTeUI7WUFBc0I3TyxPQUFPQyxNQUFNLENBQUM2TyxnQkFBZ0JDLFNBQVMsRUFBQztnQkFBQ0MsS0FBSXRKLEVBQUU7b0JBQUUsT0FBTyxJQUFJLENBQUN1SixTQUFTLENBQUN2SixHQUFHO2dCQUFBO2dCQUFFd0osS0FBSXhKLEVBQUU7b0JBQUUsT0FBTyxJQUFJLENBQUN1SixTQUFTLENBQUN2SixHQUFHLEtBQUdsRztnQkFBUztnQkFBRTJQLFVBQVNDLE1BQU07b0JBQUUsSUFBSTFKLEtBQUcsSUFBSSxDQUFDMkosUUFBUSxDQUFDbkYsR0FBRyxNQUFJLElBQUksQ0FBQytFLFNBQVMsQ0FBQzFLLE1BQU07b0JBQUMsSUFBSSxDQUFDMEssU0FBUyxDQUFDdkosR0FBRyxHQUFDMEo7b0JBQU8sT0FBTzFKO2dCQUFFO2dCQUFFNEosTUFBSzVKLEVBQUU7b0JBQUUsSUFBSSxDQUFDdUosU0FBUyxDQUFDdkosR0FBRyxHQUFDbEc7b0JBQVUsSUFBSSxDQUFDNlAsUUFBUSxDQUFDMUQsSUFBSSxDQUFDakc7Z0JBQUc7WUFBQztRQUFFO1FBQUMsU0FBU29KO1lBQWtCLElBQUksQ0FBQ0csU0FBUyxHQUFDO2dCQUFDelA7YUFBVTtZQUFDLElBQUksQ0FBQzZQLFFBQVEsR0FBQyxFQUFFO1FBQUE7UUFBQyxJQUFJRSxnQkFBYyxJQUFJVDtRQUFnQixJQUFJVSxpQkFBZUosQ0FBQUE7WUFBUyxJQUFHQSxVQUFRRyxjQUFjRSxRQUFRLElBQUUsTUFBSSxFQUFFRixjQUFjUCxHQUFHLENBQUNJLFFBQVFNLFFBQVEsRUFBQztnQkFBQ0gsY0FBY0QsSUFBSSxDQUFDRjtZQUFPO1FBQUM7UUFBRSxJQUFJTyxzQkFBb0I7WUFBSyxJQUFJQyxRQUFNO1lBQUUsSUFBSSxJQUFJeEUsSUFBRW1FLGNBQWNFLFFBQVEsRUFBQ3JFLElBQUVtRSxjQUFjTixTQUFTLENBQUMxSyxNQUFNLEVBQUMsRUFBRTZHLEVBQUU7Z0JBQUMsSUFBR21FLGNBQWNOLFNBQVMsQ0FBQzdELEVBQUUsS0FBRzVMLFdBQVU7b0JBQUMsRUFBRW9RO2dCQUFLO1lBQUM7WUFBQyxPQUFPQTtRQUFLO1FBQUUsSUFBSUMsYUFBVztZQUFLTixjQUFjTixTQUFTLENBQUN0RCxJQUFJLENBQUM7Z0JBQUNtRSxPQUFNdFE7WUFBUyxHQUFFO2dCQUFDc1EsT0FBTTtZQUFJLEdBQUU7Z0JBQUNBLE9BQU07WUFBSSxHQUFFO2dCQUFDQSxPQUFNO1lBQUs7WUFBR1AsY0FBY0UsUUFBUSxHQUFDRixjQUFjTixTQUFTLENBQUMxSyxNQUFNO1lBQUNwRixNQUFNLENBQUMsc0JBQXNCLEdBQUN3UTtRQUFtQjtRQUFFLElBQUlJLFFBQU07WUFBQ0MsU0FBUVosQ0FBQUE7Z0JBQVMsSUFBRyxDQUFDQSxRQUFPO29CQUFDakIsa0JBQWtCLHNDQUFvQ2lCO2dCQUFPO2dCQUFDLE9BQU9HLGNBQWNQLEdBQUcsQ0FBQ0ksUUFBUVUsS0FBSztZQUFBO1lBQUVHLFVBQVNILENBQUFBO2dCQUFRLE9BQU9BO29CQUFPLEtBQUt0UTt3QkFBVSxPQUFPO29CQUFFLEtBQUs7d0JBQUssT0FBTztvQkFBRSxLQUFLO3dCQUFLLE9BQU87b0JBQUUsS0FBSzt3QkFBTSxPQUFPO29CQUFFO3dCQUFROzRCQUFDLE9BQU8rUCxjQUFjSixRQUFRLENBQUM7Z0NBQUNPLFVBQVM7Z0NBQUVJLE9BQU1BOzRCQUFLO3dCQUFFO2dCQUFDO1lBQUM7UUFBQztRQUFFLElBQUlJLDBCQUF3QixDQUFDN0IsU0FBUXJCO1lBQVFBLE9BQUtlLGlCQUFpQmY7WUFBTTNCLGFBQWFnRCxTQUFRO2dCQUFDckIsTUFBS0E7Z0JBQUssZ0JBQWVvQyxDQUFBQTtvQkFBUyxJQUFJbkMsS0FBRzhDLE1BQU1DLE9BQU8sQ0FBQ1o7b0JBQVFJLGVBQWVKO29CQUFRLE9BQU9uQztnQkFBRTtnQkFBRSxjQUFhLENBQUNoRCxhQUFZNkYsUUFBUUMsTUFBTUUsUUFBUSxDQUFDSDtnQkFBTyxrQkFBaUIzQztnQkFBb0Isd0JBQXVCL0M7Z0JBQTJCZ0Qsb0JBQW1CO1lBQUk7UUFBRTtRQUFFLElBQUkrQyxzQkFBb0IsQ0FBQ0MsT0FBTUMsWUFBV0M7WUFBYSxJQUFHOVEsY0FBWTRRLEtBQUssQ0FBQ0MsV0FBVyxDQUFDRSxhQUFhLEVBQUM7Z0JBQUMsSUFBSUMsV0FBU0osS0FBSyxDQUFDQyxXQUFXO2dCQUFDRCxLQUFLLENBQUNDLFdBQVcsR0FBQztvQkFBVyxJQUFHLENBQUNELEtBQUssQ0FBQ0MsV0FBVyxDQUFDRSxhQUFhLENBQUM3RSxjQUFjLENBQUMrRSxVQUFVbE0sTUFBTSxHQUFFO3dCQUFDNEosa0JBQWtCLGFBQXVFc0MsT0FBMURILFdBQVUsa0RBQXVGRixPQUF2Q0ssVUFBVWxNLE1BQU0sRUFBQyx3QkFBc0QsT0FBaEM2TCxLQUFLLENBQUNDLFdBQVcsQ0FBQ0UsYUFBYSxFQUFDO29CQUFJO29CQUFDLE9BQU9ILEtBQUssQ0FBQ0MsV0FBVyxDQUFDRSxhQUFhLENBQUNFLFVBQVVsTSxNQUFNLENBQUMsQ0FBQ21NLEtBQUssQ0FBQyxJQUFJLEVBQUNEO2dCQUFVO2dCQUFFTCxLQUFLLENBQUNDLFdBQVcsQ0FBQ0UsYUFBYSxHQUFDLEVBQUU7Z0JBQUNILEtBQUssQ0FBQ0MsV0FBVyxDQUFDRSxhQUFhLENBQUNDLFNBQVNHLFFBQVEsQ0FBQyxHQUFDSDtZQUFRO1FBQUM7UUFBRSxJQUFJSSxxQkFBbUIsQ0FBQzVELE1BQUs4QyxPQUFNZTtZQUFnQixJQUFHMVIsT0FBT3VNLGNBQWMsQ0FBQ3NCLE9BQU07Z0JBQUMsSUFBR3hOLGNBQVlxUixnQkFBY3JSLGNBQVlMLE1BQU0sQ0FBQzZOLEtBQUssQ0FBQ3VELGFBQWEsSUFBRS9RLGNBQVlMLE1BQU0sQ0FBQzZOLEtBQUssQ0FBQ3VELGFBQWEsQ0FBQ00sYUFBYSxFQUFDO29CQUFDMUMsa0JBQWtCLGdDQUFxQyxPQUFMbkIsTUFBSztnQkFBUztnQkFBQ21ELG9CQUFvQmhSLFFBQU82TixNQUFLQTtnQkFBTSxJQUFHN04sT0FBT3VNLGNBQWMsQ0FBQ21GLGVBQWM7b0JBQUMxQyxrQkFBa0IsdUZBQW9HLE9BQWIwQyxjQUFhO2dCQUFJO2dCQUFDMVIsTUFBTSxDQUFDNk4sS0FBSyxDQUFDdUQsYUFBYSxDQUFDTSxhQUFhLEdBQUNmO1lBQUssT0FBSztnQkFBQzNRLE1BQU0sQ0FBQzZOLEtBQUssR0FBQzhDO2dCQUFNLElBQUd0USxjQUFZcVIsY0FBYTtvQkFBQzFSLE1BQU0sQ0FBQzZOLEtBQUssQ0FBQzZELFlBQVksR0FBQ0E7Z0JBQVk7WUFBQztRQUFDO1FBQUUsSUFBSUMsMkJBQXlCLENBQUM5RCxNQUFLK0QsT0FBTUM7WUFBVSxPQUFPRDtnQkFBTyxLQUFLO29CQUFFLE9BQU9DLFNBQU8sU0FBUzNHLE9BQU87d0JBQUUsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDckgsS0FBSyxDQUFDcUgsV0FBUyxFQUFFO29CQUFDLElBQUUsU0FBU0EsT0FBTzt3QkFBRSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUNwSCxNQUFNLENBQUNvSCxXQUFTLEVBQUU7b0JBQUM7Z0JBQUUsS0FBSztvQkFBRSxPQUFPMkcsU0FBTyxTQUFTM0csT0FBTzt3QkFBRSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUNuSCxNQUFNLENBQUNtSCxXQUFTLEVBQUU7b0JBQUMsSUFBRSxTQUFTQSxPQUFPO3dCQUFFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQ2xILE9BQU8sQ0FBQ2tILFdBQVMsRUFBRTtvQkFBQztnQkFBRSxLQUFLO29CQUFFLE9BQU8yRyxTQUFPLFNBQVMzRyxPQUFPO3dCQUFFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQ2pILE1BQU0sQ0FBQ2lILFdBQVMsRUFBRTtvQkFBQyxJQUFFLFNBQVNBLE9BQU87d0JBQUUsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDaEgsT0FBTyxDQUFDZ0gsV0FBUyxFQUFFO29CQUFDO2dCQUFFO29CQUFRLE1BQU0sSUFBSTZDLFVBQVUsMEJBQXFDRixPQUFYK0QsT0FBTSxPQUFVLE9BQUwvRDtZQUFPO1FBQUM7UUFBRSxJQUFJaUUseUJBQXVCLENBQUM1QyxTQUFRckIsTUFBS08sTUFBSzJEO1lBQVlsRSxPQUFLZSxpQkFBaUJmO1lBQU0sU0FBU21FLFFBQU87WUFBQ0EsS0FBS0MsTUFBTSxHQUFDLENBQUM7WUFBRS9GLGFBQWFnRCxTQUFRO2dCQUFDckIsTUFBS0E7Z0JBQUtxRSxhQUFZRjtnQkFBSyxnQkFBZSxTQUFTbEQsQ0FBQztvQkFBRSxPQUFPLElBQUksQ0FBQ29ELFdBQVcsQ0FBQ0QsTUFBTSxDQUFDbkQsRUFBRTtnQkFBQTtnQkFBRSxjQUFhLENBQUNoRSxhQUFZZ0UsSUFBSUEsRUFBRTZCLEtBQUs7Z0JBQUMsa0JBQWlCM0M7Z0JBQW9CLHdCQUF1QjJELHlCQUF5QjlELE1BQUtPLE1BQUsyRDtnQkFBVTlELG9CQUFtQjtZQUFJO1lBQUd3RCxtQkFBbUI1RCxNQUFLbUU7UUFBSztRQUFFLElBQUlHLHNCQUFvQixDQUFDdEUsTUFBS3VFLE9BQU92UixPQUFPd1IsY0FBYyxDQUFDRCxNQUFLLFFBQU87Z0JBQUN6QixPQUFNOUM7WUFBSTtRQUFHLElBQUl5RSxjQUFZL0ksQ0FBQUE7WUFBTyxJQUFJRixNQUFJa0osZUFBZWhKO1lBQU0sSUFBSXVFLEtBQUdjLGlCQUFpQnZGO1lBQUttSixNQUFNbko7WUFBSyxPQUFPeUU7UUFBRTtRQUFFLElBQUkyRSx3QkFBc0IsQ0FBQ3ZELFNBQVFpQztZQUFhLElBQUl1QixPQUFLdEgsZUFBZSxDQUFDOEQsUUFBUTtZQUFDLElBQUc3TyxjQUFZcVMsTUFBSztnQkFBQzFELGtCQUFrQm1DLFlBQVUsdUJBQXFCbUIsWUFBWXBEO1lBQVM7WUFBQyxPQUFPd0Q7UUFBSTtRQUFFLElBQUlDLCtCQUE2QixDQUFDQyxhQUFZL0UsTUFBS2dGO1lBQWEsSUFBSUMsV0FBU0wsc0JBQXNCRyxhQUFZO1lBQVEvRSxPQUFLZSxpQkFBaUJmO1lBQU0sSUFBSWtGLE9BQUtELFNBQVNaLFdBQVc7WUFBQyxJQUFJYyxRQUFNblMsT0FBT29TLE1BQU0sQ0FBQ0gsU0FBU1osV0FBVyxDQUFDdEMsU0FBUyxFQUFDO2dCQUFDZSxPQUFNO29CQUFDQSxPQUFNa0M7Z0JBQVM7Z0JBQUVYLGFBQVk7b0JBQUN2QixPQUFNd0Isb0JBQW9CLEdBQW9CdEUsT0FBakJpRixTQUFTakYsSUFBSSxFQUFDLEtBQVEsT0FBTEEsT0FBTyxZQUFXO2dCQUFFO1lBQUM7WUFBR2tGLEtBQUtkLE1BQU0sQ0FBQ1ksVUFBVSxHQUFDRztZQUFNRCxJQUFJLENBQUNsRixLQUFLLEdBQUNtRjtRQUFLO1FBQUUsSUFBSUUsNEJBQTBCLENBQUNyRixNQUFLK0Q7WUFBUyxPQUFPQTtnQkFBTyxLQUFLO29CQUFFLE9BQU8sU0FBUzFHLE9BQU87d0JBQUUsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDL0csT0FBTyxDQUFDK0csV0FBUyxFQUFFO29CQUFDO2dCQUFFLEtBQUs7b0JBQUUsT0FBTyxTQUFTQSxPQUFPO3dCQUFFLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQzlHLE9BQU8sQ0FBQzhHLFdBQVMsRUFBRTtvQkFBQztnQkFBRTtvQkFBUSxNQUFNLElBQUk2QyxVQUFVLHdCQUFtQ0YsT0FBWCtELE9BQU0sT0FBVSxPQUFML0Q7WUFBTztRQUFDO1FBQUUsSUFBSXNGLDBCQUF3QixDQUFDakUsU0FBUXJCLE1BQUtPO1lBQVFQLE9BQUtlLGlCQUFpQmY7WUFBTTNCLGFBQWFnRCxTQUFRO2dCQUFDckIsTUFBS0E7Z0JBQUssZ0JBQWU4QyxDQUFBQSxRQUFPQTtnQkFBTSxjQUFhLENBQUM3RixhQUFZNkYsUUFBUUE7Z0JBQU0sa0JBQWlCM0M7Z0JBQW9CLHdCQUF1QmtGLDBCQUEwQnJGLE1BQUtPO2dCQUFNSCxvQkFBbUI7WUFBSTtRQUFFO1FBQUUsU0FBU21GLFFBQVFsQixXQUFXLEVBQUNtQixZQUFZO1lBQUUsSUFBRyxDQUFFbkIsQ0FBQUEsdUJBQXVCb0IsUUFBTyxHQUFHO2dCQUFDLE1BQU0sSUFBSXZGLFVBQVUscUNBQXdELE9BQW5CLE9BQU9tRSxhQUFZO1lBQTBCO1lBQUMsSUFBSXFCLFFBQU1wQixvQkFBb0JELFlBQVlyRSxJQUFJLElBQUUsdUJBQXNCLFlBQVc7WUFBRzBGLE1BQU0zRCxTQUFTLEdBQUNzQyxZQUFZdEMsU0FBUztZQUFDLElBQUk0RCxNQUFJLElBQUlEO1lBQU0sSUFBSUUsSUFBRXZCLFlBQVlYLEtBQUssQ0FBQ2lDLEtBQUlIO1lBQWMsT0FBT0ksYUFBYTVTLFNBQU80UyxJQUFFRDtRQUFHO1FBQUMsU0FBU0UscUJBQXFCdkMsU0FBUyxFQUFDd0MsUUFBUSxFQUFDQyxTQUFTLEVBQUNDLGNBQWMsRUFBQ0MsYUFBYSxFQUFDQyxPQUFPO1lBQUUsSUFBSXZDLFdBQVNtQyxTQUFTdk8sTUFBTTtZQUFDLElBQUdvTSxXQUFTLEdBQUU7Z0JBQUN4QyxrQkFBa0I7WUFBaUY7WUFBQyxJQUFJZ0Ysb0JBQWtCTCxRQUFRLENBQUMsRUFBRSxLQUFHLFFBQU1DLGNBQVk7WUFBSyxJQUFJSyx1QkFBcUI7WUFBTSxJQUFJLElBQUloSSxJQUFFLEdBQUVBLElBQUUwSCxTQUFTdk8sTUFBTSxFQUFDLEVBQUU2RyxFQUFFO2dCQUFDLElBQUcwSCxRQUFRLENBQUMxSCxFQUFFLEtBQUcsUUFBTTBILFFBQVEsQ0FBQzFILEVBQUUsQ0FBQ2dDLGtCQUFrQixLQUFHNU4sV0FBVTtvQkFBQzRULHVCQUFxQjtvQkFBSztnQkFBSztZQUFDO1lBQUMsSUFBSUMsVUFBUVAsUUFBUSxDQUFDLEVBQUUsQ0FBQzlGLElBQUksS0FBRztZQUFPLElBQUlzRyxXQUFTO1lBQUcsSUFBSUMsZ0JBQWM7WUFBRyxJQUFJLElBQUluSSxJQUFFLEdBQUVBLElBQUV1RixXQUFTLEdBQUUsRUFBRXZGLEVBQUU7Z0JBQUNrSSxZQUFVLENBQUNsSSxNQUFJLElBQUUsT0FBSyxFQUFDLElBQUcsUUFBTUE7Z0JBQUVtSSxpQkFBZSxDQUFDbkksTUFBSSxJQUFFLE9BQUssRUFBQyxJQUFHLFFBQU1BLElBQUU7WUFBTztZQUFDLElBQUlvSSxnQkFBYyw4QkFBK0U3QyxPQUFqRDJDLFVBQVMsMENBQWdHaEQsT0FBeERLLFdBQVMsR0FBRSwrQ0FBbUhBLE9BQXRFTCxXQUFVLDhEQUF1RSxPQUFYSyxXQUFTLEdBQUU7WUFBZ0IsSUFBR3lDLHNCQUFxQjtnQkFBQ0ksaUJBQWU7WUFBeUI7WUFBQyxJQUFJQyxZQUFVTCx1QkFBcUIsZ0JBQWM7WUFBTyxJQUFJTSxRQUFNO2dCQUFDO2dCQUFvQjtnQkFBVTtnQkFBSztnQkFBaUI7Z0JBQVU7YUFBYTtZQUFDLElBQUlDLFFBQU07Z0JBQUN4RjtnQkFBa0I2RTtnQkFBZUM7Z0JBQWNqSjtnQkFBZThJLFFBQVEsQ0FBQyxFQUFFO2dCQUFDQSxRQUFRLENBQUMsRUFBRTthQUFDO1lBQUMsSUFBR0ssbUJBQWtCO2dCQUFDSyxpQkFBZSwyQ0FBeUNDLFlBQVU7WUFBWTtZQUFDLElBQUksSUFBSXJJLElBQUUsR0FBRUEsSUFBRXVGLFdBQVMsR0FBRSxFQUFFdkYsRUFBRTtnQkFBQ29JLGlCQUFlLFlBQVVwSSxJQUFFLG9CQUFrQkEsSUFBRSxpQkFBZXFJLFlBQVUsVUFBUXJJLElBQUUsV0FBUzBILFFBQVEsQ0FBQzFILElBQUUsRUFBRSxDQUFDNEIsSUFBSSxHQUFDO2dCQUFLMEcsTUFBTS9ILElBQUksQ0FBQyxZQUFVUDtnQkFBR3VJLE1BQU1oSSxJQUFJLENBQUNtSCxRQUFRLENBQUMxSCxJQUFFLEVBQUU7WUFBQztZQUFDLElBQUcrSCxtQkFBa0I7Z0JBQUNJLGdCQUFjLGNBQWFBLENBQUFBLGNBQWNoUCxNQUFNLEdBQUMsSUFBRSxPQUFLLEVBQUMsSUFBR2dQO1lBQWE7WUFBQ0MsaUJBQWUsQ0FBQ0gsV0FBU0gsVUFBUSxjQUFZLEVBQUMsSUFBRyxlQUFjSyxDQUFBQSxjQUFjaFAsTUFBTSxHQUFDLElBQUUsT0FBSyxFQUFDLElBQUdnUCxnQkFBYztZQUFPLElBQUdILHNCQUFxQjtnQkFBQ0ksaUJBQWU7WUFBZ0MsT0FBSztnQkFBQyxJQUFJLElBQUlwSSxJQUFFK0gsb0JBQWtCLElBQUUsR0FBRS9ILElBQUUwSCxTQUFTdk8sTUFBTSxFQUFDLEVBQUU2RyxFQUFFO29CQUFDLElBQUl3SSxZQUFVeEksTUFBSSxJQUFFLGNBQVksUUFBT0EsQ0FBQUEsSUFBRSxLQUFHO29CQUFRLElBQUcwSCxRQUFRLENBQUMxSCxFQUFFLENBQUNnQyxrQkFBa0IsS0FBRyxNQUFLO3dCQUFDb0csaUJBQWVJLFlBQVUsV0FBU0EsWUFBVSxXQUFTZCxRQUFRLENBQUMxSCxFQUFFLENBQUM0QixJQUFJLEdBQUM7d0JBQUswRyxNQUFNL0gsSUFBSSxDQUFDaUksWUFBVTt3QkFBU0QsTUFBTWhJLElBQUksQ0FBQ21ILFFBQVEsQ0FBQzFILEVBQUUsQ0FBQ2dDLGtCQUFrQjtvQkFBQztnQkFBQztZQUFDO1lBQUMsSUFBR2lHLFNBQVE7Z0JBQUNHLGlCQUFlLDBDQUF3QztZQUFlLE9BQUssQ0FBQztZQUFDQSxpQkFBZTtZQUFNRSxNQUFNL0gsSUFBSSxDQUFDNkg7WUFBZSxJQUFJSyxZQUFVdEIsUUFBUUUsVUFBU2lCLE9BQU9oRCxLQUFLLENBQUMsTUFBS2lEO1lBQU8sT0FBT3JDLG9CQUFvQmhCLFdBQVV1RDtRQUFVO1FBQUMsSUFBSUMsc0JBQW9CLENBQUNsRSxPQUFNbUU7WUFBZ0IsSUFBSUMsUUFBTSxFQUFFO1lBQUMsSUFBSSxJQUFJNUksSUFBRSxHQUFFQSxJQUFFd0UsT0FBTXhFLElBQUk7Z0JBQUM0SSxNQUFNckksSUFBSSxDQUFDdEksT0FBTyxDQUFDMFEsZUFBYTNJLElBQUUsS0FBRyxFQUFFO1lBQUM7WUFBQyxPQUFPNEk7UUFBSztRQUFFLElBQUlDLHNCQUFvQixDQUFDakgsTUFBSzhDLE9BQU1lO1lBQWdCLElBQUcsQ0FBQzFSLE9BQU91TSxjQUFjLENBQUNzQixPQUFNO2dCQUFDdEMsbUJBQW1CO1lBQXNDO1lBQUMsSUFBR2xMLGNBQVlMLE1BQU0sQ0FBQzZOLEtBQUssQ0FBQ3VELGFBQWEsSUFBRS9RLGNBQVlxUixjQUFhO2dCQUFDMVIsTUFBTSxDQUFDNk4sS0FBSyxDQUFDdUQsYUFBYSxDQUFDTSxhQUFhLEdBQUNmO1lBQUssT0FBSztnQkFBQzNRLE1BQU0sQ0FBQzZOLEtBQUssR0FBQzhDO2dCQUFNM1EsTUFBTSxDQUFDNk4sS0FBSyxDQUFDMkQsUUFBUSxHQUFDRTtZQUFZO1FBQUM7UUFBRSxJQUFJcUQsZ0JBQWMsQ0FBQ0MsS0FBSTNMLEtBQUk0TDtZQUFRLElBQUlDLElBQUVsVixNQUFNLENBQUMsYUFBV2dWLElBQUk7WUFBQyxPQUFPQyxRQUFNQSxLQUFLN1AsTUFBTSxHQUFDOFAsRUFBRTNELEtBQUssQ0FBQyxNQUFLO2dCQUFDbEk7YUFBSSxDQUFDNkQsTUFBTSxDQUFDK0gsU0FBT0MsRUFBRUMsSUFBSSxDQUFDLE1BQUs5TDtRQUFJO1FBQUUsSUFBSStMLGtCQUFnQixFQUFFO1FBQUMsSUFBSXZNO1FBQVUsSUFBSXdNLG9CQUFrQkMsQ0FBQUE7WUFBVSxJQUFJQyxPQUFLSCxlQUFlLENBQUNFLFFBQVE7WUFBQyxJQUFHLENBQUNDLE1BQUs7Z0JBQUMsSUFBR0QsV0FBU0YsZ0JBQWdCaFEsTUFBTSxFQUFDZ1EsZ0JBQWdCaFEsTUFBTSxHQUFDa1EsVUFBUTtnQkFBRUYsZUFBZSxDQUFDRSxRQUFRLEdBQUNDLE9BQUsxTSxVQUFVZ0gsR0FBRyxDQUFDeUY7WUFBUTtZQUFDLE9BQU9DO1FBQUk7UUFBRSxJQUFJQyxVQUFRLENBQUNSLEtBQUkzTCxLQUFJNEw7WUFBUSxJQUFHRCxJQUFJUyxRQUFRLENBQUMsTUFBSztnQkFBQyxPQUFPVixjQUFjQyxLQUFJM0wsS0FBSTRMO1lBQUs7WUFBQyxJQUFJUyxNQUFJTCxrQkFBa0JoTSxLQUFLa0ksS0FBSyxDQUFDLE1BQUswRDtZQUFNLE9BQU9TO1FBQUc7UUFBRSxJQUFJQyxlQUFhLENBQUNYLEtBQUkzTDtZQUFPLElBQUl1TSxXQUFTLEVBQUU7WUFBQyxPQUFPO2dCQUFXQSxTQUFTeFEsTUFBTSxHQUFDO2dCQUFFdkUsT0FBT0MsTUFBTSxDQUFDOFUsVUFBU3RFO2dCQUFXLE9BQU9rRSxRQUFRUixLQUFJM0wsS0FBSXVNO1lBQVM7UUFBQztRQUFFLElBQUlDLDBCQUF3QixDQUFDQyxXQUFVQztZQUFlRCxZQUFVbEgsaUJBQWlCa0g7WUFBVyxTQUFTRTtnQkFBZ0IsSUFBR0YsVUFBVUwsUUFBUSxDQUFDLE1BQUs7b0JBQUMsT0FBT0UsYUFBYUcsV0FBVUM7Z0JBQVk7Z0JBQUMsT0FBT1Ysa0JBQWtCVTtZQUFZO1lBQUMsSUFBSUUsS0FBR0Q7WUFBZ0IsSUFBRyxPQUFPQyxNQUFJLFlBQVc7Z0JBQUNqSCxrQkFBa0IsMkNBQXlEK0csT0FBZEQsV0FBVSxNQUFnQixPQUFaQztZQUFjO1lBQUMsT0FBT0U7UUFBRTtRQUFFLElBQUlDLGNBQVksQ0FBQ0MsZUFBY0M7WUFBYSxJQUFJQyxhQUFXbEUsb0JBQW9CaUUsV0FBVSxTQUFTNUssT0FBTztnQkFBRSxJQUFJLENBQUNxQyxJQUFJLEdBQUN1STtnQkFBVSxJQUFJLENBQUM1SyxPQUFPLEdBQUNBO2dCQUFRLElBQUk4SyxRQUFNLElBQUlDLE1BQU0vSyxTQUFTOEssS0FBSztnQkFBQyxJQUFHQSxVQUFRalcsV0FBVTtvQkFBQyxJQUFJLENBQUNpVyxLQUFLLEdBQUMsSUFBSSxDQUFDRSxRQUFRLEtBQUcsT0FBS0YsTUFBTXJVLE9BQU8sQ0FBQyxzQkFBcUI7Z0JBQUc7WUFBQztZQUFHb1UsV0FBV3pHLFNBQVMsR0FBQy9PLE9BQU9vUyxNQUFNLENBQUNrRCxjQUFjdkcsU0FBUztZQUFFeUcsV0FBV3pHLFNBQVMsQ0FBQ3NDLFdBQVcsR0FBQ21FO1lBQVdBLFdBQVd6RyxTQUFTLENBQUM0RyxRQUFRLEdBQUM7Z0JBQVcsSUFBRyxJQUFJLENBQUNoTCxPQUFPLEtBQUduTCxXQUFVO29CQUFDLE9BQU8sSUFBSSxDQUFDd04sSUFBSTtnQkFBQSxPQUFLO29CQUFDLE9BQU0sR0FBaUIsT0FBZCxJQUFJLENBQUNBLElBQUksRUFBQyxNQUFpQixPQUFiLElBQUksQ0FBQ3JDLE9BQU87Z0JBQUU7WUFBQztZQUFFLE9BQU82SztRQUFVO1FBQUUsSUFBSUk7UUFBaUIsSUFBSUMsd0JBQXNCLENBQUNsTCxTQUFRbUw7WUFBUyxJQUFJQyxlQUFhLEVBQUU7WUFBQyxJQUFJQyxPQUFLLENBQUM7WUFBRSxTQUFTQyxNQUFNdk4sSUFBSTtnQkFBRSxJQUFHc04sSUFBSSxDQUFDdE4sS0FBSyxFQUFDO29CQUFDO2dCQUFNO2dCQUFDLElBQUc2QixlQUFlLENBQUM3QixLQUFLLEVBQUM7b0JBQUM7Z0JBQU07Z0JBQUMsSUFBRzhCLGdCQUFnQixDQUFDOUIsS0FBSyxFQUFDO29CQUFDOEIsZ0JBQWdCLENBQUM5QixLQUFLLENBQUNzQyxPQUFPLENBQUNpTDtvQkFBTztnQkFBTTtnQkFBQ0YsYUFBYXBLLElBQUksQ0FBQ2pEO2dCQUFNc04sSUFBSSxDQUFDdE4sS0FBSyxHQUFDO1lBQUk7WUFBQ29OLE1BQU05SyxPQUFPLENBQUNpTDtZQUFPLE1BQU0sSUFBSUwsaUJBQWlCLEdBQVcsT0FBUmpMLFNBQVEsUUFBSW9MLGFBQWE3SixHQUFHLENBQUN1RixhQUFheUUsSUFBSSxDQUFDO2dCQUFDO2FBQUs7UUFBRTtRQUFFLElBQUlDLGtCQUFnQmxCLENBQUFBO1lBQVlBLFlBQVVBLFVBQVVtQixJQUFJO1lBQUcsTUFBTUMsWUFBVXBCLFVBQVUvVCxPQUFPLENBQUM7WUFBSyxJQUFHbVYsY0FBWSxDQUFDLEdBQUU7Z0JBQUMsT0FBT3BCLFVBQVU5VCxNQUFNLENBQUMsR0FBRWtWO1lBQVUsT0FBSztnQkFBQyxPQUFPcEI7WUFBUztRQUFDO1FBQUUsSUFBSXFCLDZCQUEyQixDQUFDdEosTUFBSzJELFVBQVM0RixpQkFBZ0J0QixXQUFVdUIsWUFBV0MsSUFBR3ZEO1lBQVcsSUFBSUosV0FBU2dCLG9CQUFvQm5ELFVBQVM0RjtZQUFpQnZKLE9BQUtlLGlCQUFpQmY7WUFBTUEsT0FBS21KLGdCQUFnQm5KO1lBQU13SixhQUFXeEIsd0JBQXdCQyxXQUFVdUI7WUFBWTVGLG1CQUFtQjVELE1BQUs7Z0JBQVc2SSxzQkFBc0IsZUFBb0IsT0FBTDdJLE1BQUssMEJBQXVCOEY7WUFBUyxHQUFFbkMsV0FBUztZQUFHL0YsOEJBQThCLEVBQUUsRUFBQ2tJLFVBQVMsU0FBU0EsUUFBUTtnQkFBRSxJQUFJNEQsbUJBQWlCO29CQUFDNUQsUUFBUSxDQUFDLEVBQUU7b0JBQUM7aUJBQUssQ0FBQ3pHLE1BQU0sQ0FBQ3lHLFNBQVM2RCxLQUFLLENBQUM7Z0JBQUkxQyxvQkFBb0JqSCxNQUFLNkYscUJBQXFCN0YsTUFBSzBKLGtCQUFpQixNQUFLRixZQUFXQyxJQUFHdkQsVUFBU3ZDLFdBQVM7Z0JBQUcsT0FBTSxFQUFFO1lBQUE7UUFBRTtRQUFFLElBQUlpRyw4QkFBNEIsQ0FBQzVKLE1BQUsrRCxPQUFNQztZQUFVLE9BQU9EO2dCQUFPLEtBQUs7b0JBQUUsT0FBT0MsU0FBTzNHLENBQUFBLFVBQVNySCxLQUFLLENBQUNxSCxXQUFTLEVBQUUsR0FBQ0EsQ0FBQUEsVUFBU3BILE1BQU0sQ0FBQ29ILFdBQVMsRUFBRTtnQkFBQyxLQUFLO29CQUFFLE9BQU8yRyxTQUFPM0csQ0FBQUEsVUFBU25ILE1BQU0sQ0FBQ21ILFdBQVMsRUFBRSxHQUFDQSxDQUFBQSxVQUFTbEgsT0FBTyxDQUFDa0gsV0FBUyxFQUFFO2dCQUFDLEtBQUs7b0JBQUUsT0FBTzJHLFNBQU8zRyxDQUFBQSxVQUFTakgsTUFBTSxDQUFDaUgsV0FBUyxFQUFFLEdBQUNBLENBQUFBLFVBQVNoSCxPQUFPLENBQUNnSCxXQUFTLEVBQUU7Z0JBQUM7b0JBQVEsTUFBTSxJQUFJNkMsVUFBVSwwQkFBcUNGLE9BQVgrRCxPQUFNLE9BQVUsT0FBTC9EO1lBQU87UUFBQztRQUFFLElBQUk2Siw0QkFBMEIsQ0FBQ3ZKLGVBQWNOLE1BQUtPLE1BQUtDLFVBQVNDO1lBQVlULE9BQUtlLGlCQUFpQmY7WUFBTSxJQUFHUyxhQUFXLENBQUMsR0FBRTtnQkFBQ0EsV0FBUztZQUFVO1lBQUMsSUFBSXFKLGVBQWFoSCxDQUFBQSxRQUFPQTtZQUFNLElBQUd0QyxhQUFXLEdBQUU7Z0JBQUMsSUFBSXVKLFdBQVMsS0FBRyxJQUFFeEo7Z0JBQUt1SixlQUFhaEgsQ0FBQUEsUUFBT0EsU0FBT2lILGFBQVdBO1lBQVE7WUFBQyxJQUFJQyxpQkFBZWhLLEtBQUs0SCxRQUFRLENBQUM7WUFBWSxJQUFJcUMsa0JBQWdCLENBQUNuSCxPQUFNb0gsY0FBYztZQUFFLElBQUlDO1lBQVcsSUFBR0gsZ0JBQWU7Z0JBQUNHLGFBQVcsU0FBU2xOLFdBQVcsRUFBQzZGLEtBQUs7b0JBQUVtSCxnQkFBZ0JuSCxPQUFNLElBQUksQ0FBQzlDLElBQUk7b0JBQUUsT0FBTzhDLFVBQVE7Z0JBQUM7WUFBQyxPQUFLO2dCQUFDcUgsYUFBVyxTQUFTbE4sV0FBVyxFQUFDNkYsS0FBSztvQkFBRW1ILGdCQUFnQm5ILE9BQU0sSUFBSSxDQUFDOUMsSUFBSTtvQkFBRSxPQUFPOEM7Z0JBQUs7WUFBQztZQUFDekUsYUFBYWlDLGVBQWM7Z0JBQUNOLE1BQUtBO2dCQUFLLGdCQUFlOEo7Z0JBQWEsY0FBYUs7Z0JBQVcsa0JBQWlCaEs7Z0JBQW9CLHdCQUF1QnlKLDRCQUE0QjVKLE1BQUtPLE1BQUtDLGFBQVc7Z0JBQUdKLG9CQUFtQjtZQUFJO1FBQUU7UUFBRSxJQUFJZ0ssZ0NBQThCLENBQUMvSSxTQUFRZ0osZUFBY3JLO1lBQVEsSUFBSXNLLGNBQVk7Z0JBQUMzVDtnQkFBVTlCO2dCQUFXK0I7Z0JBQVdDO2dCQUFZQztnQkFBV0M7Z0JBQVlDO2dCQUFhQzthQUFhO1lBQUMsSUFBSXNULEtBQUdELFdBQVcsQ0FBQ0QsY0FBYztZQUFDLFNBQVNHLGlCQUFpQnBJLE1BQU07Z0JBQUUsSUFBSTdCLE9BQUtsSyxPQUFPLENBQUMrTCxVQUFRLEVBQUU7Z0JBQUMsSUFBSXFJLE9BQUtwVSxPQUFPLENBQUMrTCxTQUFPLEtBQUcsRUFBRTtnQkFBQyxPQUFPLElBQUltSSxHQUFHdlUsTUFBTVUsTUFBTSxFQUFDK1QsTUFBS2xLO1lBQUs7WUFBQ1AsT0FBS2UsaUJBQWlCZjtZQUFNM0IsYUFBYWdELFNBQVE7Z0JBQUNyQixNQUFLQTtnQkFBSyxnQkFBZXdLO2dCQUFpQixrQkFBaUJySztnQkFBb0Isd0JBQXVCcUs7WUFBZ0IsR0FBRTtnQkFBQ2hKLDhCQUE2QjtZQUFJO1FBQUU7UUFBRSxTQUFTa0osWUFBWXJOLE9BQU87WUFBRSxPQUFPLElBQUksQ0FBQyxlQUFlLENBQUNoSCxPQUFPLENBQUNnSCxXQUFTLEVBQUU7UUFBQztRQUFDLElBQUlzTixvQkFBa0IsQ0FBQ0MsS0FBSUMsTUFBS0MsUUFBT0M7WUFBbUIsSUFBRyxDQUFFQSxDQUFBQSxrQkFBZ0IsSUFBRyxPQUFPO1lBQUUsSUFBSUMsV0FBU0Y7WUFBTyxJQUFJRyxTQUFPSCxTQUFPQyxrQkFBZ0I7WUFBRSxJQUFJLElBQUkzTSxJQUFFLEdBQUVBLElBQUV3TSxJQUFJclQsTUFBTSxFQUFDLEVBQUU2RyxFQUFFO2dCQUFDLElBQUk4TSxJQUFFTixJQUFJTyxVQUFVLENBQUMvTTtnQkFBRyxJQUFHOE0sS0FBRyxTQUFPQSxLQUFHLE9BQU07b0JBQUMsSUFBSUUsS0FBR1IsSUFBSU8sVUFBVSxDQUFDLEVBQUUvTTtvQkFBRzhNLElBQUUsUUFBTyxFQUFDQSxJQUFFLElBQUcsS0FBSSxFQUFDLElBQUdFLEtBQUc7Z0JBQUk7Z0JBQUMsSUFBR0YsS0FBRyxLQUFJO29CQUFDLElBQUdKLFVBQVFHLFFBQU87b0JBQU1KLElBQUksQ0FBQ0MsU0FBUyxHQUFDSTtnQkFBQyxPQUFNLElBQUdBLEtBQUcsTUFBSztvQkFBQyxJQUFHSixTQUFPLEtBQUdHLFFBQU87b0JBQU1KLElBQUksQ0FBQ0MsU0FBUyxHQUFDLE1BQUlJLEtBQUc7b0JBQUVMLElBQUksQ0FBQ0MsU0FBUyxHQUFDLE1BQUlJLElBQUU7Z0JBQUUsT0FBTSxJQUFHQSxLQUFHLE9BQU07b0JBQUMsSUFBR0osU0FBTyxLQUFHRyxRQUFPO29CQUFNSixJQUFJLENBQUNDLFNBQVMsR0FBQyxNQUFJSSxLQUFHO29CQUFHTCxJQUFJLENBQUNDLFNBQVMsR0FBQyxNQUFJSSxLQUFHLElBQUU7b0JBQUdMLElBQUksQ0FBQ0MsU0FBUyxHQUFDLE1BQUlJLElBQUU7Z0JBQUUsT0FBSztvQkFBQyxJQUFHSixTQUFPLEtBQUdHLFFBQU87b0JBQU1KLElBQUksQ0FBQ0MsU0FBUyxHQUFDLE1BQUlJLEtBQUc7b0JBQUdMLElBQUksQ0FBQ0MsU0FBUyxHQUFDLE1BQUlJLEtBQUcsS0FBRztvQkFBR0wsSUFBSSxDQUFDQyxTQUFTLEdBQUMsTUFBSUksS0FBRyxJQUFFO29CQUFHTCxJQUFJLENBQUNDLFNBQVMsR0FBQyxNQUFJSSxJQUFFO2dCQUFFO1lBQUM7WUFBQ0wsSUFBSSxDQUFDQyxPQUFPLEdBQUM7WUFBRSxPQUFPQSxTQUFPRTtRQUFRO1FBQUUsSUFBSUssZUFBYSxDQUFDVCxLQUFJVSxRQUFPUCxrQkFBa0JKLGtCQUFrQkMsS0FBSTNVLFFBQU9xVixRQUFPUDtRQUFpQixJQUFJUSxrQkFBZ0JYLENBQUFBO1lBQU0sSUFBSVksTUFBSTtZQUFFLElBQUksSUFBSXBOLElBQUUsR0FBRUEsSUFBRXdNLElBQUlyVCxNQUFNLEVBQUMsRUFBRTZHLEVBQUU7Z0JBQUMsSUFBSTZDLElBQUUySixJQUFJTyxVQUFVLENBQUMvTTtnQkFBRyxJQUFHNkMsS0FBRyxLQUFJO29CQUFDdUs7Z0JBQUssT0FBTSxJQUFHdkssS0FBRyxNQUFLO29CQUFDdUssT0FBSztnQkFBQyxPQUFNLElBQUd2SyxLQUFHLFNBQU9BLEtBQUcsT0FBTTtvQkFBQ3VLLE9BQUs7b0JBQUUsRUFBRXBOO2dCQUFDLE9BQUs7b0JBQUNvTixPQUFLO2dCQUFDO1lBQUM7WUFBQyxPQUFPQTtRQUFHO1FBQUUsSUFBSUMsY0FBWSxPQUFPQyxlQUFhLGNBQVksSUFBSUEsWUFBWSxVQUFRbFo7UUFBVSxJQUFJbVosb0JBQWtCLENBQUNDLGFBQVlDLEtBQUlDO1lBQWtCLElBQUliLFNBQU9ZLE1BQUlDO1lBQWUsSUFBSUMsU0FBT0Y7WUFBSSxNQUFNRCxXQUFXLENBQUNHLE9BQU8sSUFBRSxDQUFFQSxDQUFBQSxVQUFRZCxNQUFLLEVBQUcsRUFBRWM7WUFBTyxJQUFHQSxTQUFPRixNQUFJLE1BQUlELFlBQVlsVixNQUFNLElBQUUrVSxhQUFZO2dCQUFDLE9BQU9BLFlBQVlPLE1BQU0sQ0FBQ0osWUFBWUssUUFBUSxDQUFDSixLQUFJRTtZQUFRO1lBQUMsSUFBSW5CLE1BQUk7WUFBRyxNQUFNaUIsTUFBSUUsT0FBTztnQkFBQyxJQUFJRyxLQUFHTixXQUFXLENBQUNDLE1BQU07Z0JBQUMsSUFBRyxDQUFFSyxDQUFBQSxLQUFHLEdBQUUsR0FBRztvQkFBQ3RCLE9BQUtoSyxPQUFPQyxZQUFZLENBQUNxTDtvQkFBSTtnQkFBUTtnQkFBQyxJQUFJZCxLQUFHUSxXQUFXLENBQUNDLE1BQU0sR0FBQztnQkFBRyxJQUFHLENBQUNLLEtBQUcsR0FBRSxLQUFJLEtBQUk7b0JBQUN0QixPQUFLaEssT0FBT0MsWUFBWSxDQUFDLENBQUNxTCxLQUFHLEVBQUMsS0FBSSxJQUFFZDtvQkFBSTtnQkFBUTtnQkFBQyxJQUFJZSxLQUFHUCxXQUFXLENBQUNDLE1BQU0sR0FBQztnQkFBRyxJQUFHLENBQUNLLEtBQUcsR0FBRSxLQUFJLEtBQUk7b0JBQUNBLEtBQUcsQ0FBQ0EsS0FBRyxFQUFDLEtBQUksS0FBR2QsTUFBSSxJQUFFZTtnQkFBRSxPQUFLO29CQUFDRCxLQUFHLENBQUNBLEtBQUcsTUFBSSxLQUFHZCxNQUFJLEtBQUdlLE1BQUksSUFBRVAsV0FBVyxDQUFDQyxNQUFNLEdBQUM7Z0JBQUU7Z0JBQUMsSUFBR0ssS0FBRyxPQUFNO29CQUFDdEIsT0FBS2hLLE9BQU9DLFlBQVksQ0FBQ3FMO2dCQUFHLE9BQUs7b0JBQUMsSUFBSUUsS0FBR0YsS0FBRztvQkFBTXRCLE9BQUtoSyxPQUFPQyxZQUFZLENBQUMsUUFBTXVMLE1BQUksSUFBRyxRQUFNQSxLQUFHO2dCQUFLO1lBQUM7WUFBQyxPQUFPeEI7UUFBRztRQUFFLElBQUl5QixlQUFhLENBQUM3USxLQUFJc1EsaUJBQWlCdFEsTUFBSW1RLGtCQUFrQjFWLFFBQU91RixLQUFJc1Esa0JBQWdCO1FBQUcsSUFBSVEsK0JBQTZCLENBQUNqTCxTQUFRckI7WUFBUUEsT0FBS2UsaUJBQWlCZjtZQUFNLElBQUl1TSxrQkFBZ0J2TSxTQUFPO1lBQWMzQixhQUFhZ0QsU0FBUTtnQkFBQ3JCLE1BQUtBO2dCQUFLLGdCQUFlOEMsS0FBSztvQkFBRSxJQUFJdkwsU0FBT2xCLE9BQU8sQ0FBQ3lNLFNBQU8sRUFBRTtvQkFBQyxJQUFJMEosVUFBUTFKLFFBQU07b0JBQUUsSUFBSThIO29CQUFJLElBQUcyQixpQkFBZ0I7d0JBQUMsSUFBSUUsaUJBQWVEO3dCQUFRLElBQUksSUFBSXBPLElBQUUsR0FBRUEsS0FBRzdHLFFBQU8sRUFBRTZHLEVBQUU7NEJBQUMsSUFBSXNPLGlCQUFlRixVQUFRcE87NEJBQUUsSUFBR0EsS0FBRzdHLFVBQVF0QixNQUFNLENBQUN5VyxlQUFlLElBQUUsR0FBRTtnQ0FBQyxJQUFJQyxVQUFRRCxpQkFBZUQ7Z0NBQWUsSUFBSUcsZ0JBQWNQLGFBQWFJLGdCQUFlRTtnQ0FBUyxJQUFHL0IsUUFBTXBZLFdBQVU7b0NBQUNvWSxNQUFJZ0M7Z0NBQWEsT0FBSztvQ0FBQ2hDLE9BQUtoSyxPQUFPQyxZQUFZLENBQUM7b0NBQUcrSixPQUFLZ0M7Z0NBQWE7Z0NBQUNILGlCQUFlQyxpQkFBZTs0QkFBQzt3QkFBQztvQkFBQyxPQUFLO3dCQUFDLElBQUlHLElBQUUsSUFBSXZPLE1BQU0vRzt3QkFBUSxJQUFJLElBQUk2RyxJQUFFLEdBQUVBLElBQUU3RyxRQUFPLEVBQUU2RyxFQUFFOzRCQUFDeU8sQ0FBQyxDQUFDek8sRUFBRSxHQUFDd0MsT0FBT0MsWUFBWSxDQUFDNUssTUFBTSxDQUFDdVcsVUFBUXBPLEVBQUU7d0JBQUM7d0JBQUN3TSxNQUFJaUMsRUFBRTNELElBQUksQ0FBQztvQkFBRztvQkFBQ3ZFLE1BQU03QjtvQkFBTyxPQUFPOEg7Z0JBQUc7Z0JBQUUsY0FBYTNOLFdBQVcsRUFBQzZGLEtBQUs7b0JBQUUsSUFBR0EsaUJBQWlCZ0ssYUFBWTt3QkFBQ2hLLFFBQU0sSUFBSWpPLFdBQVdpTztvQkFBTTtvQkFBQyxJQUFJdkw7b0JBQU8sSUFBSXdWLHNCQUFvQixPQUFPakssU0FBTztvQkFBUyxJQUFHLENBQUVpSyxDQUFBQSx1QkFBcUJqSyxpQkFBaUJqTyxjQUFZaU8saUJBQWlCa0sscUJBQW1CbEssaUJBQWlCbk0sU0FBUSxHQUFHO3dCQUFDd0ssa0JBQWtCO29CQUF3QztvQkFBQyxJQUFHb0wsbUJBQWlCUSxxQkFBb0I7d0JBQUN4VixTQUFPZ1UsZ0JBQWdCekk7b0JBQU0sT0FBSzt3QkFBQ3ZMLFNBQU91TCxNQUFNdkwsTUFBTTtvQkFBQTtvQkFBQyxJQUFJMFYsT0FBS0MsUUFBUSxJQUFFM1YsU0FBTztvQkFBRyxJQUFJaUUsTUFBSXlSLE9BQUs7b0JBQUU1VyxPQUFPLENBQUM0VyxRQUFNLEVBQUUsR0FBQzFWO29CQUFPLElBQUdnVixtQkFBaUJRLHFCQUFvQjt3QkFBQzFCLGFBQWF2SSxPQUFNdEgsS0FBSWpFLFNBQU87b0JBQUUsT0FBSzt3QkFBQyxJQUFHd1YscUJBQW9COzRCQUFDLElBQUksSUFBSTNPLElBQUUsR0FBRUEsSUFBRTdHLFFBQU8sRUFBRTZHLEVBQUU7Z0NBQUMsSUFBSStPLFdBQVNySyxNQUFNcUksVUFBVSxDQUFDL007Z0NBQUcsSUFBRytPLFdBQVMsS0FBSTtvQ0FBQ3hJLE1BQU1uSjtvQ0FBSzJGLGtCQUFrQjtnQ0FBeUQ7Z0NBQUNsTCxNQUFNLENBQUN1RixNQUFJNEMsRUFBRSxHQUFDK087NEJBQVE7d0JBQUMsT0FBSzs0QkFBQyxJQUFJLElBQUkvTyxJQUFFLEdBQUVBLElBQUU3RyxRQUFPLEVBQUU2RyxFQUFFO2dDQUFDbkksTUFBTSxDQUFDdUYsTUFBSTRDLEVBQUUsR0FBQzBFLEtBQUssQ0FBQzFFLEVBQUU7NEJBQUE7d0JBQUM7b0JBQUM7b0JBQUMsSUFBR25CLGdCQUFjLE1BQUs7d0JBQUNBLFlBQVkwQixJQUFJLENBQUNnRyxPQUFNc0k7b0JBQUs7b0JBQUMsT0FBT0E7Z0JBQUk7Z0JBQUUsa0JBQWlCOU07Z0JBQW9CLHdCQUF1QnVLO2dCQUFZdEssb0JBQW1CNUUsR0FBRztvQkFBRW1KLE1BQU1uSjtnQkFBSTtZQUFDO1FBQUU7UUFBRSxJQUFJNFIsZUFBYSxPQUFPMUIsZUFBYSxjQUFZLElBQUlBLFlBQVksY0FBWWxaO1FBQVUsSUFBSTZhLGdCQUFjLENBQUM3UixLQUFJc1E7WUFBa0IsSUFBSUMsU0FBT3ZRO1lBQUksSUFBSXFRLE1BQUlFLFVBQVE7WUFBRSxJQUFJdUIsU0FBT3pCLE1BQUlDLGlCQUFlO1lBQUUsTUFBTSxDQUFFRCxDQUFBQSxPQUFLeUIsTUFBSyxLQUFJblgsT0FBTyxDQUFDMFYsSUFBSSxDQUFDLEVBQUVBO1lBQUlFLFNBQU9GLE9BQUs7WUFBRSxJQUFHRSxTQUFPdlEsTUFBSSxNQUFJNFIsY0FBYSxPQUFPQSxhQUFhcEIsTUFBTSxDQUFDL1YsT0FBT2dXLFFBQVEsQ0FBQ3pRLEtBQUl1UTtZQUFTLElBQUluQixNQUFJO1lBQUcsSUFBSSxJQUFJeE0sSUFBRSxHQUFFLENBQUVBLENBQUFBLEtBQUcwTixpQkFBZSxJQUFHLEVBQUUxTixFQUFFO2dCQUFDLElBQUltUCxXQUFTclgsTUFBTSxDQUFDc0YsTUFBSTRDLElBQUUsS0FBRyxFQUFFO2dCQUFDLElBQUdtUCxZQUFVLEdBQUU7Z0JBQU0zQyxPQUFLaEssT0FBT0MsWUFBWSxDQUFDME07WUFBUztZQUFDLE9BQU8zQztRQUFHO1FBQUUsSUFBSTRDLGdCQUFjLENBQUM1QyxLQUFJVSxRQUFPUDtZQUFtQixJQUFHQSxvQkFBa0J2WSxXQUFVO2dCQUFDdVksa0JBQWdCO1lBQVU7WUFBQyxJQUFHQSxrQkFBZ0IsR0FBRSxPQUFPO1lBQUVBLG1CQUFpQjtZQUFFLElBQUkwQyxXQUFTbkM7WUFBTyxJQUFJb0Msa0JBQWdCM0Msa0JBQWdCSCxJQUFJclQsTUFBTSxHQUFDLElBQUV3VCxrQkFBZ0IsSUFBRUgsSUFBSXJULE1BQU07WUFBQyxJQUFJLElBQUk2RyxJQUFFLEdBQUVBLElBQUVzUCxpQkFBZ0IsRUFBRXRQLEVBQUU7Z0JBQUMsSUFBSW1QLFdBQVMzQyxJQUFJTyxVQUFVLENBQUMvTTtnQkFBR2xJLE1BQU0sQ0FBQ29WLFVBQVEsRUFBRSxHQUFDaUM7Z0JBQVNqQyxVQUFRO1lBQUM7WUFBQ3BWLE1BQU0sQ0FBQ29WLFVBQVEsRUFBRSxHQUFDO1lBQUUsT0FBT0EsU0FBT21DO1FBQVE7UUFBRSxJQUFJRSxtQkFBaUIvQyxDQUFBQSxNQUFLQSxJQUFJclQsTUFBTSxHQUFDO1FBQUUsSUFBSXFXLGdCQUFjLENBQUNwUyxLQUFJc1E7WUFBa0IsSUFBSTFOLElBQUU7WUFBRSxJQUFJd00sTUFBSTtZQUFHLE1BQU0sQ0FBRXhNLENBQUFBLEtBQUcwTixpQkFBZSxHQUFHO2dCQUFDLElBQUkrQixRQUFNelgsTUFBTSxDQUFDb0YsTUFBSTRDLElBQUUsS0FBRyxFQUFFO2dCQUFDLElBQUd5UCxTQUFPLEdBQUU7Z0JBQU0sRUFBRXpQO2dCQUFFLElBQUd5UCxTQUFPLE9BQU07b0JBQUMsSUFBSXpCLEtBQUd5QixRQUFNO29CQUFNakQsT0FBS2hLLE9BQU9DLFlBQVksQ0FBQyxRQUFNdUwsTUFBSSxJQUFHLFFBQU1BLEtBQUc7Z0JBQUssT0FBSztvQkFBQ3hCLE9BQUtoSyxPQUFPQyxZQUFZLENBQUNnTjtnQkFBTTtZQUFDO1lBQUMsT0FBT2pEO1FBQUc7UUFBRSxJQUFJa0QsZ0JBQWMsQ0FBQ2xELEtBQUlVLFFBQU9QO1lBQW1CLElBQUdBLG9CQUFrQnZZLFdBQVU7Z0JBQUN1WSxrQkFBZ0I7WUFBVTtZQUFDLElBQUdBLGtCQUFnQixHQUFFLE9BQU87WUFBRSxJQUFJMEMsV0FBU25DO1lBQU8sSUFBSVMsU0FBTzBCLFdBQVMxQyxrQkFBZ0I7WUFBRSxJQUFJLElBQUkzTSxJQUFFLEdBQUVBLElBQUV3TSxJQUFJclQsTUFBTSxFQUFDLEVBQUU2RyxFQUFFO2dCQUFDLElBQUltUCxXQUFTM0MsSUFBSU8sVUFBVSxDQUFDL007Z0JBQUcsSUFBR21QLFlBQVUsU0FBT0EsWUFBVSxPQUFNO29CQUFDLElBQUlRLGlCQUFlbkQsSUFBSU8sVUFBVSxDQUFDLEVBQUUvTTtvQkFBR21QLFdBQVMsUUFBTyxFQUFDQSxXQUFTLElBQUcsS0FBSSxFQUFDLElBQUdRLGlCQUFlO2dCQUFJO2dCQUFDM1gsTUFBTSxDQUFDa1YsVUFBUSxFQUFFLEdBQUNpQztnQkFBU2pDLFVBQVE7Z0JBQUUsSUFBR0EsU0FBTyxJQUFFUyxRQUFPO1lBQUs7WUFBQzNWLE1BQU0sQ0FBQ2tWLFVBQVEsRUFBRSxHQUFDO1lBQUUsT0FBT0EsU0FBT21DO1FBQVE7UUFBRSxJQUFJTyxtQkFBaUJwRCxDQUFBQTtZQUFNLElBQUlZLE1BQUk7WUFBRSxJQUFJLElBQUlwTixJQUFFLEdBQUVBLElBQUV3TSxJQUFJclQsTUFBTSxFQUFDLEVBQUU2RyxFQUFFO2dCQUFDLElBQUltUCxXQUFTM0MsSUFBSU8sVUFBVSxDQUFDL007Z0JBQUcsSUFBR21QLFlBQVUsU0FBT0EsWUFBVSxPQUFNLEVBQUVuUDtnQkFBRW9OLE9BQUs7WUFBQztZQUFDLE9BQU9BO1FBQUc7UUFBRSxJQUFJeUMsZ0NBQThCLENBQUM1TSxTQUFRNk0sVUFBU2xPO1lBQVFBLE9BQUtlLGlCQUFpQmY7WUFBTSxJQUFJbU8sY0FBYUMsY0FBYUMsU0FBUUMsZ0JBQWU3VztZQUFNLElBQUd5VyxhQUFXLEdBQUU7Z0JBQUNDLGVBQWFkO2dCQUFjZSxlQUFhWjtnQkFBY2MsaUJBQWVYO2dCQUFpQlUsVUFBUSxJQUFJbFk7Z0JBQVFzQixRQUFNO1lBQUMsT0FBTSxJQUFHeVcsYUFBVyxHQUFFO2dCQUFDQyxlQUFhUDtnQkFBY1EsZUFBYU47Z0JBQWNRLGlCQUFlTjtnQkFBaUJLLFVBQVEsSUFBSWhZO2dCQUFRb0IsUUFBTTtZQUFDO1lBQUM0RyxhQUFhZ0QsU0FBUTtnQkFBQ3JCLE1BQUtBO2dCQUFLLGdCQUFlOEMsQ0FBQUE7b0JBQVEsSUFBSXZMLFNBQU9sQixPQUFPLENBQUN5TSxTQUFPLEVBQUU7b0JBQUMsSUFBSXlMLE9BQUtGO29CQUFVLElBQUl6RDtvQkFBSSxJQUFJNkIsaUJBQWUzSixRQUFNO29CQUFFLElBQUksSUFBSTFFLElBQUUsR0FBRUEsS0FBRzdHLFFBQU8sRUFBRTZHLEVBQUU7d0JBQUMsSUFBSXNPLGlCQUFlNUosUUFBTSxJQUFFMUUsSUFBRThQO3dCQUFTLElBQUc5UCxLQUFHN0csVUFBUWdYLElBQUksQ0FBQzdCLGtCQUFnQmpWLE1BQU0sSUFBRSxHQUFFOzRCQUFDLElBQUkrVyxlQUFhOUIsaUJBQWVEOzRCQUFlLElBQUlHLGdCQUFjdUIsYUFBYTFCLGdCQUFlK0I7NEJBQWMsSUFBRzVELFFBQU1wWSxXQUFVO2dDQUFDb1ksTUFBSWdDOzRCQUFhLE9BQUs7Z0NBQUNoQyxPQUFLaEssT0FBT0MsWUFBWSxDQUFDO2dDQUFHK0osT0FBS2dDOzRCQUFhOzRCQUFDSCxpQkFBZUMsaUJBQWV3Qjt3QkFBUTtvQkFBQztvQkFBQ3ZKLE1BQU03QjtvQkFBTyxPQUFPOEg7Z0JBQUc7Z0JBQUUsY0FBYSxDQUFDM04sYUFBWTZGO29CQUFTLElBQUcsQ0FBRSxRQUFPQSxTQUFPLFFBQU8sR0FBRzt3QkFBQzNCLGtCQUFrQiw2Q0FBa0QsT0FBTG5CO29CQUFPO29CQUFDLElBQUl6SSxTQUFPK1csZUFBZXhMO29CQUFPLElBQUl0SCxNQUFJMFIsUUFBUSxJQUFFM1YsU0FBTzJXO29CQUFVN1gsT0FBTyxDQUFDbUYsT0FBSyxFQUFFLEdBQUNqRSxVQUFRRTtvQkFBTTJXLGFBQWF0TCxPQUFNdEgsTUFBSSxHQUFFakUsU0FBTzJXO29CQUFVLElBQUdqUixnQkFBYyxNQUFLO3dCQUFDQSxZQUFZMEIsSUFBSSxDQUFDZ0csT0FBTW5KO29CQUFJO29CQUFDLE9BQU9BO2dCQUFHO2dCQUFFLGtCQUFpQjJFO2dCQUFvQix3QkFBdUIvQztnQkFBMkJnRCxvQkFBbUI1RSxHQUFHO29CQUFFbUosTUFBTW5KO2dCQUFJO1lBQUM7UUFBRTtRQUFFLElBQUlpVCxnQ0FBOEIsQ0FBQ3BOLFNBQVFyQixNQUFLME8sc0JBQXFCblAsZ0JBQWVvUCxxQkFBb0JuUDtZQUFpQnpDLGtCQUFrQixDQUFDc0UsUUFBUSxHQUFDO2dCQUFDckIsTUFBS2UsaUJBQWlCZjtnQkFBTVQsZ0JBQWV5SSx3QkFBd0IwRyxzQkFBcUJuUDtnQkFBZ0JDLGVBQWN3SSx3QkFBd0IyRyxxQkFBb0JuUDtnQkFBZVQsVUFBUyxFQUFFO1lBQUE7UUFBQztRQUFFLElBQUk2UCx3Q0FBc0MsQ0FBQy9QLGNBQWFPLGtCQUFpQnlQLGlCQUFnQnBQLFFBQU9DLGVBQWNKLG9CQUFtQndQLGlCQUFnQm5QLFFBQU9DO1lBQWlCN0Msa0JBQWtCLENBQUM4QixhQUFhLENBQUNFLFFBQVEsQ0FBQ0osSUFBSSxDQUFDO2dCQUFDUyxrQkFBaUJBO2dCQUFpQkssUUFBT3VJLHdCQUF3QjZHLGlCQUFnQnBQO2dCQUFRQyxlQUFjQTtnQkFBY0osb0JBQW1CQTtnQkFBbUJLLFFBQU9xSSx3QkFBd0I4RyxpQkFBZ0JuUDtnQkFBUUMsZUFBY0E7WUFBYTtRQUFFO1FBQUUsSUFBSW1QLHlCQUF1QixDQUFDMU4sU0FBUXJCO1lBQVFBLE9BQUtlLGlCQUFpQmY7WUFBTTNCLGFBQWFnRCxTQUFRO2dCQUFDMk4sUUFBTztnQkFBS2hQLE1BQUtBO2dCQUFLLGtCQUFpQjtnQkFBRSxnQkFBZSxJQUFJeE47Z0JBQVUsY0FBYSxDQUFDeUssYUFBWThDLElBQUl2TjtZQUFTO1FBQUU7UUFBRSxJQUFJeWMsU0FBTztZQUFLeFosTUFBTTtRQUFHO1FBQUUsSUFBSXlaLHdCQUFzQixDQUFDQyxNQUFLNWMsS0FBSTZjLE1BQU1uWixPQUFPb1osVUFBVSxDQUFDRixNQUFLNWMsS0FBSUEsTUFBSTZjO1FBQUssSUFBSUUsYUFBVyxJQUFJO1FBQVcsSUFBSUMsYUFBV2hQLENBQUFBO1lBQU8sSUFBSTlKLElBQUVmLFdBQVdnQixNQUFNO1lBQUMsSUFBSThZLFFBQU0sQ0FBQ2pQLE9BQUs5SixFQUFFZ1osVUFBVSxHQUFDLEtBQUksSUFBRztZQUFNLElBQUc7Z0JBQUMvWixXQUFXZ2EsSUFBSSxDQUFDRjtnQkFBT2haO2dCQUFvQixPQUFPO1lBQUMsRUFBQyxPQUFNd0MsR0FBRSxDQUFDO1FBQUM7UUFBRSxJQUFJMlcsMEJBQXdCQyxDQUFBQTtZQUFnQixJQUFJQyxVQUFRNVosT0FBT3NCLE1BQU07WUFBQ3FZLG1CQUFpQjtZQUFFLElBQUlFLGNBQVlSO1lBQWEsSUFBR00sZ0JBQWNFLGFBQVk7Z0JBQUMsT0FBTztZQUFLO1lBQUMsSUFBSUMsVUFBUSxDQUFDQyxHQUFFQyxXQUFXRCxJQUFFLENBQUNDLFdBQVNELElBQUVDLFFBQU8sSUFBR0E7WUFBUyxJQUFJLElBQUlDLFVBQVEsR0FBRUEsV0FBUyxHQUFFQSxXQUFTLEVBQUU7Z0JBQUMsSUFBSUMsb0JBQWtCTixVQUFTLEtBQUUsS0FBR0ssT0FBTTtnQkFBR0Msb0JBQWtCQyxLQUFLQyxHQUFHLENBQUNGLG1CQUFrQlAsZ0JBQWM7Z0JBQVcsSUFBSVUsVUFBUUYsS0FBS0MsR0FBRyxDQUFDUCxhQUFZQyxRQUFRSyxLQUFLRyxHQUFHLENBQUNYLGVBQWNPLG9CQUFtQjtnQkFBUSxJQUFJSyxjQUFZakIsV0FBV2U7Z0JBQVMsSUFBR0UsYUFBWTtvQkFBQyxPQUFPO2dCQUFJO1lBQUM7WUFBQyxPQUFPO1FBQUs7UUFBRSxJQUFJQyxNQUFJLENBQUM7UUFBRSxJQUFJQyxvQkFBa0IsSUFBSXZkLGVBQWE7UUFBaUIsSUFBSXdkLGdCQUFjO1lBQUssSUFBRyxDQUFDQSxjQUFjQyxPQUFPLEVBQUM7Z0JBQUMsSUFBSUMsT0FBSyxDQUFDLE9BQU9DLGFBQVcsWUFBVUEsVUFBVUMsU0FBUyxJQUFFRCxVQUFVQyxTQUFTLENBQUMsRUFBRSxJQUFFLEdBQUUsRUFBRzNjLE9BQU8sQ0FBQyxLQUFJLE9BQUs7Z0JBQVMsSUFBSTRjLE1BQUk7b0JBQUMsUUFBTztvQkFBVyxXQUFVO29CQUFXLFFBQU87b0JBQUksT0FBTTtvQkFBSSxRQUFPO29CQUFpQixRQUFPSDtvQkFBSyxLQUFJSDtnQkFBbUI7Z0JBQUUsSUFBSSxJQUFJVixLQUFLUyxJQUFJO29CQUFDLElBQUdBLEdBQUcsQ0FBQ1QsRUFBRSxLQUFHeGQsV0FBVSxPQUFPd2UsR0FBRyxDQUFDaEIsRUFBRTt5QkFBTWdCLEdBQUcsQ0FBQ2hCLEVBQUUsR0FBQ1MsR0FBRyxDQUFDVCxFQUFFO2dCQUFBO2dCQUFDLElBQUlZLFVBQVEsRUFBRTtnQkFBQyxJQUFJLElBQUlaLEtBQUtnQixJQUFJO29CQUFDSixRQUFRalMsSUFBSSxDQUFDLEdBQVFxUyxPQUFMaEIsR0FBRSxLQUFVLE9BQVBnQixHQUFHLENBQUNoQixFQUFFO2dCQUFHO2dCQUFDVyxjQUFjQyxPQUFPLEdBQUNBO1lBQU87WUFBQyxPQUFPRCxjQUFjQyxPQUFPO1FBQUE7UUFBRSxJQUFJSyxnQkFBYyxDQUFDckcsS0FBSWxVO1lBQVUsSUFBSSxJQUFJMEgsSUFBRSxHQUFFQSxJQUFFd00sSUFBSXJULE1BQU0sRUFBQyxFQUFFNkcsRUFBRTtnQkFBQ3BJLEtBQUssQ0FBQ1UsWUFBVSxFQUFFLEdBQUNrVSxJQUFJTyxVQUFVLENBQUMvTTtZQUFFO1lBQUNwSSxLQUFLLENBQUNVLFVBQVEsRUFBRSxHQUFDO1FBQUM7UUFBRSxJQUFJd2EsT0FBSztZQUFDQyxPQUFNeGQsQ0FBQUEsT0FBTUEsS0FBS3lkLE1BQU0sQ0FBQyxPQUFLO1lBQUlDLFdBQVVqWSxDQUFBQTtnQkFBVyxJQUFJa1ksY0FBWTtnQkFBZ0UsT0FBT0EsWUFBWUMsSUFBSSxDQUFDblksVUFBVXVRLEtBQUssQ0FBQztZQUFFO1lBQUU2SCxnQkFBZSxDQUFDQyxPQUFNQztnQkFBa0IsSUFBSUMsS0FBRztnQkFBRSxJQUFJLElBQUl2VCxJQUFFcVQsTUFBTWxhLE1BQU0sR0FBQyxHQUFFNkcsS0FBRyxHQUFFQSxJQUFJO29CQUFDLElBQUl3VCxPQUFLSCxLQUFLLENBQUNyVCxFQUFFO29CQUFDLElBQUd3VCxTQUFPLEtBQUk7d0JBQUNILE1BQU1JLE1BQU0sQ0FBQ3pULEdBQUU7b0JBQUUsT0FBTSxJQUFHd1QsU0FBTyxNQUFLO3dCQUFDSCxNQUFNSSxNQUFNLENBQUN6VCxHQUFFO3dCQUFHdVQ7b0JBQUksT0FBTSxJQUFHQSxJQUFHO3dCQUFDRixNQUFNSSxNQUFNLENBQUN6VCxHQUFFO3dCQUFHdVQ7b0JBQUk7Z0JBQUM7Z0JBQUMsSUFBR0QsZ0JBQWU7b0JBQUMsTUFBS0MsSUFBR0EsS0FBSzt3QkFBQ0YsTUFBTXJaLE9BQU8sQ0FBQztvQkFBSztnQkFBQztnQkFBQyxPQUFPcVo7WUFBSztZQUFFSyxXQUFVbmUsQ0FBQUE7Z0JBQU8sSUFBSW9lLGFBQVdiLEtBQUtDLEtBQUssQ0FBQ3hkLE9BQU1xZSxnQkFBY3JlLEtBQUtRLE1BQU0sQ0FBQyxDQUFDLE9BQUs7Z0JBQUlSLE9BQUt1ZCxLQUFLTSxjQUFjLENBQUM3ZCxLQUFLc2UsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBRyxDQUFDLENBQUNBLElBQUcsQ0FBQ0osWUFBWTdJLElBQUksQ0FBQztnQkFBSyxJQUFHLENBQUN2VixRQUFNLENBQUNvZSxZQUFXO29CQUFDcGUsT0FBSztnQkFBRztnQkFBQyxJQUFHQSxRQUFNcWUsZUFBYztvQkFBQ3JlLFFBQU07Z0JBQUc7Z0JBQUMsT0FBTSxDQUFDb2UsYUFBVyxNQUFJLEVBQUMsSUFBR3BlO1lBQUk7WUFBRXllLFNBQVF6ZSxDQUFBQTtnQkFBTyxJQUFJNkcsU0FBTzBXLEtBQUtHLFNBQVMsQ0FBQzFkLE9BQU0wZSxPQUFLN1gsTUFBTSxDQUFDLEVBQUUsRUFBQzhYLE1BQUk5WCxNQUFNLENBQUMsRUFBRTtnQkFBQyxJQUFHLENBQUM2WCxRQUFNLENBQUNDLEtBQUk7b0JBQUMsT0FBTTtnQkFBRztnQkFBQyxJQUFHQSxLQUFJO29CQUFDQSxNQUFJQSxJQUFJbmUsTUFBTSxDQUFDLEdBQUVtZSxJQUFJL2EsTUFBTSxHQUFDO2dCQUFFO2dCQUFDLE9BQU84YSxPQUFLQztZQUFHO1lBQUVDLFVBQVM1ZSxDQUFBQTtnQkFBTyxJQUFHQSxTQUFPLEtBQUksT0FBTTtnQkFBSUEsT0FBS3VkLEtBQUtZLFNBQVMsQ0FBQ25lO2dCQUFNQSxPQUFLQSxLQUFLUyxPQUFPLENBQUMsT0FBTTtnQkFBSSxJQUFJb2UsWUFBVTdlLEtBQUtVLFdBQVcsQ0FBQztnQkFBSyxJQUFHbWUsY0FBWSxDQUFDLEdBQUUsT0FBTzdlO2dCQUFLLE9BQU9BLEtBQUtRLE1BQU0sQ0FBQ3FlLFlBQVU7WUFBRTtZQUFFdEosTUFBSztnQkFBVyxJQUFJdUosUUFBTW5VLE1BQU15RCxTQUFTLENBQUM0SCxLQUFLLENBQUNyQyxJQUFJLENBQUM3RDtnQkFBVyxPQUFPeU4sS0FBS1ksU0FBUyxDQUFDVyxNQUFNdkosSUFBSSxDQUFDO1lBQUs7WUFBRXdKLE9BQU0sQ0FBQ0MsR0FBRS9NLElBQUlzTCxLQUFLWSxTQUFTLENBQUNhLElBQUUsTUFBSS9NO1FBQUU7UUFBRSxJQUFJZ04saUJBQWU7WUFBSyxJQUFHLE9BQU9DLFVBQVEsWUFBVSxPQUFPQSxNQUFNLENBQUMsa0JBQWtCLElBQUUsWUFBVztnQkFBQyxPQUFPQyxDQUFBQSxPQUFNRCxPQUFPRSxlQUFlLENBQUNEO1lBQUssT0FBTXJkLE1BQU07UUFBbUI7UUFBRSxJQUFJdWQsYUFBV0YsQ0FBQUEsT0FBTSxDQUFDRSxhQUFXSixnQkFBZSxFQUFHRTtRQUFNLElBQUlHLFVBQVE7WUFBQ3BnQixTQUFRO2dCQUFXLElBQUlxZ0IsZUFBYSxJQUFHQyxtQkFBaUI7Z0JBQU0sSUFBSSxJQUFJL1UsSUFBRXFGLFVBQVVsTSxNQUFNLEdBQUMsR0FBRTZHLEtBQUcsQ0FBQyxLQUFHLENBQUMrVSxrQkFBaUIvVSxJQUFJO29CQUFDLElBQUl6SyxPQUFLeUssS0FBRyxJQUFFcUYsU0FBUyxDQUFDckYsRUFBRSxHQUFDeEcsR0FBR3diLEdBQUc7b0JBQUcsSUFBRyxPQUFPemYsUUFBTSxVQUFTO3dCQUFDLE1BQU0sSUFBSXVNLFVBQVU7b0JBQTRDLE9BQU0sSUFBRyxDQUFDdk0sTUFBSzt3QkFBQyxPQUFNO29CQUFFO29CQUFDdWYsZUFBYXZmLE9BQUssTUFBSXVmO29CQUFhQyxtQkFBaUJqQyxLQUFLQyxLQUFLLENBQUN4ZDtnQkFBSztnQkFBQ3VmLGVBQWFoQyxLQUFLTSxjQUFjLENBQUMwQixhQUFhakIsS0FBSyxDQUFDLEtBQUtDLE1BQU0sQ0FBQ0MsQ0FBQUEsSUFBRyxDQUFDLENBQUNBLElBQUcsQ0FBQ2dCLGtCQUFrQmpLLElBQUksQ0FBQztnQkFBSyxPQUFNLENBQUNpSyxtQkFBaUIsTUFBSSxFQUFDLElBQUdELGdCQUFjO1lBQUc7WUFBRUcsVUFBUyxDQUFDQyxNQUFLQztnQkFBTUQsT0FBS0wsUUFBUXBnQixPQUFPLENBQUN5Z0IsTUFBTW5mLE1BQU0sQ0FBQztnQkFBR29mLEtBQUdOLFFBQVFwZ0IsT0FBTyxDQUFDMGdCLElBQUlwZixNQUFNLENBQUM7Z0JBQUcsU0FBU2lWLEtBQUtvSyxHQUFHO29CQUFFLElBQUlDLFFBQU07b0JBQUUsTUFBS0EsUUFBTUQsSUFBSWpjLE1BQU0sRUFBQ2tjLFFBQVE7d0JBQUMsSUFBR0QsR0FBRyxDQUFDQyxNQUFNLEtBQUcsSUFBRztvQkFBSztvQkFBQyxJQUFJQyxNQUFJRixJQUFJamMsTUFBTSxHQUFDO29CQUFFLE1BQUttYyxPQUFLLEdBQUVBLE1BQU07d0JBQUMsSUFBR0YsR0FBRyxDQUFDRSxJQUFJLEtBQUcsSUFBRztvQkFBSztvQkFBQyxJQUFHRCxRQUFNQyxLQUFJLE9BQU0sRUFBRTtvQkFBQyxPQUFPRixJQUFJN0osS0FBSyxDQUFDOEosT0FBTUMsTUFBSUQsUUFBTTtnQkFBRTtnQkFBQyxJQUFJRSxZQUFVdkssS0FBS2tLLEtBQUtyQixLQUFLLENBQUM7Z0JBQU0sSUFBSTJCLFVBQVF4SyxLQUFLbUssR0FBR3RCLEtBQUssQ0FBQztnQkFBTSxJQUFJMWEsU0FBTzZZLEtBQUtDLEdBQUcsQ0FBQ3NELFVBQVVwYyxNQUFNLEVBQUNxYyxRQUFRcmMsTUFBTTtnQkFBRSxJQUFJc2Msa0JBQWdCdGM7Z0JBQU8sSUFBSSxJQUFJNkcsSUFBRSxHQUFFQSxJQUFFN0csUUFBTzZHLElBQUk7b0JBQUMsSUFBR3VWLFNBQVMsQ0FBQ3ZWLEVBQUUsS0FBR3dWLE9BQU8sQ0FBQ3hWLEVBQUUsRUFBQzt3QkFBQ3lWLGtCQUFnQnpWO3dCQUFFO29CQUFLO2dCQUFDO2dCQUFDLElBQUkwVixjQUFZLEVBQUU7Z0JBQUMsSUFBSSxJQUFJMVYsSUFBRXlWLGlCQUFnQnpWLElBQUV1VixVQUFVcGMsTUFBTSxFQUFDNkcsSUFBSTtvQkFBQzBWLFlBQVluVixJQUFJLENBQUM7Z0JBQUs7Z0JBQUNtVixjQUFZQSxZQUFZelUsTUFBTSxDQUFDdVUsUUFBUWpLLEtBQUssQ0FBQ2tLO2dCQUFrQixPQUFPQyxZQUFZNUssSUFBSSxDQUFDO1lBQUk7UUFBQztRQUFFLElBQUk2SywwQkFBd0IsRUFBRTtRQUFDLFNBQVNDLG1CQUFtQkMsT0FBTyxFQUFDQyxXQUFXLEVBQUMzYyxNQUFNO1lBQUUsSUFBSWlVLE1BQUlqVSxTQUFPLElBQUVBLFNBQU9nVSxnQkFBZ0IwSSxXQUFTO1lBQUUsSUFBSUUsVUFBUSxJQUFJN1YsTUFBTWtOO1lBQUssSUFBSTRJLGtCQUFnQnpKLGtCQUFrQnNKLFNBQVFFLFNBQVEsR0FBRUEsUUFBUTVjLE1BQU07WUFBRSxJQUFHMmMsYUFBWUMsUUFBUTVjLE1BQU0sR0FBQzZjO1lBQWdCLE9BQU9EO1FBQU87UUFBQyxJQUFJRSxtQkFBaUI7WUFBSyxJQUFHLENBQUNOLHdCQUF3QnhjLE1BQU0sRUFBQztnQkFBQyxJQUFJaUQsU0FBTztnQkFBSyxJQUFHLEtBQTBCLElBQUUsT0FBTzhaLE9BQU9DLE1BQU0sSUFBRSxZQUFXO29CQUFDL1osU0FBTzhaLE9BQU9DLE1BQU0sQ0FBQztvQkFBVyxJQUFHL1osV0FBUyxNQUFLO3dCQUFDQSxVQUFRO29CQUFJO2dCQUFDLE9BQU0sSUFBRyxPQUFPZ2EsWUFBVSxZQUFXO29CQUFDaGEsU0FBT2dhO29CQUFXLElBQUdoYSxXQUFTLE1BQUs7d0JBQUNBLFVBQVE7b0JBQUk7Z0JBQUM7Z0JBQUMsSUFBRyxDQUFDQSxRQUFPO29CQUFDLE9BQU87Z0JBQUk7Z0JBQUN1WiwwQkFBd0JDLG1CQUFtQnhaLFFBQU87WUFBSztZQUFDLE9BQU91Wix3QkFBd0J0YyxLQUFLO1FBQUU7UUFBRSxJQUFJTyxNQUFJO1lBQUN5YyxNQUFLLEVBQUU7WUFBQzVjLFNBQU87WUFBRTZjLGFBQVc7WUFBRUMsVUFBU0MsR0FBRyxFQUFDQyxHQUFHO2dCQUFFN2MsSUFBSXljLElBQUksQ0FBQ0csSUFBSSxHQUFDO29CQUFDRSxPQUFNLEVBQUU7b0JBQUNDLFFBQU8sRUFBRTtvQkFBQ0YsS0FBSUE7Z0JBQUc7Z0JBQUVqZCxHQUFHb2QsY0FBYyxDQUFDSixLQUFJNWMsSUFBSWlkLFVBQVU7WUFBQztZQUFFQSxZQUFXO2dCQUFDeGdCLE1BQUt5Z0IsTUFBTTtvQkFBRSxJQUFJQyxNQUFJbmQsSUFBSXljLElBQUksQ0FBQ1MsT0FBT0UsSUFBSSxDQUFDQyxJQUFJLENBQUM7b0JBQUMsSUFBRyxDQUFDRixLQUFJO3dCQUFDLE1BQU0sSUFBSXZkLEdBQUcwZCxVQUFVLENBQUM7b0JBQUc7b0JBQUNKLE9BQU9DLEdBQUcsR0FBQ0E7b0JBQUlELE9BQU9LLFFBQVEsR0FBQztnQkFBSztnQkFBRUMsT0FBTU4sTUFBTTtvQkFBRUEsT0FBT0MsR0FBRyxDQUFDTixHQUFHLENBQUNZLEtBQUssQ0FBQ1AsT0FBT0MsR0FBRztnQkFBQztnQkFBRU0sT0FBTVAsTUFBTTtvQkFBRUEsT0FBT0MsR0FBRyxDQUFDTixHQUFHLENBQUNZLEtBQUssQ0FBQ1AsT0FBT0MsR0FBRztnQkFBQztnQkFBRXRWLE1BQUtxVixNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUNvZSxHQUFHO29CQUFFLElBQUcsQ0FBQ1QsT0FBT0MsR0FBRyxJQUFFLENBQUNELE9BQU9DLEdBQUcsQ0FBQ04sR0FBRyxDQUFDZSxRQUFRLEVBQUM7d0JBQUMsTUFBTSxJQUFJaGUsR0FBRzBkLFVBQVUsQ0FBQztvQkFBRztvQkFBQyxJQUFJTyxZQUFVO29CQUFFLElBQUksSUFBSXpYLElBQUUsR0FBRUEsSUFBRTdHLFFBQU82RyxJQUFJO3dCQUFDLElBQUk1RDt3QkFBTyxJQUFHOzRCQUFDQSxTQUFPMGEsT0FBT0MsR0FBRyxDQUFDTixHQUFHLENBQUNlLFFBQVEsQ0FBQ1YsT0FBT0MsR0FBRzt3QkFBQyxFQUFDLE9BQU1uYyxHQUFFOzRCQUFDLE1BQU0sSUFBSXBCLEdBQUcwZCxVQUFVLENBQUM7d0JBQUc7d0JBQUMsSUFBRzlhLFdBQVNoSSxhQUFXcWpCLGNBQVksR0FBRTs0QkFBQyxNQUFNLElBQUlqZSxHQUFHMGQsVUFBVSxDQUFDO3dCQUFFO3dCQUFDLElBQUc5YSxXQUFTLFFBQU1BLFdBQVNoSSxXQUFVO3dCQUFNcWpCO3dCQUFZbmYsTUFBTSxDQUFDZ2YsU0FBT3RYLEVBQUUsR0FBQzVEO29CQUFNO29CQUFDLElBQUdxYixXQUFVO3dCQUFDWCxPQUFPRSxJQUFJLENBQUNVLFNBQVMsR0FBQ0MsS0FBS0MsR0FBRztvQkFBRTtvQkFBQyxPQUFPSDtnQkFBUztnQkFBRS9WLE9BQU1vVixNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUNvZSxHQUFHO29CQUFFLElBQUcsQ0FBQ1QsT0FBT0MsR0FBRyxJQUFFLENBQUNELE9BQU9DLEdBQUcsQ0FBQ04sR0FBRyxDQUFDb0IsUUFBUSxFQUFDO3dCQUFDLE1BQU0sSUFBSXJlLEdBQUcwZCxVQUFVLENBQUM7b0JBQUc7b0JBQUMsSUFBRzt3QkFBQyxJQUFJLElBQUlsWCxJQUFFLEdBQUVBLElBQUU3RyxRQUFPNkcsSUFBSTs0QkFBQzhXLE9BQU9DLEdBQUcsQ0FBQ04sR0FBRyxDQUFDb0IsUUFBUSxDQUFDZixPQUFPQyxHQUFHLEVBQUN6ZSxNQUFNLENBQUNnZixTQUFPdFgsRUFBRTt3QkFBQztvQkFBQyxFQUFDLE9BQU1wRixHQUFFO3dCQUFDLE1BQU0sSUFBSXBCLEdBQUcwZCxVQUFVLENBQUM7b0JBQUc7b0JBQUMsSUFBRy9kLFFBQU87d0JBQUMyZCxPQUFPRSxJQUFJLENBQUNVLFNBQVMsR0FBQ0MsS0FBS0MsR0FBRztvQkFBRTtvQkFBQyxPQUFPNVg7Z0JBQUM7WUFBQztZQUFFOFgsaUJBQWdCO2dCQUFDTixVQUFTVCxHQUFHO29CQUFFLE9BQU9kO2dCQUFrQjtnQkFBRTRCLFVBQVNkLEdBQUcsRUFBQ2dCLEdBQUc7b0JBQUUsSUFBR0EsUUFBTSxRQUFNQSxRQUFNLElBQUc7d0JBQUNsaEIsSUFBSTBXLGtCQUFrQndKLElBQUlKLE1BQU0sRUFBQzt3QkFBSUksSUFBSUosTUFBTSxHQUFDLEVBQUU7b0JBQUEsT0FBSzt3QkFBQyxJQUFHb0IsT0FBSyxHQUFFaEIsSUFBSUosTUFBTSxDQUFDcFcsSUFBSSxDQUFDd1g7b0JBQUk7Z0JBQUM7Z0JBQUVWLE9BQU1OLEdBQUc7b0JBQUUsSUFBR0EsSUFBSUosTUFBTSxJQUFFSSxJQUFJSixNQUFNLENBQUN4ZCxNQUFNLEdBQUMsR0FBRTt3QkFBQ3RDLElBQUkwVyxrQkFBa0J3SixJQUFJSixNQUFNLEVBQUM7d0JBQUlJLElBQUlKLE1BQU0sR0FBQyxFQUFFO29CQUFBO2dCQUFDO2dCQUFFcUIsY0FBYWpCLEdBQUc7b0JBQUUsT0FBTTt3QkFBQ2tCLFNBQVE7d0JBQU1DLFNBQVE7d0JBQUVDLFNBQVE7d0JBQUlDLFNBQVE7d0JBQU1DLE1BQUs7NEJBQUM7NEJBQUU7NEJBQUc7NEJBQUk7NEJBQUc7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUU7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUc7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7NEJBQUU7eUJBQUU7b0JBQUE7Z0JBQUM7Z0JBQUVDLGNBQWF2QixHQUFHLEVBQUN3QixnQkFBZ0IsRUFBQ2xNLElBQUk7b0JBQUUsT0FBTztnQkFBQztnQkFBRW1NLGtCQUFpQnpCLEdBQUc7b0JBQUUsT0FBTTt3QkFBQzt3QkFBRztxQkFBRztnQkFBQTtZQUFDO1lBQUUwQixrQkFBaUI7Z0JBQUNaLFVBQVNkLEdBQUcsRUFBQ2dCLEdBQUc7b0JBQUUsSUFBR0EsUUFBTSxRQUFNQSxRQUFNLElBQUc7d0JBQUM5Z0IsSUFBSXNXLGtCQUFrQndKLElBQUlKLE1BQU0sRUFBQzt3QkFBSUksSUFBSUosTUFBTSxHQUFDLEVBQUU7b0JBQUEsT0FBSzt3QkFBQyxJQUFHb0IsT0FBSyxHQUFFaEIsSUFBSUosTUFBTSxDQUFDcFcsSUFBSSxDQUFDd1g7b0JBQUk7Z0JBQUM7Z0JBQUVWLE9BQU1OLEdBQUc7b0JBQUUsSUFBR0EsSUFBSUosTUFBTSxJQUFFSSxJQUFJSixNQUFNLENBQUN4ZCxNQUFNLEdBQUMsR0FBRTt3QkFBQ2xDLElBQUlzVyxrQkFBa0J3SixJQUFJSixNQUFNLEVBQUM7d0JBQUlJLElBQUlKLE1BQU0sR0FBQyxFQUFFO29CQUFBO2dCQUFDO1lBQUM7UUFBQztRQUFFLElBQUkrQixZQUFVdlcsQ0FBQUE7WUFBTzlLO1FBQU87UUFBRSxJQUFJc2hCLFFBQU07WUFBQ0MsV0FBVTtZQUFLQyxPQUFNQSxLQUFLO2dCQUFFLE9BQU9GLE1BQU1HLFVBQVUsQ0FBQyxNQUFLLEtBQUksUUFBTSxLQUFJO1lBQUU7WUFBRUEsWUFBV0MsTUFBTSxFQUFDblgsSUFBSSxFQUFDb1gsSUFBSSxFQUFDeEMsR0FBRztnQkFBRSxJQUFHaGQsR0FBR3lmLFFBQVEsQ0FBQ0QsU0FBT3hmLEdBQUcwZixNQUFNLENBQUNGLE9BQU07b0JBQUMsTUFBTSxJQUFJeGYsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHLENBQUN5QixNQUFNQyxTQUFTLEVBQUM7b0JBQUNELE1BQU1DLFNBQVMsR0FBQzt3QkFBQzFFLEtBQUk7NEJBQUM4QyxNQUFLO2dDQUFDbUMsU0FBUVIsTUFBTVMsUUFBUSxDQUFDRCxPQUFPO2dDQUFDRSxTQUFRVixNQUFNUyxRQUFRLENBQUNDLE9BQU87Z0NBQUNDLFFBQU9YLE1BQU1TLFFBQVEsQ0FBQ0UsTUFBTTtnQ0FBQ0MsT0FBTVosTUFBTVMsUUFBUSxDQUFDRyxLQUFLO2dDQUFDQyxRQUFPYixNQUFNUyxRQUFRLENBQUNJLE1BQU07Z0NBQUNDLFFBQU9kLE1BQU1TLFFBQVEsQ0FBQ0ssTUFBTTtnQ0FBQ0MsT0FBTWYsTUFBTVMsUUFBUSxDQUFDTSxLQUFLO2dDQUFDQyxTQUFRaEIsTUFBTVMsUUFBUSxDQUFDTyxPQUFPO2dDQUFDQyxTQUFRakIsTUFBTVMsUUFBUSxDQUFDUSxPQUFPOzRCQUFBOzRCQUFFOUMsUUFBTztnQ0FBQytDLFFBQU9sQixNQUFNOUIsVUFBVSxDQUFDZ0QsTUFBTTs0QkFBQTt3QkFBQzt3QkFBRXplLE1BQUs7NEJBQUM0YixNQUFLO2dDQUFDbUMsU0FBUVIsTUFBTVMsUUFBUSxDQUFDRCxPQUFPO2dDQUFDRSxTQUFRVixNQUFNUyxRQUFRLENBQUNDLE9BQU87NEJBQUE7NEJBQUV2QyxRQUFPO2dDQUFDK0MsUUFBT2xCLE1BQU05QixVQUFVLENBQUNnRCxNQUFNO2dDQUFDcFksTUFBS2tYLE1BQU05QixVQUFVLENBQUNwVixJQUFJO2dDQUFDQyxPQUFNaVgsTUFBTTlCLFVBQVUsQ0FBQ25WLEtBQUs7Z0NBQUNxQyxVQUFTNFUsTUFBTTlCLFVBQVUsQ0FBQzlTLFFBQVE7Z0NBQUMrVixNQUFLbkIsTUFBTTlCLFVBQVUsQ0FBQ2lELElBQUk7Z0NBQUNDLE9BQU1wQixNQUFNOUIsVUFBVSxDQUFDa0QsS0FBSzs0QkFBQTt3QkFBQzt3QkFBRUMsTUFBSzs0QkFBQ2hELE1BQUs7Z0NBQUNtQyxTQUFRUixNQUFNUyxRQUFRLENBQUNELE9BQU87Z0NBQUNFLFNBQVFWLE1BQU1TLFFBQVEsQ0FBQ0MsT0FBTztnQ0FBQ1ksVUFBU3RCLE1BQU1TLFFBQVEsQ0FBQ2EsUUFBUTs0QkFBQTs0QkFBRW5ELFFBQU8sQ0FBQzt3QkFBQzt3QkFBRW9ELFFBQU87NEJBQUNsRCxNQUFLO2dDQUFDbUMsU0FBUVIsTUFBTVMsUUFBUSxDQUFDRCxPQUFPO2dDQUFDRSxTQUFRVixNQUFNUyxRQUFRLENBQUNDLE9BQU87NEJBQUE7NEJBQUV2QyxRQUFPdGQsR0FBRzJnQixpQkFBaUI7d0JBQUE7b0JBQUM7Z0JBQUM7Z0JBQUMsSUFBSW5ELE9BQUt4ZCxHQUFHc2YsVUFBVSxDQUFDQyxRQUFPblgsTUFBS29YLE1BQUt4QztnQkFBSyxJQUFHaGQsR0FBRzRnQixLQUFLLENBQUNwRCxLQUFLZ0MsSUFBSSxHQUFFO29CQUFDaEMsS0FBS29DLFFBQVEsR0FBQ1QsTUFBTUMsU0FBUyxDQUFDMUUsR0FBRyxDQUFDOEMsSUFBSTtvQkFBQ0EsS0FBS0gsVUFBVSxHQUFDOEIsTUFBTUMsU0FBUyxDQUFDMUUsR0FBRyxDQUFDNEMsTUFBTTtvQkFBQ0UsS0FBS3FELFFBQVEsR0FBQyxDQUFDO2dCQUFDLE9BQU0sSUFBRzdnQixHQUFHOGdCLE1BQU0sQ0FBQ3RELEtBQUtnQyxJQUFJLEdBQUU7b0JBQUNoQyxLQUFLb0MsUUFBUSxHQUFDVCxNQUFNQyxTQUFTLENBQUN4ZCxJQUFJLENBQUM0YixJQUFJO29CQUFDQSxLQUFLSCxVQUFVLEdBQUM4QixNQUFNQyxTQUFTLENBQUN4ZCxJQUFJLENBQUMwYixNQUFNO29CQUFDRSxLQUFLdUQsU0FBUyxHQUFDO29CQUFFdkQsS0FBS3FELFFBQVEsR0FBQztnQkFBSSxPQUFNLElBQUc3Z0IsR0FBR2doQixNQUFNLENBQUN4RCxLQUFLZ0MsSUFBSSxHQUFFO29CQUFDaEMsS0FBS29DLFFBQVEsR0FBQ1QsTUFBTUMsU0FBUyxDQUFDb0IsSUFBSSxDQUFDaEQsSUFBSTtvQkFBQ0EsS0FBS0gsVUFBVSxHQUFDOEIsTUFBTUMsU0FBUyxDQUFDb0IsSUFBSSxDQUFDbEQsTUFBTTtnQkFBQSxPQUFNLElBQUd0ZCxHQUFHaWhCLFFBQVEsQ0FBQ3pELEtBQUtnQyxJQUFJLEdBQUU7b0JBQUNoQyxLQUFLb0MsUUFBUSxHQUFDVCxNQUFNQyxTQUFTLENBQUNzQixNQUFNLENBQUNsRCxJQUFJO29CQUFDQSxLQUFLSCxVQUFVLEdBQUM4QixNQUFNQyxTQUFTLENBQUNzQixNQUFNLENBQUNwRCxNQUFNO2dCQUFBO2dCQUFDRSxLQUFLVSxTQUFTLEdBQUNDLEtBQUtDLEdBQUc7Z0JBQUcsSUFBR21CLFFBQU87b0JBQUNBLE9BQU9zQixRQUFRLENBQUN6WSxLQUFLLEdBQUNvVjtvQkFBSytCLE9BQU9yQixTQUFTLEdBQUNWLEtBQUtVLFNBQVM7Z0JBQUE7Z0JBQUMsT0FBT1Y7WUFBSTtZQUFFMEQseUJBQXdCMUQsSUFBSTtnQkFBRSxJQUFHLENBQUNBLEtBQUtxRCxRQUFRLEVBQUMsT0FBTyxJQUFJNWpCLFdBQVc7Z0JBQUcsSUFBR3VnQixLQUFLcUQsUUFBUSxDQUFDeE0sUUFBUSxFQUFDLE9BQU9tSixLQUFLcUQsUUFBUSxDQUFDeE0sUUFBUSxDQUFDLEdBQUVtSixLQUFLdUQsU0FBUztnQkFBRSxPQUFPLElBQUk5akIsV0FBV3VnQixLQUFLcUQsUUFBUTtZQUFDO1lBQUVNLG1CQUFrQjNELElBQUksRUFBQzRELFdBQVc7Z0JBQUUsSUFBSUMsZUFBYTdELEtBQUtxRCxRQUFRLEdBQUNyRCxLQUFLcUQsUUFBUSxDQUFDbGhCLE1BQU0sR0FBQztnQkFBRSxJQUFHMGhCLGdCQUFjRCxhQUFZO2dCQUFPLElBQUlFLHdCQUFzQixPQUFLO2dCQUFLRixjQUFZNUksS0FBS0csR0FBRyxDQUFDeUksYUFBWUMsZUFBY0EsQ0FBQUEsZUFBYUMsd0JBQXNCLElBQUUsS0FBSSxNQUFLO2dCQUFHLElBQUdELGdCQUFjLEdBQUVELGNBQVk1SSxLQUFLRyxHQUFHLENBQUN5SSxhQUFZO2dCQUFLLElBQUlHLGNBQVkvRCxLQUFLcUQsUUFBUTtnQkFBQ3JELEtBQUtxRCxRQUFRLEdBQUMsSUFBSTVqQixXQUFXbWtCO2dCQUFhLElBQUc1RCxLQUFLdUQsU0FBUyxHQUFDLEdBQUV2RCxLQUFLcUQsUUFBUSxDQUFDVyxHQUFHLENBQUNELFlBQVlsTixRQUFRLENBQUMsR0FBRW1KLEtBQUt1RCxTQUFTLEdBQUU7WUFBRTtZQUFFVSxtQkFBa0JqRSxJQUFJLEVBQUM5RSxPQUFPO2dCQUFFLElBQUc4RSxLQUFLdUQsU0FBUyxJQUFFckksU0FBUTtnQkFBTyxJQUFHQSxXQUFTLEdBQUU7b0JBQUM4RSxLQUFLcUQsUUFBUSxHQUFDO29CQUFLckQsS0FBS3VELFNBQVMsR0FBQztnQkFBQyxPQUFLO29CQUFDLElBQUlRLGNBQVkvRCxLQUFLcUQsUUFBUTtvQkFBQ3JELEtBQUtxRCxRQUFRLEdBQUMsSUFBSTVqQixXQUFXeWI7b0JBQVMsSUFBRzZJLGFBQVk7d0JBQUMvRCxLQUFLcUQsUUFBUSxDQUFDVyxHQUFHLENBQUNELFlBQVlsTixRQUFRLENBQUMsR0FBRW1FLEtBQUtDLEdBQUcsQ0FBQ0MsU0FBUThFLEtBQUt1RCxTQUFTO29CQUFHO29CQUFDdkQsS0FBS3VELFNBQVMsR0FBQ3JJO2dCQUFPO1lBQUM7WUFBRWtILFVBQVM7Z0JBQUNELFNBQVFuQyxJQUFJO29CQUFFLElBQUlrRSxPQUFLLENBQUM7b0JBQUVBLEtBQUsxRSxHQUFHLEdBQUNoZCxHQUFHaWhCLFFBQVEsQ0FBQ3pELEtBQUtnQyxJQUFJLElBQUVoQyxLQUFLMWMsRUFBRSxHQUFDO29CQUFFNGdCLEtBQUtDLEdBQUcsR0FBQ25FLEtBQUsxYyxFQUFFO29CQUFDNGdCLEtBQUtsQyxJQUFJLEdBQUNoQyxLQUFLZ0MsSUFBSTtvQkFBQ2tDLEtBQUtFLEtBQUssR0FBQztvQkFBRUYsS0FBS0csR0FBRyxHQUFDO29CQUFFSCxLQUFLSSxHQUFHLEdBQUM7b0JBQUVKLEtBQUtqRSxJQUFJLEdBQUNELEtBQUtDLElBQUk7b0JBQUMsSUFBR3pkLEdBQUc0Z0IsS0FBSyxDQUFDcEQsS0FBS2dDLElBQUksR0FBRTt3QkFBQ2tDLEtBQUsvWSxJQUFJLEdBQUM7b0JBQUksT0FBTSxJQUFHM0ksR0FBRzhnQixNQUFNLENBQUN0RCxLQUFLZ0MsSUFBSSxHQUFFO3dCQUFDa0MsS0FBSy9ZLElBQUksR0FBQzZVLEtBQUt1RCxTQUFTO29CQUFBLE9BQU0sSUFBRy9nQixHQUFHZ2hCLE1BQU0sQ0FBQ3hELEtBQUtnQyxJQUFJLEdBQUU7d0JBQUNrQyxLQUFLL1ksSUFBSSxHQUFDNlUsS0FBS2dELElBQUksQ0FBQzdnQixNQUFNO29CQUFBLE9BQUs7d0JBQUMraEIsS0FBSy9ZLElBQUksR0FBQztvQkFBQztvQkFBQytZLEtBQUtLLEtBQUssR0FBQyxJQUFJNUQsS0FBS1gsS0FBS1UsU0FBUztvQkFBRXdELEtBQUtNLEtBQUssR0FBQyxJQUFJN0QsS0FBS1gsS0FBS1UsU0FBUztvQkFBRXdELEtBQUtPLEtBQUssR0FBQyxJQUFJOUQsS0FBS1gsS0FBS1UsU0FBUztvQkFBRXdELEtBQUtRLE9BQU8sR0FBQztvQkFBS1IsS0FBS1MsTUFBTSxHQUFDM0osS0FBSzRKLElBQUksQ0FBQ1YsS0FBSy9ZLElBQUksR0FBQytZLEtBQUtRLE9BQU87b0JBQUUsT0FBT1I7Z0JBQUk7Z0JBQUU3QixTQUFRckMsSUFBSSxFQUFDa0UsSUFBSTtvQkFBRSxJQUFHQSxLQUFLbEMsSUFBSSxLQUFHNWtCLFdBQVU7d0JBQUM0aUIsS0FBS2dDLElBQUksR0FBQ2tDLEtBQUtsQyxJQUFJO29CQUFBO29CQUFDLElBQUdrQyxLQUFLeEQsU0FBUyxLQUFHdGpCLFdBQVU7d0JBQUM0aUIsS0FBS1UsU0FBUyxHQUFDd0QsS0FBS3hELFNBQVM7b0JBQUE7b0JBQUMsSUFBR3dELEtBQUsvWSxJQUFJLEtBQUcvTixXQUFVO3dCQUFDdWtCLE1BQU1zQyxpQkFBaUIsQ0FBQ2pFLE1BQUtrRSxLQUFLL1ksSUFBSTtvQkFBQztnQkFBQztnQkFBRW1YLFFBQU9QLE1BQU0sRUFBQ25YLElBQUk7b0JBQUUsTUFBTXBJLEdBQUdxaUIsYUFBYSxDQUFDLEdBQUc7Z0JBQUE7Z0JBQUV0QyxPQUFNUixNQUFNLEVBQUNuWCxJQUFJLEVBQUNvWCxJQUFJLEVBQUN4QyxHQUFHO29CQUFFLE9BQU9tQyxNQUFNRyxVQUFVLENBQUNDLFFBQU9uWCxNQUFLb1gsTUFBS3hDO2dCQUFJO2dCQUFFZ0QsUUFBT3NDLFFBQVEsRUFBQ0MsT0FBTyxFQUFDQyxRQUFRO29CQUFFLElBQUd4aUIsR0FBRzRnQixLQUFLLENBQUMwQixTQUFTOUMsSUFBSSxHQUFFO3dCQUFDLElBQUlpRDt3QkFBUyxJQUFHOzRCQUFDQSxXQUFTemlCLEdBQUcwaUIsVUFBVSxDQUFDSCxTQUFRQzt3QkFBUyxFQUFDLE9BQU1waEIsR0FBRSxDQUFDO3dCQUFDLElBQUdxaEIsVUFBUzs0QkFBQyxJQUFJLElBQUlqYyxLQUFLaWMsU0FBUzVCLFFBQVEsQ0FBQztnQ0FBQyxNQUFNLElBQUk3Z0IsR0FBRzBkLFVBQVUsQ0FBQzs0QkFBRzt3QkFBQztvQkFBQztvQkFBQyxPQUFPNEUsU0FBUy9DLE1BQU0sQ0FBQ3NCLFFBQVEsQ0FBQ3lCLFNBQVNsYSxJQUFJLENBQUM7b0JBQUNrYSxTQUFTL0MsTUFBTSxDQUFDckIsU0FBUyxHQUFDQyxLQUFLQyxHQUFHO29CQUFHa0UsU0FBU2xhLElBQUksR0FBQ29hO29CQUFTRCxRQUFRMUIsUUFBUSxDQUFDMkIsU0FBUyxHQUFDRjtvQkFBU0MsUUFBUXJFLFNBQVMsR0FBQ29FLFNBQVMvQyxNQUFNLENBQUNyQixTQUFTO29CQUFDb0UsU0FBUy9DLE1BQU0sR0FBQ2dEO2dCQUFPO2dCQUFFdEMsUUFBT1YsTUFBTSxFQUFDblgsSUFBSTtvQkFBRSxPQUFPbVgsT0FBT3NCLFFBQVEsQ0FBQ3pZLEtBQUs7b0JBQUNtWCxPQUFPckIsU0FBUyxHQUFDQyxLQUFLQyxHQUFHO2dCQUFFO2dCQUFFOEIsT0FBTVgsTUFBTSxFQUFDblgsSUFBSTtvQkFBRSxJQUFJb1YsT0FBS3hkLEdBQUcwaUIsVUFBVSxDQUFDbkQsUUFBT25YO29CQUFNLElBQUksSUFBSTVCLEtBQUtnWCxLQUFLcUQsUUFBUSxDQUFDO3dCQUFDLE1BQU0sSUFBSTdnQixHQUFHMGQsVUFBVSxDQUFDO29CQUFHO29CQUFDLE9BQU82QixPQUFPc0IsUUFBUSxDQUFDelksS0FBSztvQkFBQ21YLE9BQU9yQixTQUFTLEdBQUNDLEtBQUtDLEdBQUc7Z0JBQUU7Z0JBQUUrQixTQUFRM0MsSUFBSTtvQkFBRSxJQUFJbUYsVUFBUTt3QkFBQzt3QkFBSTtxQkFBSztvQkFBQyxJQUFJLElBQUlDLE9BQU9wRixLQUFLcUQsUUFBUSxDQUFDO3dCQUFDLElBQUcsQ0FBQ3JELEtBQUtxRCxRQUFRLENBQUMvWixjQUFjLENBQUM4YixNQUFLOzRCQUFDO3dCQUFRO3dCQUFDRCxRQUFRNWIsSUFBSSxDQUFDNmI7b0JBQUk7b0JBQUMsT0FBT0Q7Z0JBQU87Z0JBQUV2QyxTQUFRYixNQUFNLEVBQUNzRCxPQUFPLEVBQUNDLE9BQU87b0JBQUUsSUFBSXRGLE9BQUsyQixNQUFNRyxVQUFVLENBQUNDLFFBQU9zRCxTQUFRLE1BQUksT0FBTTtvQkFBR3JGLEtBQUtnRCxJQUFJLEdBQUNzQztvQkFBUSxPQUFPdEY7Z0JBQUk7Z0JBQUVpRCxVQUFTakQsSUFBSTtvQkFBRSxJQUFHLENBQUN4ZCxHQUFHZ2hCLE1BQU0sQ0FBQ3hELEtBQUtnQyxJQUFJLEdBQUU7d0JBQUMsTUFBTSxJQUFJeGYsR0FBRzBkLFVBQVUsQ0FBQztvQkFBRztvQkFBQyxPQUFPRixLQUFLZ0QsSUFBSTtnQkFBQTtZQUFDO1lBQUVuRCxZQUFXO2dCQUFDcFYsTUFBS3FWLE1BQU0sRUFBQ3hlLE1BQU0sRUFBQ2dmLE1BQU0sRUFBQ25lLE1BQU0sRUFBQ29qQixRQUFRO29CQUFFLElBQUlsQyxXQUFTdkQsT0FBT0UsSUFBSSxDQUFDcUQsUUFBUTtvQkFBQyxJQUFHa0MsWUFBVXpGLE9BQU9FLElBQUksQ0FBQ3VELFNBQVMsRUFBQyxPQUFPO29CQUFFLElBQUlwWSxPQUFLNlAsS0FBS0MsR0FBRyxDQUFDNkUsT0FBT0UsSUFBSSxDQUFDdUQsU0FBUyxHQUFDZ0MsVUFBU3BqQjtvQkFBUSxJQUFHZ0osT0FBSyxLQUFHa1ksU0FBU3hNLFFBQVEsRUFBQzt3QkFBQ3ZWLE9BQU8waUIsR0FBRyxDQUFDWCxTQUFTeE0sUUFBUSxDQUFDME8sVUFBU0EsV0FBU3BhLE9BQU1tVjtvQkFBTyxPQUFLO3dCQUFDLElBQUksSUFBSXRYLElBQUUsR0FBRUEsSUFBRW1DLE1BQUtuQyxJQUFJMUgsTUFBTSxDQUFDZ2YsU0FBT3RYLEVBQUUsR0FBQ3FhLFFBQVEsQ0FBQ2tDLFdBQVN2YyxFQUFFO29CQUFBO29CQUFDLE9BQU9tQztnQkFBSTtnQkFBRVQsT0FBTW9WLE1BQU0sRUFBQ3hlLE1BQU0sRUFBQ2dmLE1BQU0sRUFBQ25lLE1BQU0sRUFBQ29qQixRQUFRLEVBQUNDLE1BQU07b0JBQUUsSUFBR2xrQixPQUFPQSxNQUFNLEtBQUdWLE1BQU1VLE1BQU0sRUFBQzt3QkFBQ2trQixTQUFPO29CQUFLO29CQUFDLElBQUcsQ0FBQ3JqQixRQUFPLE9BQU87b0JBQUUsSUFBSTZkLE9BQUtGLE9BQU9FLElBQUk7b0JBQUNBLEtBQUtVLFNBQVMsR0FBQ0MsS0FBS0MsR0FBRztvQkFBRyxJQUFHdGYsT0FBT3VWLFFBQVEsSUFBRyxFQUFDbUosS0FBS3FELFFBQVEsSUFBRXJELEtBQUtxRCxRQUFRLENBQUN4TSxRQUFRLEdBQUU7d0JBQUMsSUFBRzJPLFFBQU87NEJBQUN4RixLQUFLcUQsUUFBUSxHQUFDL2hCLE9BQU91VixRQUFRLENBQUN5SixRQUFPQSxTQUFPbmU7NEJBQVE2ZCxLQUFLdUQsU0FBUyxHQUFDcGhCOzRCQUFPLE9BQU9BO3dCQUFNLE9BQU0sSUFBRzZkLEtBQUt1RCxTQUFTLEtBQUcsS0FBR2dDLGFBQVcsR0FBRTs0QkFBQ3ZGLEtBQUtxRCxRQUFRLEdBQUMvaEIsT0FBT2lULEtBQUssQ0FBQytMLFFBQU9BLFNBQU9uZTs0QkFBUTZkLEtBQUt1RCxTQUFTLEdBQUNwaEI7NEJBQU8sT0FBT0E7d0JBQU0sT0FBTSxJQUFHb2pCLFdBQVNwakIsVUFBUTZkLEtBQUt1RCxTQUFTLEVBQUM7NEJBQUN2RCxLQUFLcUQsUUFBUSxDQUFDVyxHQUFHLENBQUMxaUIsT0FBT3VWLFFBQVEsQ0FBQ3lKLFFBQU9BLFNBQU9uZSxTQUFRb2pCOzRCQUFVLE9BQU9wakI7d0JBQU07b0JBQUM7b0JBQUN3ZixNQUFNZ0MsaUJBQWlCLENBQUMzRCxNQUFLdUYsV0FBU3BqQjtvQkFBUSxJQUFHNmQsS0FBS3FELFFBQVEsQ0FBQ3hNLFFBQVEsSUFBRXZWLE9BQU91VixRQUFRLEVBQUM7d0JBQUNtSixLQUFLcUQsUUFBUSxDQUFDVyxHQUFHLENBQUMxaUIsT0FBT3VWLFFBQVEsQ0FBQ3lKLFFBQU9BLFNBQU9uZSxTQUFRb2pCO29CQUFTLE9BQUs7d0JBQUMsSUFBSSxJQUFJdmMsSUFBRSxHQUFFQSxJQUFFN0csUUFBTzZHLElBQUk7NEJBQUNnWCxLQUFLcUQsUUFBUSxDQUFDa0MsV0FBU3ZjLEVBQUUsR0FBQzFILE1BQU0sQ0FBQ2dmLFNBQU90WCxFQUFFO3dCQUFBO29CQUFDO29CQUFDZ1gsS0FBS3VELFNBQVMsR0FBQ3ZJLEtBQUtHLEdBQUcsQ0FBQzZFLEtBQUt1RCxTQUFTLEVBQUNnQyxXQUFTcGpCO29CQUFRLE9BQU9BO2dCQUFNO2dCQUFFMGdCLFFBQU8vQyxNQUFNLEVBQUNRLE1BQU0sRUFBQ21GLE1BQU07b0JBQUUsSUFBSUYsV0FBU2pGO29CQUFPLElBQUdtRixXQUFTLEdBQUU7d0JBQUNGLFlBQVV6RixPQUFPeUYsUUFBUTtvQkFBQSxPQUFNLElBQUdFLFdBQVMsR0FBRTt3QkFBQyxJQUFHampCLEdBQUc4Z0IsTUFBTSxDQUFDeEQsT0FBT0UsSUFBSSxDQUFDZ0MsSUFBSSxHQUFFOzRCQUFDdUQsWUFBVXpGLE9BQU9FLElBQUksQ0FBQ3VELFNBQVM7d0JBQUE7b0JBQUM7b0JBQUMsSUFBR2dDLFdBQVMsR0FBRTt3QkFBQyxNQUFNLElBQUkvaUIsR0FBRzBkLFVBQVUsQ0FBQztvQkFBRztvQkFBQyxPQUFPcUY7Z0JBQVE7Z0JBQUV4WSxVQUFTK1MsTUFBTSxFQUFDUSxNQUFNLEVBQUNuZSxNQUFNO29CQUFFd2YsTUFBTWdDLGlCQUFpQixDQUFDN0QsT0FBT0UsSUFBSSxFQUFDTSxTQUFPbmU7b0JBQVEyZCxPQUFPRSxJQUFJLENBQUN1RCxTQUFTLEdBQUN2SSxLQUFLRyxHQUFHLENBQUMyRSxPQUFPRSxJQUFJLENBQUN1RCxTQUFTLEVBQUNqRCxTQUFPbmU7Z0JBQU87Z0JBQUUyZ0IsTUFBS2hELE1BQU0sRUFBQzNkLE1BQU0sRUFBQ29qQixRQUFRLEVBQUNHLElBQUksRUFBQ0MsS0FBSztvQkFBRSxJQUFHLENBQUNuakIsR0FBRzhnQixNQUFNLENBQUN4RCxPQUFPRSxJQUFJLENBQUNnQyxJQUFJLEdBQUU7d0JBQUMsTUFBTSxJQUFJeGYsR0FBRzBkLFVBQVUsQ0FBQztvQkFBRztvQkFBQyxJQUFJOVo7b0JBQUksSUFBSXlHO29CQUFVLElBQUl3VyxXQUFTdkQsT0FBT0UsSUFBSSxDQUFDcUQsUUFBUTtvQkFBQyxJQUFHLENBQUVzQyxDQUFBQSxRQUFNLE1BQUl0QyxTQUFTL2hCLE1BQU0sS0FBR1YsTUFBTVUsTUFBTSxFQUFDO3dCQUFDdUwsWUFBVTt3QkFBTXpHLE1BQUlpZCxTQUFTdUMsVUFBVTtvQkFBQSxPQUFLO3dCQUFDLElBQUdMLFdBQVMsS0FBR0EsV0FBU3BqQixTQUFPa2hCLFNBQVNsaEIsTUFBTSxFQUFDOzRCQUFDLElBQUdraEIsU0FBU3hNLFFBQVEsRUFBQztnQ0FBQ3dNLFdBQVNBLFNBQVN4TSxRQUFRLENBQUMwTyxVQUFTQSxXQUFTcGpCOzRCQUFPLE9BQUs7Z0NBQUNraEIsV0FBU25hLE1BQU15RCxTQUFTLENBQUM0SCxLQUFLLENBQUNyQyxJQUFJLENBQUNtUixVQUFTa0MsVUFBU0EsV0FBU3BqQjs0QkFBTzt3QkFBQzt3QkFBQzBLLFlBQVU7d0JBQUt6RyxNQUFJc2IsVUFBVXZmO3dCQUFRLElBQUcsQ0FBQ2lFLEtBQUk7NEJBQUMsTUFBTSxJQUFJNUQsR0FBRzBkLFVBQVUsQ0FBQzt3QkFBRzt3QkFBQ3RmLE1BQU1vakIsR0FBRyxDQUFDWCxVQUFTamQ7b0JBQUk7b0JBQUMsT0FBTTt3QkFBQ0EsS0FBSUE7d0JBQUl5RyxXQUFVQTtvQkFBUztnQkFBQztnQkFBRWtXLE9BQU1qRCxNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUMwakIsU0FBUztvQkFBRWxFLE1BQU05QixVQUFVLENBQUNuVixLQUFLLENBQUNvVixRQUFPeGUsUUFBTyxHQUFFYSxRQUFPbWUsUUFBTztvQkFBTyxPQUFPO2dCQUFDO1lBQUM7UUFBQztRQUFFLElBQUl3RixZQUFVLENBQUM1bUIsS0FBSVMsUUFBT0MsU0FBUW1tQjtZQUFZLElBQUlDLE1BQUksQ0FBQ0QsV0FBUzFpQix1QkFBdUIsTUFBVSxPQUFKbkUsUUFBTztZQUFHVCxVQUFVUyxLQUFJK21CLENBQUFBO2dCQUFjeGxCLE9BQU93bEIsYUFBWSxzQkFBMEIsT0FBSi9tQixLQUFJO2dCQUE2QlMsT0FBTyxJQUFJRixXQUFXd21CO2dCQUFjLElBQUdELEtBQUl4aUIsb0JBQW9Cd2lCO1lBQUksR0FBRUUsQ0FBQUE7Z0JBQVEsSUFBR3RtQixTQUFRO29CQUFDQTtnQkFBUyxPQUFLO29CQUFDLE1BQUssc0JBQTBCLE9BQUpWLEtBQUk7Z0JBQVU7WUFBQztZQUFHLElBQUc4bUIsS0FBSXppQixpQkFBaUJ5aUI7UUFBSTtRQUFFLElBQUlHLG9CQUFrQixDQUFDcEUsUUFBT25YLE1BQUt3YixVQUFTQyxTQUFRQyxVQUFTZDtZQUFVaGpCLEdBQUcrakIsY0FBYyxDQUFDeEUsUUFBT25YLE1BQUt3YixVQUFTQyxTQUFRQyxVQUFTZDtRQUFPO1FBQUUsSUFBSWdCLGlCQUFlenBCLE1BQU0sQ0FBQyxpQkFBaUIsSUFBRSxFQUFFO1FBQUMsSUFBSTBwQiw0QkFBMEIsQ0FBQ0MsV0FBVUMsVUFBU0MsUUFBT2huQjtZQUFXLElBQUcsT0FBT2luQixXQUFTLGFBQVlBLFFBQVFwa0IsSUFBSTtZQUFHLElBQUlxa0IsVUFBUTtZQUFNTixlQUFlNWQsT0FBTyxDQUFDbWUsQ0FBQUE7Z0JBQVMsSUFBR0QsU0FBUTtnQkFBTyxJQUFHQyxNQUFNLENBQUMsWUFBWSxDQUFDSixXQUFVO29CQUFDSSxNQUFNLENBQUMsU0FBUyxDQUFDTCxXQUFVQyxVQUFTQyxRQUFPaG5CO29CQUFTa25CLFVBQVE7Z0JBQUk7WUFBQztZQUFHLE9BQU9BO1FBQU87UUFBRSxJQUFJRSx5QkFBdUIsQ0FBQ2pGLFFBQU9uWCxNQUFLMUwsS0FBSW1uQixTQUFRQyxVQUFTM21CLFFBQU9DLFNBQVFxbkIsZ0JBQWV6QixRQUFPMEI7WUFBYSxJQUFJUCxXQUFTL2IsT0FBS2lULFFBQVFwZ0IsT0FBTyxDQUFDcWUsS0FBS3dCLEtBQUssQ0FBQ3lFLFFBQU9uWCxTQUFPbVg7WUFBTyxJQUFJaUUsTUFBSTNpQix1QkFBdUIsTUFBZSxPQUFUc2pCO1lBQVksU0FBU1EsWUFBWVQsU0FBUztnQkFBRSxTQUFTRSxPQUFPRixTQUFTO29CQUFFLElBQUdRLFdBQVVBO29CQUFZLElBQUcsQ0FBQ0QsZ0JBQWU7d0JBQUNkLGtCQUFrQnBFLFFBQU9uWCxNQUFLOGIsV0FBVUwsU0FBUUMsVUFBU2Q7b0JBQU87b0JBQUMsSUFBRzdsQixRQUFPQTtvQkFBUzZELG9CQUFvQndpQjtnQkFBSTtnQkFBQyxJQUFHUywwQkFBMEJDLFdBQVVDLFVBQVNDLFFBQU87b0JBQUssSUFBR2huQixTQUFRQTtvQkFBVTRELG9CQUFvQndpQjtnQkFBSSxJQUFHO29CQUFDO2dCQUFNO2dCQUFDWSxPQUFPRjtZQUFVO1lBQUNuakIsaUJBQWlCeWlCO1lBQUssSUFBRyxPQUFPOW1CLE9BQUssVUFBUztnQkFBQzRtQixVQUFVNW1CLEtBQUl3bkIsQ0FBQUEsWUFBV1MsWUFBWVQsWUFBVzltQjtZQUFRLE9BQUs7Z0JBQUN1bkIsWUFBWWpvQjtZQUFJO1FBQUM7UUFBRSxJQUFJa29CLHVCQUFxQjVSLENBQUFBO1lBQU0sSUFBSTZSLFlBQVU7Z0JBQUMsS0FBSTtnQkFBRSxNQUFLO2dCQUFFLEtBQUksTUFBSSxLQUFHO2dCQUFFLE1BQUssTUFBSSxLQUFHO2dCQUFFLEtBQUksT0FBSyxLQUFHO2dCQUFFLE1BQUssT0FBSyxLQUFHO1lBQUM7WUFBRSxJQUFJMUIsUUFBTTBCLFNBQVMsQ0FBQzdSLElBQUk7WUFBQyxJQUFHLE9BQU9tUSxTQUFPLGFBQVk7Z0JBQUMsTUFBTSxJQUFJclMsTUFBTSwyQkFBK0IsT0FBSmtDO1lBQU07WUFBQyxPQUFPbVE7UUFBSztRQUFFLElBQUkyQixhQUFXLENBQUNqQixTQUFRQztZQUFZLElBQUl0RSxPQUFLO1lBQUUsSUFBR3FFLFNBQVFyRSxRQUFNLE1BQUk7WUFBRyxJQUFHc0UsVUFBU3RFLFFBQU07WUFBSSxPQUFPQTtRQUFJO1FBQUUsSUFBSXhmLEtBQUc7WUFBQ3lhLE1BQUs7WUFBS3NLLFFBQU8sRUFBRTtZQUFDQyxTQUFRLENBQUM7WUFBRUMsU0FBUSxFQUFFO1lBQUNDLFdBQVU7WUFBRUMsV0FBVTtZQUFLQyxhQUFZO1lBQUlsbEIsYUFBWTtZQUFNQyxtQkFBa0I7WUFBS3VkLFlBQVc7WUFBSzJFLGVBQWMsQ0FBQztZQUFFZ0QsYUFBWTtZQUFLQyxnQkFBZTtZQUFFQyxZQUFXeHBCLElBQUk7b0JBQUN5cEIsT0FBQUEsaUVBQUssQ0FBQztnQkFBR3pwQixPQUFLc2YsUUFBUXBnQixPQUFPLENBQUNjO2dCQUFNLElBQUcsQ0FBQ0EsTUFBSyxPQUFNO29CQUFDQSxNQUFLO29CQUFHeWhCLE1BQUs7Z0JBQUk7Z0JBQUUsSUFBSWlJLFdBQVM7b0JBQUNDLGNBQWE7b0JBQUtDLGVBQWM7Z0JBQUM7Z0JBQUVILE9BQUtwcUIsT0FBT0MsTUFBTSxDQUFDb3FCLFVBQVNEO2dCQUFNLElBQUdBLEtBQUtHLGFBQWEsR0FBQyxHQUFFO29CQUFDLE1BQU0sSUFBSTNsQixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLElBQUk3RCxRQUFNOWQsS0FBS3NlLEtBQUssQ0FBQyxLQUFLQyxNQUFNLENBQUNDLENBQUFBLElBQUcsQ0FBQyxDQUFDQTtnQkFBRyxJQUFJcUwsVUFBUTVsQixHQUFHeWEsSUFBSTtnQkFBQyxJQUFJb0wsZUFBYTtnQkFBSSxJQUFJLElBQUlyZixJQUFFLEdBQUVBLElBQUVxVCxNQUFNbGEsTUFBTSxFQUFDNkcsSUFBSTtvQkFBQyxJQUFJc2YsU0FBT3RmLE1BQUlxVCxNQUFNbGEsTUFBTSxHQUFDO29CQUFFLElBQUdtbUIsVUFBUU4sS0FBS2pHLE1BQU0sRUFBQzt3QkFBQztvQkFBSztvQkFBQ3FHLFVBQVE1bEIsR0FBRzBpQixVQUFVLENBQUNrRCxTQUFRL0wsS0FBSyxDQUFDclQsRUFBRTtvQkFBRXFmLGVBQWF2TSxLQUFLd0IsS0FBSyxDQUFDK0ssY0FBYWhNLEtBQUssQ0FBQ3JULEVBQUU7b0JBQUUsSUFBR3hHLEdBQUcrbEIsWUFBWSxDQUFDSCxVQUFTO3dCQUFDLElBQUcsQ0FBQ0UsVUFBUUEsVUFBUU4sS0FBS0UsWUFBWSxFQUFDOzRCQUFDRSxVQUFRQSxRQUFRSSxPQUFPLENBQUN2TCxJQUFJO3dCQUFBO29CQUFDO29CQUFDLElBQUcsQ0FBQ3FMLFVBQVFOLEtBQUtTLE1BQU0sRUFBQzt3QkFBQyxJQUFJamIsUUFBTTt3QkFBRSxNQUFNaEwsR0FBR2doQixNQUFNLENBQUM0RSxRQUFRcEcsSUFBSSxFQUFFOzRCQUFDLElBQUlnQixPQUFLeGdCLEdBQUd5Z0IsUUFBUSxDQUFDb0Y7NEJBQWNBLGVBQWF4SyxRQUFRcGdCLE9BQU8sQ0FBQ3FlLEtBQUtrQixPQUFPLENBQUNxTCxlQUFjckY7NEJBQU0sSUFBSVYsU0FBTzlmLEdBQUd1bEIsVUFBVSxDQUFDTSxjQUFhO2dDQUFDRixlQUFjSCxLQUFLRyxhQUFhLEdBQUM7NEJBQUM7NEJBQUdDLFVBQVE5RixPQUFPdEMsSUFBSTs0QkFBQyxJQUFHeFMsVUFBUSxJQUFHO2dDQUFDLE1BQU0sSUFBSWhMLEdBQUcwZCxVQUFVLENBQUM7NEJBQUc7d0JBQUM7b0JBQUM7Z0JBQUM7Z0JBQUMsT0FBTTtvQkFBQzNoQixNQUFLOHBCO29CQUFhckksTUFBS29JO2dCQUFPO1lBQUM7WUFBRU0sU0FBUTFJLElBQUk7Z0JBQUUsSUFBSXpoQjtnQkFBSyxNQUFNLEtBQUs7b0JBQUMsSUFBR2lFLEdBQUdtbUIsTUFBTSxDQUFDM0ksT0FBTTt3QkFBQyxJQUFJNkIsUUFBTTdCLEtBQUs2QixLQUFLLENBQUMrRyxVQUFVO3dCQUFDLElBQUcsQ0FBQ3JxQixNQUFLLE9BQU9zakI7d0JBQU0sT0FBT0EsS0FBSyxDQUFDQSxNQUFNMWYsTUFBTSxHQUFDLEVBQUUsS0FBRyxNQUFJLEdBQVk1RCxPQUFUc2pCLE9BQU0sS0FBUSxPQUFMdGpCLFFBQU9zakIsUUFBTXRqQjtvQkFBSTtvQkFBQ0EsT0FBS0EsT0FBSyxHQUFnQkEsT0FBYnloQixLQUFLcFYsSUFBSSxFQUFDLEtBQVEsT0FBTHJNLFFBQU95aEIsS0FBS3BWLElBQUk7b0JBQUNvVixPQUFLQSxLQUFLK0IsTUFBTTtnQkFBQTtZQUFDO1lBQUU4RyxVQUFTQyxRQUFRLEVBQUNsZSxJQUFJO2dCQUFFLElBQUltZSxPQUFLO2dCQUFFLElBQUksSUFBSS9mLElBQUUsR0FBRUEsSUFBRTRCLEtBQUt6SSxNQUFNLEVBQUM2RyxJQUFJO29CQUFDK2YsT0FBSyxDQUFDQSxRQUFNLEtBQUdBLE9BQUtuZSxLQUFLbUwsVUFBVSxDQUFDL00sS0FBRztnQkFBQztnQkFBQyxPQUFNLENBQUM4ZixXQUFTQyxTQUFPLEtBQUd2bUIsR0FBR21sQixTQUFTLENBQUN4bEIsTUFBTTtZQUFBO1lBQUU2bUIsYUFBWWhKLElBQUk7Z0JBQUUsSUFBSStJLE9BQUt2bUIsR0FBR3FtQixRQUFRLENBQUM3SSxLQUFLK0IsTUFBTSxDQUFDemUsRUFBRSxFQUFDMGMsS0FBS3BWLElBQUk7Z0JBQUVvVixLQUFLaUosU0FBUyxHQUFDem1CLEdBQUdtbEIsU0FBUyxDQUFDb0IsS0FBSztnQkFBQ3ZtQixHQUFHbWxCLFNBQVMsQ0FBQ29CLEtBQUssR0FBQy9JO1lBQUk7WUFBRWtKLGdCQUFlbEosSUFBSTtnQkFBRSxJQUFJK0ksT0FBS3ZtQixHQUFHcW1CLFFBQVEsQ0FBQzdJLEtBQUsrQixNQUFNLENBQUN6ZSxFQUFFLEVBQUMwYyxLQUFLcFYsSUFBSTtnQkFBRSxJQUFHcEksR0FBR21sQixTQUFTLENBQUNvQixLQUFLLEtBQUcvSSxNQUFLO29CQUFDeGQsR0FBR21sQixTQUFTLENBQUNvQixLQUFLLEdBQUMvSSxLQUFLaUosU0FBUztnQkFBQSxPQUFLO29CQUFDLElBQUliLFVBQVE1bEIsR0FBR21sQixTQUFTLENBQUNvQixLQUFLO29CQUFDLE1BQU1YLFFBQVE7d0JBQUMsSUFBR0EsUUFBUWEsU0FBUyxLQUFHakosTUFBSzs0QkFBQ29JLFFBQVFhLFNBQVMsR0FBQ2pKLEtBQUtpSixTQUFTOzRCQUFDO3dCQUFLO3dCQUFDYixVQUFRQSxRQUFRYSxTQUFTO29CQUFBO2dCQUFDO1lBQUM7WUFBRS9ELFlBQVduRCxNQUFNLEVBQUNuWCxJQUFJO2dCQUFFLElBQUl1ZSxVQUFRM21CLEdBQUc0bUIsU0FBUyxDQUFDckg7Z0JBQVEsSUFBR29ILFNBQVE7b0JBQUMsTUFBTSxJQUFJM21CLEdBQUcwZCxVQUFVLENBQUNpSixTQUFRcEg7Z0JBQU87Z0JBQUMsSUFBSWdILE9BQUt2bUIsR0FBR3FtQixRQUFRLENBQUM5RyxPQUFPemUsRUFBRSxFQUFDc0g7Z0JBQU0sSUFBSSxJQUFJb1YsT0FBS3hkLEdBQUdtbEIsU0FBUyxDQUFDb0IsS0FBSyxFQUFDL0ksTUFBS0EsT0FBS0EsS0FBS2lKLFNBQVMsQ0FBQztvQkFBQyxJQUFJSSxXQUFTckosS0FBS3BWLElBQUk7b0JBQUMsSUFBR29WLEtBQUsrQixNQUFNLENBQUN6ZSxFQUFFLEtBQUd5ZSxPQUFPemUsRUFBRSxJQUFFK2xCLGFBQVd6ZSxNQUFLO3dCQUFDLE9BQU9vVjtvQkFBSTtnQkFBQztnQkFBQyxPQUFPeGQsR0FBRzhmLE1BQU0sQ0FBQ1AsUUFBT25YO1lBQUs7WUFBRWtYLFlBQVdDLE1BQU0sRUFBQ25YLElBQUksRUFBQ29YLElBQUksRUFBQy9CLElBQUk7Z0JBQUUsSUFBSUQsT0FBSyxJQUFJeGQsR0FBRzhtQixNQUFNLENBQUN2SCxRQUFPblgsTUFBS29YLE1BQUsvQjtnQkFBTXpkLEdBQUd3bUIsV0FBVyxDQUFDaEo7Z0JBQU0sT0FBT0E7WUFBSTtZQUFFdUosYUFBWXZKLElBQUk7Z0JBQUV4ZCxHQUFHMG1CLGNBQWMsQ0FBQ2xKO1lBQUs7WUFBRTJJLFFBQU8zSSxJQUFJO2dCQUFFLE9BQU9BLFNBQU9BLEtBQUsrQixNQUFNO1lBQUE7WUFBRXdHLGNBQWF2SSxJQUFJO2dCQUFFLE9BQU0sQ0FBQyxDQUFDQSxLQUFLd0ksT0FBTztZQUFBO1lBQUVsRixRQUFPdEIsSUFBSTtnQkFBRSxPQUFNLENBQUNBLE9BQUssS0FBSSxNQUFLO1lBQUs7WUFBRW9CLE9BQU1wQixJQUFJO2dCQUFFLE9BQU0sQ0FBQ0EsT0FBSyxLQUFJLE1BQUs7WUFBSztZQUFFd0IsUUFBT3hCLElBQUk7Z0JBQUUsT0FBTSxDQUFDQSxPQUFLLEtBQUksTUFBSztZQUFLO1lBQUV5QixVQUFTekIsSUFBSTtnQkFBRSxPQUFNLENBQUNBLE9BQUssS0FBSSxNQUFLO1lBQUk7WUFBRUMsVUFBU0QsSUFBSTtnQkFBRSxPQUFNLENBQUNBLE9BQUssS0FBSSxNQUFLO1lBQUs7WUFBRUUsUUFBT0YsSUFBSTtnQkFBRSxPQUFNLENBQUNBLE9BQUssS0FBSSxNQUFLO1lBQUk7WUFBRXdILFVBQVN4SCxJQUFJO2dCQUFFLE9BQU0sQ0FBQ0EsT0FBSyxLQUFJLE1BQUs7WUFBSztZQUFFeUgseUJBQXdCQyxJQUFJO2dCQUFFLElBQUlDLFFBQU07b0JBQUM7b0JBQUk7b0JBQUk7aUJBQUssQ0FBQ0QsT0FBSyxFQUFFO2dCQUFDLElBQUdBLE9BQUssS0FBSTtvQkFBQ0MsU0FBTztnQkFBRztnQkFBQyxPQUFPQTtZQUFLO1lBQUVDLGlCQUFnQjVKLElBQUksRUFBQzJKLEtBQUs7Z0JBQUUsSUFBR25uQixHQUFHRyxpQkFBaUIsRUFBQztvQkFBQyxPQUFPO2dCQUFDO2dCQUFDLElBQUdnbkIsTUFBTW5YLFFBQVEsQ0FBQyxRQUFNLENBQUV3TixDQUFBQSxLQUFLZ0MsSUFBSSxHQUFDLEdBQUUsR0FBRztvQkFBQyxPQUFPO2dCQUFDLE9BQU0sSUFBRzJILE1BQU1uWCxRQUFRLENBQUMsUUFBTSxDQUFFd04sQ0FBQUEsS0FBS2dDLElBQUksR0FBQyxHQUFFLEdBQUc7b0JBQUMsT0FBTztnQkFBQyxPQUFNLElBQUcySCxNQUFNblgsUUFBUSxDQUFDLFFBQU0sQ0FBRXdOLENBQUFBLEtBQUtnQyxJQUFJLEdBQUMsRUFBQyxHQUFHO29CQUFDLE9BQU87Z0JBQUM7Z0JBQUMsT0FBTztZQUFDO1lBQUVvSCxXQUFVbE0sR0FBRztnQkFBRSxJQUFJaU0sVUFBUTNtQixHQUFHb25CLGVBQWUsQ0FBQzFNLEtBQUk7Z0JBQUssSUFBR2lNLFNBQVEsT0FBT0E7Z0JBQVEsSUFBRyxDQUFDak0sSUFBSWtGLFFBQVEsQ0FBQ0UsTUFBTSxFQUFDLE9BQU87Z0JBQUUsT0FBTztZQUFDO1lBQUV1SCxXQUFVM00sR0FBRyxFQUFDdFMsSUFBSTtnQkFBRSxJQUFHO29CQUFDLElBQUlvVixPQUFLeGQsR0FBRzBpQixVQUFVLENBQUNoSSxLQUFJdFM7b0JBQU0sT0FBTztnQkFBRSxFQUFDLE9BQU1oSCxHQUFFLENBQUM7Z0JBQUMsT0FBT3BCLEdBQUdvbkIsZUFBZSxDQUFDMU0sS0FBSTtZQUFLO1lBQUU0TSxXQUFVNU0sR0FBRyxFQUFDdFMsSUFBSSxFQUFDbWYsS0FBSztnQkFBRSxJQUFJL0o7Z0JBQUssSUFBRztvQkFBQ0EsT0FBS3hkLEdBQUcwaUIsVUFBVSxDQUFDaEksS0FBSXRTO2dCQUFLLEVBQUMsT0FBTWhILEdBQUU7b0JBQUMsT0FBT0EsRUFBRW9tQixLQUFLO2dCQUFBO2dCQUFDLElBQUliLFVBQVEzbUIsR0FBR29uQixlQUFlLENBQUMxTSxLQUFJO2dCQUFNLElBQUdpTSxTQUFRO29CQUFDLE9BQU9BO2dCQUFPO2dCQUFDLElBQUdZLE9BQU07b0JBQUMsSUFBRyxDQUFDdm5CLEdBQUc0Z0IsS0FBSyxDQUFDcEQsS0FBS2dDLElBQUksR0FBRTt3QkFBQyxPQUFPO29CQUFFO29CQUFDLElBQUd4ZixHQUFHbW1CLE1BQU0sQ0FBQzNJLFNBQU94ZCxHQUFHa21CLE9BQU8sQ0FBQzFJLFVBQVF4ZCxHQUFHd2IsR0FBRyxJQUFHO3dCQUFDLE9BQU87b0JBQUU7Z0JBQUMsT0FBSztvQkFBQyxJQUFHeGIsR0FBRzRnQixLQUFLLENBQUNwRCxLQUFLZ0MsSUFBSSxHQUFFO3dCQUFDLE9BQU87b0JBQUU7Z0JBQUM7Z0JBQUMsT0FBTztZQUFDO1lBQUVpSSxTQUFRakssSUFBSSxFQUFDMkYsS0FBSztnQkFBRSxJQUFHLENBQUMzRixNQUFLO29CQUFDLE9BQU87Z0JBQUU7Z0JBQUMsSUFBR3hkLEdBQUdnaEIsTUFBTSxDQUFDeEQsS0FBS2dDLElBQUksR0FBRTtvQkFBQyxPQUFPO2dCQUFFLE9BQU0sSUFBR3hmLEdBQUc0Z0IsS0FBSyxDQUFDcEQsS0FBS2dDLElBQUksR0FBRTtvQkFBQyxJQUFHeGYsR0FBR2luQix1QkFBdUIsQ0FBQzlELFdBQVMsT0FBS0EsUUFBTSxLQUFJO3dCQUFDLE9BQU87b0JBQUU7Z0JBQUM7Z0JBQUMsT0FBT25qQixHQUFHb25CLGVBQWUsQ0FBQzVKLE1BQUt4ZCxHQUFHaW5CLHVCQUF1QixDQUFDOUQ7WUFBTztZQUFFdUUsY0FBYTtZQUFLQztnQkFBUyxJQUFJLElBQUlDLEtBQUcsR0FBRUEsTUFBSTVuQixHQUFHMG5CLFlBQVksRUFBQ0UsS0FBSztvQkFBQyxJQUFHLENBQUM1bkIsR0FBR2lsQixPQUFPLENBQUMyQyxHQUFHLEVBQUM7d0JBQUMsT0FBT0E7b0JBQUU7Z0JBQUM7Z0JBQUMsTUFBTSxJQUFJNW5CLEdBQUcwZCxVQUFVLENBQUM7WUFBRztZQUFFbUssa0JBQWlCRCxFQUFFO2dCQUFFLElBQUl0SyxTQUFPdGQsR0FBRzhuQixTQUFTLENBQUNGO2dCQUFJLElBQUcsQ0FBQ3RLLFFBQU87b0JBQUMsTUFBTSxJQUFJdGQsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRTtnQkFBQyxPQUFPSjtZQUFNO1lBQUV3SyxXQUFVRixDQUFBQSxLQUFJNW5CLEdBQUdpbEIsT0FBTyxDQUFDMkMsR0FBRztZQUFDRyxjQUFhekssTUFBTTtvQkFBQ3NLLEtBQUFBLGlFQUFHLENBQUM7Z0JBQUcsSUFBRyxDQUFDNW5CLEdBQUdnb0IsUUFBUSxFQUFDO29CQUFDaG9CLEdBQUdnb0IsUUFBUSxHQUFDO3dCQUFXLElBQUksQ0FBQ0MsTUFBTSxHQUFDLENBQUM7b0JBQUM7b0JBQUVqb0IsR0FBR2dvQixRQUFRLENBQUM3ZCxTQUFTLEdBQUMsQ0FBQztvQkFBRS9PLE9BQU84c0IsZ0JBQWdCLENBQUNsb0IsR0FBR2dvQixRQUFRLENBQUM3ZCxTQUFTLEVBQUM7d0JBQUNnZSxRQUFPOzRCQUFDL2Q7Z0NBQU0sT0FBTyxJQUFJLENBQUNvVCxJQUFJOzRCQUFBOzRCQUFFZ0UsS0FBSWpELEdBQUc7Z0NBQUUsSUFBSSxDQUFDZixJQUFJLEdBQUNlOzRCQUFHO3dCQUFDO3dCQUFFNkosUUFBTzs0QkFBQ2hlO2dDQUFNLE9BQU0sQ0FBQyxJQUFJLENBQUMrWSxLQUFLLEdBQUMsT0FBTSxNQUFLOzRCQUFDO3dCQUFDO3dCQUFFa0YsU0FBUTs0QkFBQ2plO2dDQUFNLE9BQU0sQ0FBQyxJQUFJLENBQUMrWSxLQUFLLEdBQUMsT0FBTSxNQUFLOzRCQUFDO3dCQUFDO3dCQUFFbUYsVUFBUzs0QkFBQ2xlO2dDQUFNLE9BQU8sSUFBSSxDQUFDK1ksS0FBSyxHQUFDOzRCQUFJO3dCQUFDO3dCQUFFQSxPQUFNOzRCQUFDL1k7Z0NBQU0sT0FBTyxJQUFJLENBQUM2ZCxNQUFNLENBQUM5RSxLQUFLOzRCQUFBOzRCQUFFM0IsS0FBSWpELEdBQUc7Z0NBQUUsSUFBSSxDQUFDMEosTUFBTSxDQUFDOUUsS0FBSyxHQUFDNUU7NEJBQUc7d0JBQUM7d0JBQUV3RSxVQUFTOzRCQUFDM1k7Z0NBQU0sT0FBTyxJQUFJLENBQUM2ZCxNQUFNLENBQUNsRixRQUFROzRCQUFBOzRCQUFFdkIsS0FBSWpELEdBQUc7Z0NBQUUsSUFBSSxDQUFDMEosTUFBTSxDQUFDbEYsUUFBUSxHQUFDeEU7NEJBQUc7d0JBQUM7b0JBQUM7Z0JBQUU7Z0JBQUNqQixTQUFPbGlCLE9BQU9DLE1BQU0sQ0FBQyxJQUFJMkUsR0FBR2dvQixRQUFRLEVBQUMxSztnQkFBUSxJQUFHc0ssTUFBSSxDQUFDLEdBQUU7b0JBQUNBLEtBQUc1bkIsR0FBRzJuQixNQUFNO2dCQUFFO2dCQUFDckssT0FBT3NLLEVBQUUsR0FBQ0E7Z0JBQUc1bkIsR0FBR2lsQixPQUFPLENBQUMyQyxHQUFHLEdBQUN0SztnQkFBTyxPQUFPQTtZQUFNO1lBQUVpTCxhQUFZWCxFQUFFO2dCQUFFNW5CLEdBQUdpbEIsT0FBTyxDQUFDMkMsR0FBRyxHQUFDO1lBQUk7WUFBRWpILG1CQUFrQjtnQkFBQzlqQixNQUFLeWdCLE1BQU07b0JBQUUsSUFBSWtMLFNBQU94b0IsR0FBR3lvQixTQUFTLENBQUNuTCxPQUFPRSxJQUFJLENBQUNDLElBQUk7b0JBQUVILE9BQU9ELFVBQVUsR0FBQ21MLE9BQU9uTCxVQUFVO29CQUFDLElBQUdDLE9BQU9ELFVBQVUsQ0FBQ3hnQixJQUFJLEVBQUM7d0JBQUN5Z0IsT0FBT0QsVUFBVSxDQUFDeGdCLElBQUksQ0FBQ3lnQjtvQkFBTztnQkFBQztnQkFBRStDO29CQUFTLE1BQU0sSUFBSXJnQixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO1lBQUM7WUFBRWdMLE9BQU0xTCxDQUFBQSxNQUFLQSxPQUFLO1lBQUUyTCxPQUFNM0wsQ0FBQUEsTUFBS0EsTUFBSTtZQUFJNEwsU0FBUSxDQUFDQyxJQUFHQyxLQUFLRCxNQUFJLElBQUVDO1lBQUcxTCxnQkFBZUosR0FBRyxFQUFDQyxHQUFHO2dCQUFFamQsR0FBR2dsQixPQUFPLENBQUNoSSxJQUFJLEdBQUM7b0JBQUNLLFlBQVdKO2dCQUFHO1lBQUM7WUFBRXdMLFdBQVV6TCxDQUFBQSxNQUFLaGQsR0FBR2dsQixPQUFPLENBQUNoSSxJQUFJO1lBQUMrTCxXQUFVMUosS0FBSztnQkFBRSxJQUFJMEYsU0FBTyxFQUFFO2dCQUFDLElBQUlpRSxRQUFNO29CQUFDM0o7aUJBQU07Z0JBQUMsTUFBTTJKLE1BQU1ycEIsTUFBTSxDQUFDO29CQUFDLElBQUlzcEIsSUFBRUQsTUFBTTFqQixHQUFHO29CQUFHeWYsT0FBT2hlLElBQUksQ0FBQ2tpQjtvQkFBR0QsTUFBTWppQixJQUFJLENBQUMrRSxLQUFLLENBQUNrZCxPQUFNQyxFQUFFbEUsTUFBTTtnQkFBQztnQkFBQyxPQUFPQTtZQUFNO1lBQUVtRSxRQUFPQyxRQUFRLEVBQUNqb0IsUUFBUTtnQkFBRSxJQUFHLE9BQU9pb0IsWUFBVSxZQUFXO29CQUFDam9CLFdBQVNpb0I7b0JBQVNBLFdBQVM7Z0JBQUs7Z0JBQUNucEIsR0FBR3NsQixjQUFjO2dCQUFHLElBQUd0bEIsR0FBR3NsQixjQUFjLEdBQUMsR0FBRTtvQkFBQzduQixJQUFJLFlBQThCLE9BQWxCdUMsR0FBR3NsQixjQUFjLEVBQUM7Z0JBQXlFO2dCQUFDLElBQUlQLFNBQU8va0IsR0FBRytvQixTQUFTLENBQUMvb0IsR0FBR3lhLElBQUksQ0FBQzRFLEtBQUs7Z0JBQUUsSUFBSStKLFlBQVU7Z0JBQUUsU0FBU0MsV0FBVzFDLE9BQU87b0JBQUUzbUIsR0FBR3NsQixjQUFjO29CQUFHLE9BQU9wa0IsU0FBU3lsQjtnQkFBUTtnQkFBQyxTQUFTMkMsS0FBSzNDLE9BQU87b0JBQUUsSUFBR0EsU0FBUTt3QkFBQyxJQUFHLENBQUMyQyxLQUFLQyxPQUFPLEVBQUM7NEJBQUNELEtBQUtDLE9BQU8sR0FBQzs0QkFBSyxPQUFPRixXQUFXMUM7d0JBQVE7d0JBQUM7b0JBQU07b0JBQUMsSUFBRyxFQUFFeUMsYUFBV3JFLE9BQU9wbEIsTUFBTSxFQUFDO3dCQUFDMHBCLFdBQVc7b0JBQUs7Z0JBQUM7Z0JBQUN0RSxPQUFPM2UsT0FBTyxDQUFDaVosQ0FBQUE7b0JBQVEsSUFBRyxDQUFDQSxNQUFNdmIsSUFBSSxDQUFDb2xCLE1BQU0sRUFBQzt3QkFBQyxPQUFPSSxLQUFLO29CQUFLO29CQUFDakssTUFBTXZiLElBQUksQ0FBQ29sQixNQUFNLENBQUM3SixPQUFNOEosVUFBU0c7Z0JBQUs7WUFBRTtZQUFFakssT0FBTXZiLElBQUksRUFBQzBoQixJQUFJLEVBQUNZLFVBQVU7Z0JBQUUsSUFBSTNMLE9BQUsyTCxlQUFhO2dCQUFJLElBQUlvRCxTQUFPLENBQUNwRDtnQkFBVyxJQUFJNUk7Z0JBQUssSUFBRy9DLFFBQU16YSxHQUFHeWEsSUFBSSxFQUFDO29CQUFDLE1BQU0sSUFBSXphLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUcsT0FBTSxJQUFHLENBQUNqRCxRQUFNLENBQUMrTyxRQUFPO29CQUFDLElBQUkxSixTQUFPOWYsR0FBR3VsQixVQUFVLENBQUNhLFlBQVc7d0JBQUNWLGNBQWE7b0JBQUs7b0JBQUdVLGFBQVd0RyxPQUFPL2pCLElBQUk7b0JBQUN5aEIsT0FBS3NDLE9BQU90QyxJQUFJO29CQUFDLElBQUd4ZCxHQUFHK2xCLFlBQVksQ0FBQ3ZJLE9BQU07d0JBQUMsTUFBTSxJQUFJeGQsR0FBRzBkLFVBQVUsQ0FBQztvQkFBRztvQkFBQyxJQUFHLENBQUMxZCxHQUFHNGdCLEtBQUssQ0FBQ3BELEtBQUtnQyxJQUFJLEdBQUU7d0JBQUMsTUFBTSxJQUFJeGYsR0FBRzBkLFVBQVUsQ0FBQztvQkFBRztnQkFBQztnQkFBQyxJQUFJMkIsUUFBTTtvQkFBQ3ZiLE1BQUtBO29CQUFLMGhCLE1BQUtBO29CQUFLWSxZQUFXQTtvQkFBV3JCLFFBQU8sRUFBRTtnQkFBQTtnQkFBRSxJQUFJMEUsWUFBVTNsQixLQUFLdWIsS0FBSyxDQUFDQTtnQkFBT29LLFVBQVVwSyxLQUFLLEdBQUNBO2dCQUFNQSxNQUFNNUUsSUFBSSxHQUFDZ1A7Z0JBQVUsSUFBR2hQLE1BQUs7b0JBQUN6YSxHQUFHeWEsSUFBSSxHQUFDZ1A7Z0JBQVMsT0FBTSxJQUFHak0sTUFBSztvQkFBQ0EsS0FBS3dJLE9BQU8sR0FBQzNHO29CQUFNLElBQUc3QixLQUFLNkIsS0FBSyxFQUFDO3dCQUFDN0IsS0FBSzZCLEtBQUssQ0FBQzBGLE1BQU0sQ0FBQ2hlLElBQUksQ0FBQ3NZO29CQUFNO2dCQUFDO2dCQUFDLE9BQU9vSztZQUFTO1lBQUVDLFNBQVF0RCxVQUFVO2dCQUFFLElBQUl0RyxTQUFPOWYsR0FBR3VsQixVQUFVLENBQUNhLFlBQVc7b0JBQUNWLGNBQWE7Z0JBQUs7Z0JBQUcsSUFBRyxDQUFDMWxCLEdBQUcrbEIsWUFBWSxDQUFDakcsT0FBT3RDLElBQUksR0FBRTtvQkFBQyxNQUFNLElBQUl4ZCxHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLElBQUlGLE9BQUtzQyxPQUFPdEMsSUFBSTtnQkFBQyxJQUFJNkIsUUFBTTdCLEtBQUt3SSxPQUFPO2dCQUFDLElBQUlqQixTQUFPL2tCLEdBQUcrb0IsU0FBUyxDQUFDMUo7Z0JBQU9qa0IsT0FBT3V1QixJQUFJLENBQUMzcEIsR0FBR21sQixTQUFTLEVBQUUvZSxPQUFPLENBQUNtZ0IsQ0FBQUE7b0JBQU8sSUFBSVgsVUFBUTVsQixHQUFHbWxCLFNBQVMsQ0FBQ29CLEtBQUs7b0JBQUMsTUFBTVgsUUFBUTt3QkFBQyxJQUFJZ0UsT0FBS2hFLFFBQVFhLFNBQVM7d0JBQUMsSUFBRzFCLE9BQU8vVSxRQUFRLENBQUM0VixRQUFRdkcsS0FBSyxHQUFFOzRCQUFDcmYsR0FBRyttQixXQUFXLENBQUNuQjt3QkFBUTt3QkFBQ0EsVUFBUWdFO29CQUFJO2dCQUFDO2dCQUFHcE0sS0FBS3dJLE9BQU8sR0FBQztnQkFBSyxJQUFJL1IsTUFBSXVKLEtBQUs2QixLQUFLLENBQUMwRixNQUFNLENBQUN6b0IsT0FBTyxDQUFDK2lCO2dCQUFPN0IsS0FBSzZCLEtBQUssQ0FBQzBGLE1BQU0sQ0FBQzlLLE1BQU0sQ0FBQ2hHLEtBQUk7WUFBRTtZQUFFNkwsUUFBT1AsTUFBTSxFQUFDblgsSUFBSTtnQkFBRSxPQUFPbVgsT0FBT0ssUUFBUSxDQUFDRSxNQUFNLENBQUNQLFFBQU9uWDtZQUFLO1lBQUUyWCxPQUFNaGtCLElBQUksRUFBQ3lqQixJQUFJLEVBQUN4QyxHQUFHO2dCQUFFLElBQUk4QyxTQUFPOWYsR0FBR3VsQixVQUFVLENBQUN4cEIsTUFBSztvQkFBQ3dqQixRQUFPO2dCQUFJO2dCQUFHLElBQUlBLFNBQU9PLE9BQU90QyxJQUFJO2dCQUFDLElBQUlwVixPQUFLa1IsS0FBS3FCLFFBQVEsQ0FBQzVlO2dCQUFNLElBQUcsQ0FBQ3FNLFFBQU1BLFNBQU8sT0FBS0EsU0FBTyxNQUFLO29CQUFDLE1BQU0sSUFBSXBJLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBSWlKLFVBQVEzbUIsR0FBR3FuQixTQUFTLENBQUM5SCxRQUFPblg7Z0JBQU0sSUFBR3VlLFNBQVE7b0JBQUMsTUFBTSxJQUFJM21CLEdBQUcwZCxVQUFVLENBQUNpSjtnQkFBUTtnQkFBQyxJQUFHLENBQUNwSCxPQUFPSyxRQUFRLENBQUNHLEtBQUssRUFBQztvQkFBQyxNQUFNLElBQUkvZixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLE9BQU82QixPQUFPSyxRQUFRLENBQUNHLEtBQUssQ0FBQ1IsUUFBT25YLE1BQUtvWCxNQUFLeEM7WUFBSTtZQUFFeFAsUUFBT3pSLElBQUksRUFBQ3lqQixJQUFJO2dCQUFFQSxPQUFLQSxTQUFPNWtCLFlBQVU0a0IsT0FBSztnQkFBSUEsUUFBTTtnQkFBS0EsUUFBTTtnQkFBTSxPQUFPeGYsR0FBRytmLEtBQUssQ0FBQ2hrQixNQUFLeWpCLE1BQUs7WUFBRTtZQUFFcUssT0FBTTl0QixJQUFJLEVBQUN5akIsSUFBSTtnQkFBRUEsT0FBS0EsU0FBTzVrQixZQUFVNGtCLE9BQUs7Z0JBQUlBLFFBQU0sTUFBSTtnQkFBSUEsUUFBTTtnQkFBTSxPQUFPeGYsR0FBRytmLEtBQUssQ0FBQ2hrQixNQUFLeWpCLE1BQUs7WUFBRTtZQUFFc0ssV0FBVS90QixJQUFJLEVBQUN5akIsSUFBSTtnQkFBRSxJQUFJdUssT0FBS2h1QixLQUFLc2UsS0FBSyxDQUFDO2dCQUFLLElBQUkyUCxJQUFFO2dCQUFHLElBQUksSUFBSXhqQixJQUFFLEdBQUVBLElBQUV1akIsS0FBS3BxQixNQUFNLEVBQUMsRUFBRTZHLEVBQUU7b0JBQUMsSUFBRyxDQUFDdWpCLElBQUksQ0FBQ3ZqQixFQUFFLEVBQUM7b0JBQVN3akIsS0FBRyxNQUFJRCxJQUFJLENBQUN2akIsRUFBRTtvQkFBQyxJQUFHO3dCQUFDeEcsR0FBRzZwQixLQUFLLENBQUNHLEdBQUV4SztvQkFBSyxFQUFDLE9BQU1wZSxHQUFFO3dCQUFDLElBQUdBLEVBQUVvbUIsS0FBSyxJQUFFLElBQUcsTUFBTXBtQjtvQkFBQztnQkFBQztZQUFDO1lBQUU2b0IsT0FBTWx1QixJQUFJLEVBQUN5akIsSUFBSSxFQUFDeEMsR0FBRztnQkFBRSxJQUFHLE9BQU9BLE9BQUssYUFBWTtvQkFBQ0EsTUFBSXdDO29CQUFLQSxPQUFLO2dCQUFHO2dCQUFDQSxRQUFNO2dCQUFLLE9BQU94ZixHQUFHK2YsS0FBSyxDQUFDaGtCLE1BQUt5akIsTUFBS3hDO1lBQUk7WUFBRW9ELFNBQVEwQyxPQUFPLEVBQUNvSCxPQUFPO2dCQUFFLElBQUcsQ0FBQzdPLFFBQVFwZ0IsT0FBTyxDQUFDNm5CLFVBQVM7b0JBQUMsTUFBTSxJQUFJOWlCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBSW9DLFNBQU85ZixHQUFHdWxCLFVBQVUsQ0FBQzJFLFNBQVE7b0JBQUMzSyxRQUFPO2dCQUFJO2dCQUFHLElBQUlBLFNBQU9PLE9BQU90QyxJQUFJO2dCQUFDLElBQUcsQ0FBQytCLFFBQU87b0JBQUMsTUFBTSxJQUFJdmYsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFJbUYsVUFBUXZKLEtBQUtxQixRQUFRLENBQUN1UDtnQkFBUyxJQUFJdkQsVUFBUTNtQixHQUFHcW5CLFNBQVMsQ0FBQzlILFFBQU9zRDtnQkFBUyxJQUFHOEQsU0FBUTtvQkFBQyxNQUFNLElBQUkzbUIsR0FBRzBkLFVBQVUsQ0FBQ2lKO2dCQUFRO2dCQUFDLElBQUcsQ0FBQ3BILE9BQU9LLFFBQVEsQ0FBQ1EsT0FBTyxFQUFDO29CQUFDLE1BQU0sSUFBSXBnQixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLE9BQU82QixPQUFPSyxRQUFRLENBQUNRLE9BQU8sQ0FBQ2IsUUFBT3NELFNBQVFDO1lBQVE7WUFBRTlDLFFBQU9tSyxRQUFRLEVBQUNDLFFBQVE7Z0JBQUUsSUFBSUMsY0FBWS9RLEtBQUtrQixPQUFPLENBQUMyUDtnQkFBVSxJQUFJRyxjQUFZaFIsS0FBS2tCLE9BQU8sQ0FBQzRQO2dCQUFVLElBQUlHLFdBQVNqUixLQUFLcUIsUUFBUSxDQUFDd1A7Z0JBQVUsSUFBSTNILFdBQVNsSixLQUFLcUIsUUFBUSxDQUFDeVA7Z0JBQVUsSUFBSXRLLFFBQU8wSyxTQUFRakk7Z0JBQVF6QyxTQUFPOWYsR0FBR3VsQixVQUFVLENBQUM0RSxVQUFTO29CQUFDNUssUUFBTztnQkFBSTtnQkFBR2lMLFVBQVExSyxPQUFPdEMsSUFBSTtnQkFBQ3NDLFNBQU85ZixHQUFHdWxCLFVBQVUsQ0FBQzZFLFVBQVM7b0JBQUM3SyxRQUFPO2dCQUFJO2dCQUFHZ0QsVUFBUXpDLE9BQU90QyxJQUFJO2dCQUFDLElBQUcsQ0FBQ2dOLFdBQVMsQ0FBQ2pJLFNBQVEsTUFBTSxJQUFJdmlCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUksSUFBRzhNLFFBQVFuTCxLQUFLLEtBQUdrRCxRQUFRbEQsS0FBSyxFQUFDO29CQUFDLE1BQU0sSUFBSXJmLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBSTRFLFdBQVN0aUIsR0FBRzBpQixVQUFVLENBQUM4SCxTQUFRRDtnQkFBVSxJQUFJOU8sV0FBU0osUUFBUUksUUFBUSxDQUFDME8sVUFBU0c7Z0JBQWEsSUFBRzdPLFNBQVNqQyxNQUFNLENBQUMsT0FBSyxLQUFJO29CQUFDLE1BQU0sSUFBSXhaLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUNqQyxXQUFTSixRQUFRSSxRQUFRLENBQUMyTyxVQUFTQztnQkFBYSxJQUFHNU8sU0FBU2pDLE1BQU0sQ0FBQyxPQUFLLEtBQUk7b0JBQUMsTUFBTSxJQUFJeFosR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFJK0U7Z0JBQVMsSUFBRztvQkFBQ0EsV0FBU3ppQixHQUFHMGlCLFVBQVUsQ0FBQ0gsU0FBUUM7Z0JBQVMsRUFBQyxPQUFNcGhCLEdBQUUsQ0FBQztnQkFBQyxJQUFHa2hCLGFBQVdHLFVBQVM7b0JBQUM7Z0JBQU07Z0JBQUMsSUFBSThFLFFBQU12bkIsR0FBRzRnQixLQUFLLENBQUMwQixTQUFTOUMsSUFBSTtnQkFBRSxJQUFJbUgsVUFBUTNtQixHQUFHc25CLFNBQVMsQ0FBQ2tELFNBQVFELFVBQVNoRDtnQkFBTyxJQUFHWixTQUFRO29CQUFDLE1BQU0sSUFBSTNtQixHQUFHMGQsVUFBVSxDQUFDaUo7Z0JBQVE7Z0JBQUNBLFVBQVFsRSxXQUFTemlCLEdBQUdzbkIsU0FBUyxDQUFDL0UsU0FBUUMsVUFBUytFLFNBQU92bkIsR0FBR3FuQixTQUFTLENBQUM5RSxTQUFRQztnQkFBVSxJQUFHbUUsU0FBUTtvQkFBQyxNQUFNLElBQUkzbUIsR0FBRzBkLFVBQVUsQ0FBQ2lKO2dCQUFRO2dCQUFDLElBQUcsQ0FBQzZELFFBQVE1SyxRQUFRLENBQUNJLE1BQU0sRUFBQztvQkFBQyxNQUFNLElBQUloZ0IsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHMWQsR0FBRytsQixZQUFZLENBQUN6RCxhQUFXRyxZQUFVemlCLEdBQUcrbEIsWUFBWSxDQUFDdEQsV0FBVTtvQkFBQyxNQUFNLElBQUl6aUIsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHNkUsWUFBVWlJLFNBQVE7b0JBQUM3RCxVQUFRM21CLEdBQUdvbkIsZUFBZSxDQUFDb0QsU0FBUTtvQkFBSyxJQUFHN0QsU0FBUTt3QkFBQyxNQUFNLElBQUkzbUIsR0FBRzBkLFVBQVUsQ0FBQ2lKO29CQUFRO2dCQUFDO2dCQUFDM21CLEdBQUcwbUIsY0FBYyxDQUFDcEU7Z0JBQVUsSUFBRztvQkFBQ2tJLFFBQVE1SyxRQUFRLENBQUNJLE1BQU0sQ0FBQ3NDLFVBQVNDLFNBQVFDO2dCQUFTLEVBQUMsT0FBTXBoQixHQUFFO29CQUFDLE1BQU1BO2dCQUFDLFNBQVE7b0JBQUNwQixHQUFHd21CLFdBQVcsQ0FBQ2xFO2dCQUFTO1lBQUM7WUFBRXBDLE9BQU1ua0IsSUFBSTtnQkFBRSxJQUFJK2pCLFNBQU85ZixHQUFHdWxCLFVBQVUsQ0FBQ3hwQixNQUFLO29CQUFDd2pCLFFBQU87Z0JBQUk7Z0JBQUcsSUFBSUEsU0FBT08sT0FBT3RDLElBQUk7Z0JBQUMsSUFBSXBWLE9BQUtrUixLQUFLcUIsUUFBUSxDQUFDNWU7Z0JBQU0sSUFBSXloQixPQUFLeGQsR0FBRzBpQixVQUFVLENBQUNuRCxRQUFPblg7Z0JBQU0sSUFBSXVlLFVBQVEzbUIsR0FBR3NuQixTQUFTLENBQUMvSCxRQUFPblgsTUFBSztnQkFBTSxJQUFHdWUsU0FBUTtvQkFBQyxNQUFNLElBQUkzbUIsR0FBRzBkLFVBQVUsQ0FBQ2lKO2dCQUFRO2dCQUFDLElBQUcsQ0FBQ3BILE9BQU9LLFFBQVEsQ0FBQ00sS0FBSyxFQUFDO29CQUFDLE1BQU0sSUFBSWxnQixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLElBQUcxZCxHQUFHK2xCLFlBQVksQ0FBQ3ZJLE9BQU07b0JBQUMsTUFBTSxJQUFJeGQsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQzZCLE9BQU9LLFFBQVEsQ0FBQ00sS0FBSyxDQUFDWCxRQUFPblg7Z0JBQU1wSSxHQUFHK21CLFdBQVcsQ0FBQ3ZKO1lBQUs7WUFBRTJDLFNBQVFwa0IsSUFBSTtnQkFBRSxJQUFJK2pCLFNBQU85ZixHQUFHdWxCLFVBQVUsQ0FBQ3hwQixNQUFLO29CQUFDa3FCLFFBQU87Z0JBQUk7Z0JBQUcsSUFBSXpJLE9BQUtzQyxPQUFPdEMsSUFBSTtnQkFBQyxJQUFHLENBQUNBLEtBQUtvQyxRQUFRLENBQUNPLE9BQU8sRUFBQztvQkFBQyxNQUFNLElBQUluZ0IsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxPQUFPRixLQUFLb0MsUUFBUSxDQUFDTyxPQUFPLENBQUMzQztZQUFLO1lBQUV5QyxRQUFPbGtCLElBQUk7Z0JBQUUsSUFBSStqQixTQUFPOWYsR0FBR3VsQixVQUFVLENBQUN4cEIsTUFBSztvQkFBQ3dqQixRQUFPO2dCQUFJO2dCQUFHLElBQUlBLFNBQU9PLE9BQU90QyxJQUFJO2dCQUFDLElBQUcsQ0FBQytCLFFBQU87b0JBQUMsTUFBTSxJQUFJdmYsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFJdFYsT0FBS2tSLEtBQUtxQixRQUFRLENBQUM1ZTtnQkFBTSxJQUFJeWhCLE9BQUt4ZCxHQUFHMGlCLFVBQVUsQ0FBQ25ELFFBQU9uWDtnQkFBTSxJQUFJdWUsVUFBUTNtQixHQUFHc25CLFNBQVMsQ0FBQy9ILFFBQU9uWCxNQUFLO2dCQUFPLElBQUd1ZSxTQUFRO29CQUFDLE1BQU0sSUFBSTNtQixHQUFHMGQsVUFBVSxDQUFDaUo7Z0JBQVE7Z0JBQUMsSUFBRyxDQUFDcEgsT0FBT0ssUUFBUSxDQUFDSyxNQUFNLEVBQUM7b0JBQUMsTUFBTSxJQUFJamdCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBRzFkLEdBQUcrbEIsWUFBWSxDQUFDdkksT0FBTTtvQkFBQyxNQUFNLElBQUl4ZCxHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDNkIsT0FBT0ssUUFBUSxDQUFDSyxNQUFNLENBQUNWLFFBQU9uWDtnQkFBTXBJLEdBQUcrbUIsV0FBVyxDQUFDdko7WUFBSztZQUFFaUQsVUFBUzFrQixJQUFJO2dCQUFFLElBQUkrakIsU0FBTzlmLEdBQUd1bEIsVUFBVSxDQUFDeHBCO2dCQUFNLElBQUl5a0IsT0FBS1YsT0FBT3RDLElBQUk7Z0JBQUMsSUFBRyxDQUFDZ0QsTUFBSztvQkFBQyxNQUFNLElBQUl4Z0IsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHLENBQUM4QyxLQUFLWixRQUFRLENBQUNhLFFBQVEsRUFBQztvQkFBQyxNQUFNLElBQUl6Z0IsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxPQUFPckMsUUFBUXBnQixPQUFPLENBQUMrRSxHQUFHa21CLE9BQU8sQ0FBQzFGLEtBQUtqQixNQUFNLEdBQUVpQixLQUFLWixRQUFRLENBQUNhLFFBQVEsQ0FBQ0Q7WUFBTTtZQUFFaUssTUFBSzF1QixJQUFJLEVBQUMydUIsVUFBVTtnQkFBRSxJQUFJNUssU0FBTzlmLEdBQUd1bEIsVUFBVSxDQUFDeHBCLE1BQUs7b0JBQUNrcUIsUUFBTyxDQUFDeUU7Z0JBQVU7Z0JBQUcsSUFBSWxOLE9BQUtzQyxPQUFPdEMsSUFBSTtnQkFBQyxJQUFHLENBQUNBLE1BQUs7b0JBQUMsTUFBTSxJQUFJeGQsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHLENBQUNGLEtBQUtvQyxRQUFRLENBQUNELE9BQU8sRUFBQztvQkFBQyxNQUFNLElBQUkzZixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLE9BQU9GLEtBQUtvQyxRQUFRLENBQUNELE9BQU8sQ0FBQ25DO1lBQUs7WUFBRW1OLE9BQU01dUIsSUFBSTtnQkFBRSxPQUFPaUUsR0FBR3lxQixJQUFJLENBQUMxdUIsTUFBSztZQUFLO1lBQUU2dUIsT0FBTTd1QixJQUFJLEVBQUN5akIsSUFBSSxFQUFDa0wsVUFBVTtnQkFBRSxJQUFJbE47Z0JBQUssSUFBRyxPQUFPemhCLFFBQU0sVUFBUztvQkFBQyxJQUFJK2pCLFNBQU85ZixHQUFHdWxCLFVBQVUsQ0FBQ3hwQixNQUFLO3dCQUFDa3FCLFFBQU8sQ0FBQ3lFO29CQUFVO29CQUFHbE4sT0FBS3NDLE9BQU90QyxJQUFJO2dCQUFBLE9BQUs7b0JBQUNBLE9BQUt6aEI7Z0JBQUk7Z0JBQUMsSUFBRyxDQUFDeWhCLEtBQUtvQyxRQUFRLENBQUNDLE9BQU8sRUFBQztvQkFBQyxNQUFNLElBQUk3ZixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDRixLQUFLb0MsUUFBUSxDQUFDQyxPQUFPLENBQUNyQyxNQUFLO29CQUFDZ0MsTUFBS0EsT0FBSyxPQUFLaEMsS0FBS2dDLElBQUksR0FBQyxDQUFDO29CQUFLdEIsV0FBVUMsS0FBS0MsR0FBRztnQkFBRTtZQUFFO1lBQUV5TSxRQUFPOXVCLElBQUksRUFBQ3lqQixJQUFJO2dCQUFFeGYsR0FBRzRxQixLQUFLLENBQUM3dUIsTUFBS3lqQixNQUFLO1lBQUs7WUFBRXNMLFFBQU9sRCxFQUFFLEVBQUNwSSxJQUFJO2dCQUFFLElBQUlsQyxTQUFPdGQsR0FBRzZuQixnQkFBZ0IsQ0FBQ0Q7Z0JBQUk1bkIsR0FBRzRxQixLQUFLLENBQUN0TixPQUFPRSxJQUFJLEVBQUNnQztZQUFLO1lBQUV1TCxPQUFNaHZCLElBQUksRUFBQzhsQixHQUFHLEVBQUNDLEdBQUcsRUFBQzRJLFVBQVU7Z0JBQUUsSUFBSWxOO2dCQUFLLElBQUcsT0FBT3poQixRQUFNLFVBQVM7b0JBQUMsSUFBSStqQixTQUFPOWYsR0FBR3VsQixVQUFVLENBQUN4cEIsTUFBSzt3QkFBQ2txQixRQUFPLENBQUN5RTtvQkFBVTtvQkFBR2xOLE9BQUtzQyxPQUFPdEMsSUFBSTtnQkFBQSxPQUFLO29CQUFDQSxPQUFLemhCO2dCQUFJO2dCQUFDLElBQUcsQ0FBQ3loQixLQUFLb0MsUUFBUSxDQUFDQyxPQUFPLEVBQUM7b0JBQUMsTUFBTSxJQUFJN2YsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQ0YsS0FBS29DLFFBQVEsQ0FBQ0MsT0FBTyxDQUFDckMsTUFBSztvQkFBQ1UsV0FBVUMsS0FBS0MsR0FBRztnQkFBRTtZQUFFO1lBQUU0TSxRQUFPanZCLElBQUksRUFBQzhsQixHQUFHLEVBQUNDLEdBQUc7Z0JBQUU5aEIsR0FBRytxQixLQUFLLENBQUNodkIsTUFBSzhsQixLQUFJQyxLQUFJO1lBQUs7WUFBRW1KLFFBQU9yRCxFQUFFLEVBQUMvRixHQUFHLEVBQUNDLEdBQUc7Z0JBQUUsSUFBSXhFLFNBQU90ZCxHQUFHNm5CLGdCQUFnQixDQUFDRDtnQkFBSTVuQixHQUFHK3FCLEtBQUssQ0FBQ3pOLE9BQU9FLElBQUksRUFBQ3FFLEtBQUlDO1lBQUk7WUFBRW9KLFVBQVNudkIsSUFBSSxFQUFDNlgsR0FBRztnQkFBRSxJQUFHQSxNQUFJLEdBQUU7b0JBQUMsTUFBTSxJQUFJNVQsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFJRjtnQkFBSyxJQUFHLE9BQU96aEIsUUFBTSxVQUFTO29CQUFDLElBQUkrakIsU0FBTzlmLEdBQUd1bEIsVUFBVSxDQUFDeHBCLE1BQUs7d0JBQUNrcUIsUUFBTztvQkFBSTtvQkFBR3pJLE9BQUtzQyxPQUFPdEMsSUFBSTtnQkFBQSxPQUFLO29CQUFDQSxPQUFLemhCO2dCQUFJO2dCQUFDLElBQUcsQ0FBQ3loQixLQUFLb0MsUUFBUSxDQUFDQyxPQUFPLEVBQUM7b0JBQUMsTUFBTSxJQUFJN2YsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHMWQsR0FBRzRnQixLQUFLLENBQUNwRCxLQUFLZ0MsSUFBSSxHQUFFO29CQUFDLE1BQU0sSUFBSXhmLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBRyxDQUFDMWQsR0FBRzhnQixNQUFNLENBQUN0RCxLQUFLZ0MsSUFBSSxHQUFFO29CQUFDLE1BQU0sSUFBSXhmLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBSWlKLFVBQVEzbUIsR0FBR29uQixlQUFlLENBQUM1SixNQUFLO2dCQUFLLElBQUdtSixTQUFRO29CQUFDLE1BQU0sSUFBSTNtQixHQUFHMGQsVUFBVSxDQUFDaUo7Z0JBQVE7Z0JBQUNuSixLQUFLb0MsUUFBUSxDQUFDQyxPQUFPLENBQUNyQyxNQUFLO29CQUFDN1UsTUFBS2lMO29CQUFJc0ssV0FBVUMsS0FBS0MsR0FBRztnQkFBRTtZQUFFO1lBQUUrTSxXQUFVdkQsRUFBRSxFQUFDaFUsR0FBRztnQkFBRSxJQUFJMEosU0FBT3RkLEdBQUc2bkIsZ0JBQWdCLENBQUNEO2dCQUFJLElBQUcsQ0FBQ3RLLE9BQU82RixLQUFLLEdBQUMsT0FBTSxNQUFLLEdBQUU7b0JBQUMsTUFBTSxJQUFJbmpCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMxZCxHQUFHa3JCLFFBQVEsQ0FBQzVOLE9BQU9FLElBQUksRUFBQzVKO1lBQUk7WUFBRXdYLE9BQU1ydkIsSUFBSSxFQUFDZ21CLEtBQUssRUFBQ0MsS0FBSztnQkFBRSxJQUFJbEMsU0FBTzlmLEdBQUd1bEIsVUFBVSxDQUFDeHBCLE1BQUs7b0JBQUNrcUIsUUFBTztnQkFBSTtnQkFBRyxJQUFJekksT0FBS3NDLE9BQU90QyxJQUFJO2dCQUFDQSxLQUFLb0MsUUFBUSxDQUFDQyxPQUFPLENBQUNyQyxNQUFLO29CQUFDVSxXQUFVMUYsS0FBS0csR0FBRyxDQUFDb0osT0FBTUM7Z0JBQU07WUFBRTtZQUFFbmxCLE1BQUtkLElBQUksRUFBQ29uQixLQUFLLEVBQUMzRCxJQUFJO2dCQUFFLElBQUd6akIsU0FBTyxJQUFHO29CQUFDLE1BQU0sSUFBSWlFLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUN5RixRQUFNLE9BQU9BLFNBQU8sV0FBU3lCLHFCQUFxQnpCLFNBQU9BO2dCQUFNM0QsT0FBSyxPQUFPQSxRQUFNLGNBQVksTUFBSUE7Z0JBQUssSUFBRzJELFFBQU0sSUFBRztvQkFBQzNELE9BQUtBLE9BQUssT0FBSztnQkFBSyxPQUFLO29CQUFDQSxPQUFLO2dCQUFDO2dCQUFDLElBQUloQztnQkFBSyxJQUFHLE9BQU96aEIsUUFBTSxVQUFTO29CQUFDeWhCLE9BQUt6aEI7Z0JBQUksT0FBSztvQkFBQ0EsT0FBS3VkLEtBQUtZLFNBQVMsQ0FBQ25lO29CQUFNLElBQUc7d0JBQUMsSUFBSStqQixTQUFPOWYsR0FBR3VsQixVQUFVLENBQUN4cEIsTUFBSzs0QkFBQ2txQixRQUFPLENBQUU5QyxDQUFBQSxRQUFNLE1BQUs7d0JBQUU7d0JBQUczRixPQUFLc0MsT0FBT3RDLElBQUk7b0JBQUEsRUFBQyxPQUFNcGMsR0FBRSxDQUFDO2dCQUFDO2dCQUFDLElBQUlpcUIsVUFBUTtnQkFBTSxJQUFHbEksUUFBTSxJQUFHO29CQUFDLElBQUczRixNQUFLO3dCQUFDLElBQUcyRixRQUFNLEtBQUk7NEJBQUMsTUFBTSxJQUFJbmpCLEdBQUcwZCxVQUFVLENBQUM7d0JBQUc7b0JBQUMsT0FBSzt3QkFBQ0YsT0FBS3hkLEdBQUcrZixLQUFLLENBQUNoa0IsTUFBS3lqQixNQUFLO3dCQUFHNkwsVUFBUTtvQkFBSTtnQkFBQztnQkFBQyxJQUFHLENBQUM3TixNQUFLO29CQUFDLE1BQU0sSUFBSXhkLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBRzFkLEdBQUdpaEIsUUFBUSxDQUFDekQsS0FBS2dDLElBQUksR0FBRTtvQkFBQzJELFNBQU8sQ0FBQztnQkFBRztnQkFBQyxJQUFHQSxRQUFNLFNBQU8sQ0FBQ25qQixHQUFHNGdCLEtBQUssQ0FBQ3BELEtBQUtnQyxJQUFJLEdBQUU7b0JBQUMsTUFBTSxJQUFJeGYsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHLENBQUMyTixTQUFRO29CQUFDLElBQUkxRSxVQUFRM21CLEdBQUd5bkIsT0FBTyxDQUFDakssTUFBSzJGO29CQUFPLElBQUd3RCxTQUFRO3dCQUFDLE1BQU0sSUFBSTNtQixHQUFHMGQsVUFBVSxDQUFDaUo7b0JBQVE7Z0JBQUM7Z0JBQUMsSUFBR3hELFFBQU0sT0FBSyxDQUFDa0ksU0FBUTtvQkFBQ3JyQixHQUFHa3JCLFFBQVEsQ0FBQzFOLE1BQUs7Z0JBQUU7Z0JBQUMyRixTQUFPLENBQUUsT0FBSSxNQUFJLE1BQUs7Z0JBQUcsSUFBSTdGLFNBQU90ZCxHQUFHK25CLFlBQVksQ0FBQztvQkFBQ3ZLLE1BQUtBO29CQUFLemhCLE1BQUtpRSxHQUFHa21CLE9BQU8sQ0FBQzFJO29CQUFNMkYsT0FBTUE7b0JBQU14RixVQUFTO29CQUFLb0YsVUFBUztvQkFBRTFGLFlBQVdHLEtBQUtILFVBQVU7b0JBQUNpTyxVQUFTLEVBQUU7b0JBQUM1dEIsT0FBTTtnQkFBSztnQkFBRyxJQUFHNGYsT0FBT0QsVUFBVSxDQUFDeGdCLElBQUksRUFBQztvQkFBQ3lnQixPQUFPRCxVQUFVLENBQUN4Z0IsSUFBSSxDQUFDeWdCO2dCQUFPO2dCQUFDLElBQUcvaUIsTUFBTSxDQUFDLGVBQWUsSUFBRSxDQUFFNG9CLENBQUFBLFFBQU0sSUFBRztvQkFBQyxJQUFHLENBQUNuakIsR0FBR3VyQixTQUFTLEVBQUN2ckIsR0FBR3VyQixTQUFTLEdBQUMsQ0FBQztvQkFBRSxJQUFHLENBQUV4dkIsQ0FBQUEsUUFBUWlFLEdBQUd1ckIsU0FBUyxHQUFFO3dCQUFDdnJCLEdBQUd1ckIsU0FBUyxDQUFDeHZCLEtBQUssR0FBQztvQkFBQztnQkFBQztnQkFBQyxPQUFPdWhCO1lBQU07WUFBRU0sT0FBTU4sTUFBTTtnQkFBRSxJQUFHdGQsR0FBR3dyQixRQUFRLENBQUNsTyxTQUFRO29CQUFDLE1BQU0sSUFBSXRkLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUU7Z0JBQUMsSUFBR0osT0FBT21PLFFBQVEsRUFBQ25PLE9BQU9tTyxRQUFRLEdBQUM7Z0JBQUssSUFBRztvQkFBQyxJQUFHbk8sT0FBT0QsVUFBVSxDQUFDTyxLQUFLLEVBQUM7d0JBQUNOLE9BQU9ELFVBQVUsQ0FBQ08sS0FBSyxDQUFDTjtvQkFBTztnQkFBQyxFQUFDLE9BQU1sYyxHQUFFO29CQUFDLE1BQU1BO2dCQUFDLFNBQVE7b0JBQUNwQixHQUFHdW9CLFdBQVcsQ0FBQ2pMLE9BQU9zSyxFQUFFO2dCQUFDO2dCQUFDdEssT0FBT3NLLEVBQUUsR0FBQztZQUFJO1lBQUU0RCxVQUFTbE8sTUFBTTtnQkFBRSxPQUFPQSxPQUFPc0ssRUFBRSxLQUFHO1lBQUk7WUFBRXZILFFBQU8vQyxNQUFNLEVBQUNRLE1BQU0sRUFBQ21GLE1BQU07Z0JBQUUsSUFBR2pqQixHQUFHd3JCLFFBQVEsQ0FBQ2xPLFNBQVE7b0JBQUMsTUFBTSxJQUFJdGQsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRTtnQkFBQyxJQUFHLENBQUNKLE9BQU9LLFFBQVEsSUFBRSxDQUFDTCxPQUFPRCxVQUFVLENBQUNnRCxNQUFNLEVBQUM7b0JBQUMsTUFBTSxJQUFJcmdCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBR3VGLFVBQVEsS0FBR0EsVUFBUSxLQUFHQSxVQUFRLEdBQUU7b0JBQUMsTUFBTSxJQUFJampCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUNKLE9BQU95RixRQUFRLEdBQUN6RixPQUFPRCxVQUFVLENBQUNnRCxNQUFNLENBQUMvQyxRQUFPUSxRQUFPbUY7Z0JBQVEzRixPQUFPZ08sUUFBUSxHQUFDLEVBQUU7Z0JBQUMsT0FBT2hPLE9BQU95RixRQUFRO1lBQUE7WUFBRTlhLE1BQUtxVixNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUNvakIsUUFBUTtnQkFBRSxJQUFHcGpCLFNBQU8sS0FBR29qQixXQUFTLEdBQUU7b0JBQUMsTUFBTSxJQUFJL2lCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBRzFkLEdBQUd3ckIsUUFBUSxDQUFDbE8sU0FBUTtvQkFBQyxNQUFNLElBQUl0ZCxHQUFHMGQsVUFBVSxDQUFDO2dCQUFFO2dCQUFDLElBQUcsQ0FBQ0osT0FBTzZGLEtBQUssR0FBQyxPQUFNLE1BQUssR0FBRTtvQkFBQyxNQUFNLElBQUluakIsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRTtnQkFBQyxJQUFHMWQsR0FBRzRnQixLQUFLLENBQUN0RCxPQUFPRSxJQUFJLENBQUNnQyxJQUFJLEdBQUU7b0JBQUMsTUFBTSxJQUFJeGYsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHLENBQUNKLE9BQU9ELFVBQVUsQ0FBQ3BWLElBQUksRUFBQztvQkFBQyxNQUFNLElBQUlqSSxHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLElBQUlnTyxVQUFRLE9BQU8zSSxZQUFVO2dCQUFZLElBQUcsQ0FBQzJJLFNBQVE7b0JBQUMzSSxXQUFTekYsT0FBT3lGLFFBQVE7Z0JBQUEsT0FBTSxJQUFHLENBQUN6RixPQUFPSyxRQUFRLEVBQUM7b0JBQUMsTUFBTSxJQUFJM2QsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFJTyxZQUFVWCxPQUFPRCxVQUFVLENBQUNwVixJQUFJLENBQUNxVixRQUFPeGUsUUFBT2dmLFFBQU9uZSxRQUFPb2pCO2dCQUFVLElBQUcsQ0FBQzJJLFNBQVFwTyxPQUFPeUYsUUFBUSxJQUFFOUU7Z0JBQVUsT0FBT0E7WUFBUztZQUFFL1YsT0FBTW9WLE1BQU0sRUFBQ3hlLE1BQU0sRUFBQ2dmLE1BQU0sRUFBQ25lLE1BQU0sRUFBQ29qQixRQUFRLEVBQUNDLE1BQU07Z0JBQUUsSUFBR3JqQixTQUFPLEtBQUdvakIsV0FBUyxHQUFFO29CQUFDLE1BQU0sSUFBSS9pQixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLElBQUcxZCxHQUFHd3JCLFFBQVEsQ0FBQ2xPLFNBQVE7b0JBQUMsTUFBTSxJQUFJdGQsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRTtnQkFBQyxJQUFHLENBQUNKLE9BQU82RixLQUFLLEdBQUMsT0FBTSxNQUFLLEdBQUU7b0JBQUMsTUFBTSxJQUFJbmpCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUU7Z0JBQUMsSUFBRzFkLEdBQUc0Z0IsS0FBSyxDQUFDdEQsT0FBT0UsSUFBSSxDQUFDZ0MsSUFBSSxHQUFFO29CQUFDLE1BQU0sSUFBSXhmLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBRyxDQUFDSixPQUFPRCxVQUFVLENBQUNuVixLQUFLLEVBQUM7b0JBQUMsTUFBTSxJQUFJbEksR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHSixPQUFPSyxRQUFRLElBQUVMLE9BQU82RixLQUFLLEdBQUMsTUFBSztvQkFBQ25qQixHQUFHcWdCLE1BQU0sQ0FBQy9DLFFBQU8sR0FBRTtnQkFBRTtnQkFBQyxJQUFJb08sVUFBUSxPQUFPM0ksWUFBVTtnQkFBWSxJQUFHLENBQUMySSxTQUFRO29CQUFDM0ksV0FBU3pGLE9BQU95RixRQUFRO2dCQUFBLE9BQU0sSUFBRyxDQUFDekYsT0FBT0ssUUFBUSxFQUFDO29CQUFDLE1BQU0sSUFBSTNkLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBSWlPLGVBQWFyTyxPQUFPRCxVQUFVLENBQUNuVixLQUFLLENBQUNvVixRQUFPeGUsUUFBT2dmLFFBQU9uZSxRQUFPb2pCLFVBQVNDO2dCQUFRLElBQUcsQ0FBQzBJLFNBQVFwTyxPQUFPeUYsUUFBUSxJQUFFNEk7Z0JBQWEsT0FBT0E7WUFBWTtZQUFFcGhCLFVBQVMrUyxNQUFNLEVBQUNRLE1BQU0sRUFBQ25lLE1BQU07Z0JBQUUsSUFBR0ssR0FBR3dyQixRQUFRLENBQUNsTyxTQUFRO29CQUFDLE1BQU0sSUFBSXRkLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUU7Z0JBQUMsSUFBR0ksU0FBTyxLQUFHbmUsVUFBUSxHQUFFO29CQUFDLE1BQU0sSUFBSUssR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHLENBQUNKLE9BQU82RixLQUFLLEdBQUMsT0FBTSxNQUFLLEdBQUU7b0JBQUMsTUFBTSxJQUFJbmpCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDMWQsR0FBRzhnQixNQUFNLENBQUN4RCxPQUFPRSxJQUFJLENBQUNnQyxJQUFJLEtBQUcsQ0FBQ3hmLEdBQUc0Z0IsS0FBSyxDQUFDdEQsT0FBT0UsSUFBSSxDQUFDZ0MsSUFBSSxHQUFFO29CQUFDLE1BQU0sSUFBSXhmLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsSUFBRyxDQUFDSixPQUFPRCxVQUFVLENBQUM5UyxRQUFRLEVBQUM7b0JBQUMsTUFBTSxJQUFJdkssR0FBRzBkLFVBQVUsQ0FBQztnQkFBSTtnQkFBQ0osT0FBT0QsVUFBVSxDQUFDOVMsUUFBUSxDQUFDK1MsUUFBT1EsUUFBT25lO1lBQU87WUFBRTJnQixNQUFLaEQsTUFBTSxFQUFDM2QsTUFBTSxFQUFDb2pCLFFBQVEsRUFBQ0csSUFBSSxFQUFDQyxLQUFLO2dCQUFFLElBQUcsQ0FBQ0QsT0FBSyxPQUFLLEtBQUcsQ0FBQ0MsUUFBTSxPQUFLLEtBQUcsQ0FBQzdGLE9BQU82RixLQUFLLEdBQUMsT0FBTSxNQUFLLEdBQUU7b0JBQUMsTUFBTSxJQUFJbmpCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUU7Z0JBQUMsSUFBRyxDQUFDSixPQUFPNkYsS0FBSyxHQUFDLE9BQU0sTUFBSyxHQUFFO29CQUFDLE1BQU0sSUFBSW5qQixHQUFHMGQsVUFBVSxDQUFDO2dCQUFFO2dCQUFDLElBQUcsQ0FBQ0osT0FBT0QsVUFBVSxDQUFDaUQsSUFBSSxFQUFDO29CQUFDLE1BQU0sSUFBSXRnQixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLE9BQU9KLE9BQU9ELFVBQVUsQ0FBQ2lELElBQUksQ0FBQ2hELFFBQU8zZCxRQUFPb2pCLFVBQVNHLE1BQUtDO1lBQU07WUFBRTVDLE9BQU1qRCxNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUMwakIsU0FBUztnQkFBRSxJQUFHLENBQUMvRixPQUFPRCxVQUFVLENBQUNrRCxLQUFLLEVBQUM7b0JBQUMsT0FBTztnQkFBQztnQkFBQyxPQUFPakQsT0FBT0QsVUFBVSxDQUFDa0QsS0FBSyxDQUFDakQsUUFBT3hlLFFBQU9nZixRQUFPbmUsUUFBTzBqQjtZQUFVO1lBQUV1SSxRQUFPdE8sQ0FBQUEsU0FBUTtZQUFFdU8sT0FBTXZPLE1BQU0sRUFBQ3dPLEdBQUcsRUFBQ0MsR0FBRztnQkFBRSxJQUFHLENBQUN6TyxPQUFPRCxVQUFVLENBQUN3TyxLQUFLLEVBQUM7b0JBQUMsTUFBTSxJQUFJN3JCLEdBQUcwZCxVQUFVLENBQUM7Z0JBQUc7Z0JBQUMsT0FBT0osT0FBT0QsVUFBVSxDQUFDd08sS0FBSyxDQUFDdk8sUUFBT3dPLEtBQUlDO1lBQUk7WUFBRUMsVUFBU2p3QixJQUFJO29CQUFDeXBCLE9BQUFBLGlFQUFLLENBQUM7Z0JBQUdBLEtBQUtyQyxLQUFLLEdBQUNxQyxLQUFLckMsS0FBSyxJQUFFO2dCQUFFcUMsS0FBS3lHLFFBQVEsR0FBQ3pHLEtBQUt5RyxRQUFRLElBQUU7Z0JBQVMsSUFBR3pHLEtBQUt5RyxRQUFRLEtBQUcsVUFBUXpHLEtBQUt5RyxRQUFRLEtBQUcsVUFBUztvQkFBQyxNQUFNLElBQUluYixNQUFNLDBCQUF3QyxPQUFkMFUsS0FBS3lHLFFBQVEsRUFBQztnQkFBRztnQkFBQyxJQUFJN2lCO2dCQUFJLElBQUlrVSxTQUFPdGQsR0FBR25ELElBQUksQ0FBQ2QsTUFBS3lwQixLQUFLckMsS0FBSztnQkFBRSxJQUFJc0gsT0FBS3pxQixHQUFHeXFCLElBQUksQ0FBQzF1QjtnQkFBTSxJQUFJNEQsU0FBTzhxQixLQUFLOWhCLElBQUk7Z0JBQUMsSUFBSXVqQixNQUFJLElBQUlqdkIsV0FBVzBDO2dCQUFRSyxHQUFHaUksSUFBSSxDQUFDcVYsUUFBTzRPLEtBQUksR0FBRXZzQixRQUFPO2dCQUFHLElBQUc2bEIsS0FBS3lHLFFBQVEsS0FBRyxRQUFPO29CQUFDN2lCLE1BQUkySyxrQkFBa0JtWSxLQUFJO2dCQUFFLE9BQU0sSUFBRzFHLEtBQUt5RyxRQUFRLEtBQUcsVUFBUztvQkFBQzdpQixNQUFJOGlCO2dCQUFHO2dCQUFDbHNCLEdBQUc0ZCxLQUFLLENBQUNOO2dCQUFRLE9BQU9sVTtZQUFHO1lBQUUraUIsV0FBVXB3QixJQUFJLEVBQUM4VyxJQUFJO29CQUFDMlMsT0FBQUEsaUVBQUssQ0FBQztnQkFBR0EsS0FBS3JDLEtBQUssR0FBQ3FDLEtBQUtyQyxLQUFLLElBQUU7Z0JBQUksSUFBSTdGLFNBQU90ZCxHQUFHbkQsSUFBSSxDQUFDZCxNQUFLeXBCLEtBQUtyQyxLQUFLLEVBQUNxQyxLQUFLaEcsSUFBSTtnQkFBRSxJQUFHLE9BQU8zTSxRQUFNLFVBQVM7b0JBQUMsSUFBSXFaLE1BQUksSUFBSWp2QixXQUFXMFcsZ0JBQWdCZCxRQUFNO29CQUFHLElBQUl1WixpQkFBZXJaLGtCQUFrQkYsTUFBS3FaLEtBQUksR0FBRUEsSUFBSXZzQixNQUFNO29CQUFFSyxHQUFHa0ksS0FBSyxDQUFDb1YsUUFBTzRPLEtBQUksR0FBRUUsZ0JBQWV4eEIsV0FBVTRxQixLQUFLeEMsTUFBTTtnQkFBQyxPQUFNLElBQUc5TixZQUFZbVgsTUFBTSxDQUFDeFosT0FBTTtvQkFBQzdTLEdBQUdrSSxLQUFLLENBQUNvVixRQUFPekssTUFBSyxHQUFFQSxLQUFLZ0YsVUFBVSxFQUFDamQsV0FBVTRxQixLQUFLeEMsTUFBTTtnQkFBQyxPQUFLO29CQUFDLE1BQU0sSUFBSWxTLE1BQU07Z0JBQXdCO2dCQUFDOVEsR0FBRzRkLEtBQUssQ0FBQ047WUFBTztZQUFFOUIsS0FBSSxJQUFJeGIsR0FBR29sQixXQUFXO1lBQUNrSCxPQUFNdndCLElBQUk7Z0JBQUUsSUFBSStqQixTQUFPOWYsR0FBR3VsQixVQUFVLENBQUN4cEIsTUFBSztvQkFBQ2txQixRQUFPO2dCQUFJO2dCQUFHLElBQUduRyxPQUFPdEMsSUFBSSxLQUFHLE1BQUs7b0JBQUMsTUFBTSxJQUFJeGQsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHLENBQUMxZCxHQUFHNGdCLEtBQUssQ0FBQ2QsT0FBT3RDLElBQUksQ0FBQ2dDLElBQUksR0FBRTtvQkFBQyxNQUFNLElBQUl4ZixHQUFHMGQsVUFBVSxDQUFDO2dCQUFHO2dCQUFDLElBQUlpSixVQUFRM21CLEdBQUdvbkIsZUFBZSxDQUFDdEgsT0FBT3RDLElBQUksRUFBQztnQkFBSyxJQUFHbUosU0FBUTtvQkFBQyxNQUFNLElBQUkzbUIsR0FBRzBkLFVBQVUsQ0FBQ2lKO2dCQUFRO2dCQUFDM21CLEdBQUdvbEIsV0FBVyxHQUFDdEYsT0FBTy9qQixJQUFJO1lBQUE7WUFBRXd3QjtnQkFBMkJ2c0IsR0FBRzZwQixLQUFLLENBQUM7Z0JBQVE3cEIsR0FBRzZwQixLQUFLLENBQUM7Z0JBQVM3cEIsR0FBRzZwQixLQUFLLENBQUM7WUFBaUI7WUFBRTJDO2dCQUF1QnhzQixHQUFHNnBCLEtBQUssQ0FBQztnQkFBUTdwQixHQUFHb2QsY0FBYyxDQUFDcGQsR0FBRzRvQixPQUFPLENBQUMsR0FBRSxJQUFHO29CQUFDM2dCLE1BQUssSUFBSTtvQkFBRUMsT0FBTSxDQUFDb1YsUUFBT3hlLFFBQU9nZixRQUFPbmUsUUFBT29lLE1BQU1wZTtnQkFBTTtnQkFBR0ssR0FBR2lxQixLQUFLLENBQUMsYUFBWWpxQixHQUFHNG9CLE9BQU8sQ0FBQyxHQUFFO2dCQUFJeG9CLElBQUkyYyxRQUFRLENBQUMvYyxHQUFHNG9CLE9BQU8sQ0FBQyxHQUFFLElBQUd4b0IsSUFBSWtlLGVBQWU7Z0JBQUVsZSxJQUFJMmMsUUFBUSxDQUFDL2MsR0FBRzRvQixPQUFPLENBQUMsR0FBRSxJQUFHeG9CLElBQUk2ZSxnQkFBZ0I7Z0JBQUVqZixHQUFHaXFCLEtBQUssQ0FBQyxZQUFXanFCLEdBQUc0b0IsT0FBTyxDQUFDLEdBQUU7Z0JBQUk1b0IsR0FBR2lxQixLQUFLLENBQUMsYUFBWWpxQixHQUFHNG9CLE9BQU8sQ0FBQyxHQUFFO2dCQUFJLElBQUk2RCxlQUFhLElBQUl4dkIsV0FBVyxPQUFNeXZCLGFBQVc7Z0JBQUUsSUFBSUMsYUFBVztvQkFBSyxJQUFHRCxlQUFhLEdBQUU7d0JBQUNBLGFBQVd0UixXQUFXcVIsY0FBYzVVLFVBQVU7b0JBQUE7b0JBQUMsT0FBTzRVLFlBQVksQ0FBQyxFQUFFQyxXQUFXO2dCQUFBO2dCQUFFMXNCLEdBQUc0c0IsWUFBWSxDQUFDLFFBQU8sVUFBU0Q7Z0JBQVkzc0IsR0FBRzRzQixZQUFZLENBQUMsUUFBTyxXQUFVRDtnQkFBWTNzQixHQUFHNnBCLEtBQUssQ0FBQztnQkFBWTdwQixHQUFHNnBCLEtBQUssQ0FBQztZQUFlO1lBQUVnRDtnQkFBMkI3c0IsR0FBRzZwQixLQUFLLENBQUM7Z0JBQVMsSUFBSWlELFlBQVU5c0IsR0FBRzZwQixLQUFLLENBQUM7Z0JBQWM3cEIsR0FBRzZwQixLQUFLLENBQUM7Z0JBQWlCN3BCLEdBQUdxZixLQUFLLENBQUM7b0JBQUNBO3dCQUFRLElBQUk3QixPQUFLeGQsR0FBR3NmLFVBQVUsQ0FBQ3dOLFdBQVUsTUFBSyxRQUFNLEtBQUk7d0JBQUl0UCxLQUFLb0MsUUFBUSxHQUFDOzRCQUFDRSxRQUFPUCxNQUFNLEVBQUNuWCxJQUFJO2dDQUFFLElBQUl3ZixLQUFHLENBQUN4ZjtnQ0FBSyxJQUFJa1YsU0FBT3RkLEdBQUc2bkIsZ0JBQWdCLENBQUNEO2dDQUFJLElBQUl4ZSxNQUFJO29DQUFDbVcsUUFBTztvQ0FBS0YsT0FBTTt3Q0FBQytHLFlBQVc7b0NBQU07b0NBQUV4RyxVQUFTO3dDQUFDYSxVQUFTLElBQUluRCxPQUFPdmhCLElBQUk7b0NBQUE7Z0NBQUM7Z0NBQUVxTixJQUFJbVcsTUFBTSxHQUFDblc7Z0NBQUksT0FBT0E7NEJBQUc7d0JBQUM7d0JBQUUsT0FBT29VO29CQUFJO2dCQUFDLEdBQUUsQ0FBQyxHQUFFO1lBQWdCO1lBQUV1UDtnQkFBd0IsSUFBR3h5QixNQUFNLENBQUMsUUFBUSxFQUFDO29CQUFDeUYsR0FBRzRzQixZQUFZLENBQUMsUUFBTyxTQUFRcnlCLE1BQU0sQ0FBQyxRQUFRO2dCQUFDLE9BQUs7b0JBQUN5RixHQUFHb2dCLE9BQU8sQ0FBQyxZQUFXO2dCQUFhO2dCQUFDLElBQUc3bEIsTUFBTSxDQUFDLFNBQVMsRUFBQztvQkFBQ3lGLEdBQUc0c0IsWUFBWSxDQUFDLFFBQU8sVUFBUyxNQUFLcnlCLE1BQU0sQ0FBQyxTQUFTO2dCQUFDLE9BQUs7b0JBQUN5RixHQUFHb2dCLE9BQU8sQ0FBQyxZQUFXO2dCQUFjO2dCQUFDLElBQUc3bEIsTUFBTSxDQUFDLFNBQVMsRUFBQztvQkFBQ3lGLEdBQUc0c0IsWUFBWSxDQUFDLFFBQU8sVUFBUyxNQUFLcnlCLE1BQU0sQ0FBQyxTQUFTO2dCQUFDLE9BQUs7b0JBQUN5RixHQUFHb2dCLE9BQU8sQ0FBQyxhQUFZO2dCQUFjO2dCQUFDLElBQUk0TSxRQUFNaHRCLEdBQUduRCxJQUFJLENBQUMsY0FBYTtnQkFBRyxJQUFJb3dCLFNBQU9qdEIsR0FBR25ELElBQUksQ0FBQyxlQUFjO2dCQUFHLElBQUlxd0IsU0FBT2x0QixHQUFHbkQsSUFBSSxDQUFDLGVBQWM7WUFBRTtZQUFFc3dCO2dCQUFtQixJQUFHbnRCLEdBQUcwZCxVQUFVLEVBQUM7Z0JBQU8xZCxHQUFHMGQsVUFBVSxHQUFDLFNBQVNBLFdBQVc4SixLQUFLLEVBQUNoSyxJQUFJO29CQUFFLElBQUksQ0FBQ3BWLElBQUksR0FBQztvQkFBYSxJQUFJLENBQUNvVixJQUFJLEdBQUNBO29CQUFLLElBQUksQ0FBQzRQLFFBQVEsR0FBQyxTQUFTNUYsS0FBSzt3QkFBRSxJQUFJLENBQUNBLEtBQUssR0FBQ0E7b0JBQUs7b0JBQUUsSUFBSSxDQUFDNEYsUUFBUSxDQUFDNUY7b0JBQU8sSUFBSSxDQUFDemhCLE9BQU8sR0FBQztnQkFBVTtnQkFBRS9GLEdBQUcwZCxVQUFVLENBQUN2VCxTQUFTLEdBQUMsSUFBSTJHO2dCQUFNOVEsR0FBRzBkLFVBQVUsQ0FBQ3ZULFNBQVMsQ0FBQ3NDLFdBQVcsR0FBQ3pNLEdBQUcwZCxVQUFVO2dCQUFDO29CQUFDO2lCQUFHLENBQUN0WCxPQUFPLENBQUNpbkIsQ0FBQUE7b0JBQU9ydEIsR0FBR3FpQixhQUFhLENBQUNnTCxLQUFLLEdBQUMsSUFBSXJ0QixHQUFHMGQsVUFBVSxDQUFDMlA7b0JBQU1ydEIsR0FBR3FpQixhQUFhLENBQUNnTCxLQUFLLENBQUN4YyxLQUFLLEdBQUM7Z0JBQTJCO1lBQUU7WUFBRXljO2dCQUFhdHRCLEdBQUdtdEIsZ0JBQWdCO2dCQUFHbnRCLEdBQUdtbEIsU0FBUyxHQUFDLElBQUl6ZSxNQUFNO2dCQUFNMUcsR0FBR3FmLEtBQUssQ0FBQ0YsT0FBTSxDQUFDLEdBQUU7Z0JBQUtuZixHQUFHdXNCLHdCQUF3QjtnQkFBR3ZzQixHQUFHd3NCLG9CQUFvQjtnQkFBR3hzQixHQUFHNnNCLHdCQUF3QjtnQkFBRzdzQixHQUFHcWxCLFdBQVcsR0FBQztvQkFBQyxTQUFRbEc7Z0JBQUs7WUFBQztZQUFFbGYsTUFBS2lkLEtBQUssRUFBQ0MsTUFBTSxFQUFDemYsS0FBSztnQkFBRXNDLEdBQUdDLElBQUksQ0FBQ0MsV0FBVyxHQUFDO2dCQUFLRixHQUFHbXRCLGdCQUFnQjtnQkFBRzV5QixNQUFNLENBQUMsUUFBUSxHQUFDMmlCLFNBQU8zaUIsTUFBTSxDQUFDLFFBQVE7Z0JBQUNBLE1BQU0sQ0FBQyxTQUFTLEdBQUM0aUIsVUFBUTVpQixNQUFNLENBQUMsU0FBUztnQkFBQ0EsTUFBTSxDQUFDLFNBQVMsR0FBQ21ELFNBQU9uRCxNQUFNLENBQUMsU0FBUztnQkFBQ3lGLEdBQUcrc0IscUJBQXFCO1lBQUU7WUFBRVE7Z0JBQU92dEIsR0FBR0MsSUFBSSxDQUFDQyxXQUFXLEdBQUM7Z0JBQU0sSUFBSSxJQUFJc0csSUFBRSxHQUFFQSxJQUFFeEcsR0FBR2lsQixPQUFPLENBQUN0bEIsTUFBTSxFQUFDNkcsSUFBSTtvQkFBQyxJQUFJOFcsU0FBT3RkLEdBQUdpbEIsT0FBTyxDQUFDemUsRUFBRTtvQkFBQyxJQUFHLENBQUM4VyxRQUFPO3dCQUFDO29CQUFRO29CQUFDdGQsR0FBRzRkLEtBQUssQ0FBQ047Z0JBQU87WUFBQztZQUFFa1EsWUFBV3p4QixJQUFJLEVBQUMweEIsbUJBQW1CO2dCQUFFLElBQUlya0IsTUFBSXBKLEdBQUcwdEIsV0FBVyxDQUFDM3hCLE1BQUsweEI7Z0JBQXFCLElBQUcsQ0FBQ3JrQixJQUFJdWtCLE1BQU0sRUFBQztvQkFBQyxPQUFPO2dCQUFJO2dCQUFDLE9BQU92a0IsSUFBSStlLE1BQU07WUFBQTtZQUFFdUYsYUFBWTN4QixJQUFJLEVBQUMweEIsbUJBQW1CO2dCQUFFLElBQUc7b0JBQUMsSUFBSTNOLFNBQU85ZixHQUFHdWxCLFVBQVUsQ0FBQ3hwQixNQUFLO3dCQUFDa3FCLFFBQU8sQ0FBQ3dIO29CQUFtQjtvQkFBRzF4QixPQUFLK2pCLE9BQU8vakIsSUFBSTtnQkFBQSxFQUFDLE9BQU1xRixHQUFFLENBQUM7Z0JBQUMsSUFBSWdJLE1BQUk7b0JBQUMrYyxRQUFPO29CQUFNd0gsUUFBTztvQkFBTWp3QixPQUFNO29CQUFFMEssTUFBSztvQkFBS3JNLE1BQUs7b0JBQUtvc0IsUUFBTztvQkFBS3lGLGNBQWE7b0JBQU1DLFlBQVc7b0JBQUtDLGNBQWE7Z0JBQUk7Z0JBQUUsSUFBRztvQkFBQyxJQUFJaE8sU0FBTzlmLEdBQUd1bEIsVUFBVSxDQUFDeHBCLE1BQUs7d0JBQUN3akIsUUFBTztvQkFBSTtvQkFBR25XLElBQUl3a0IsWUFBWSxHQUFDO29CQUFLeGtCLElBQUl5a0IsVUFBVSxHQUFDL04sT0FBTy9qQixJQUFJO29CQUFDcU4sSUFBSTBrQixZQUFZLEdBQUNoTyxPQUFPdEMsSUFBSTtvQkFBQ3BVLElBQUloQixJQUFJLEdBQUNrUixLQUFLcUIsUUFBUSxDQUFDNWU7b0JBQU0rakIsU0FBTzlmLEdBQUd1bEIsVUFBVSxDQUFDeHBCLE1BQUs7d0JBQUNrcUIsUUFBTyxDQUFDd0g7b0JBQW1CO29CQUFHcmtCLElBQUl1a0IsTUFBTSxHQUFDO29CQUFLdmtCLElBQUlyTixJQUFJLEdBQUMrakIsT0FBTy9qQixJQUFJO29CQUFDcU4sSUFBSStlLE1BQU0sR0FBQ3JJLE9BQU90QyxJQUFJO29CQUFDcFUsSUFBSWhCLElBQUksR0FBQzBYLE9BQU90QyxJQUFJLENBQUNwVixJQUFJO29CQUFDZ0IsSUFBSStjLE1BQU0sR0FBQ3JHLE9BQU8vakIsSUFBSSxLQUFHO2dCQUFHLEVBQUMsT0FBTXFGLEdBQUU7b0JBQUNnSSxJQUFJMUwsS0FBSyxHQUFDMEQsRUFBRW9tQixLQUFLO2dCQUFBO2dCQUFDLE9BQU9wZTtZQUFHO1lBQUUya0IsWUFBV3hPLE1BQU0sRUFBQ3hqQixJQUFJLEVBQUM4bkIsT0FBTyxFQUFDQyxRQUFRO2dCQUFFdkUsU0FBTyxPQUFPQSxVQUFRLFdBQVNBLFNBQU92ZixHQUFHa21CLE9BQU8sQ0FBQzNHO2dCQUFRLElBQUkxRixRQUFNOWQsS0FBS3NlLEtBQUssQ0FBQyxLQUFLMlQsT0FBTztnQkFBRyxNQUFNblUsTUFBTWxhLE1BQU0sQ0FBQztvQkFBQyxJQUFJc3VCLE9BQUtwVSxNQUFNdlUsR0FBRztvQkFBRyxJQUFHLENBQUMyb0IsTUFBSztvQkFBUyxJQUFJckksVUFBUXRNLEtBQUt3QixLQUFLLENBQUN5RSxRQUFPME87b0JBQU0sSUFBRzt3QkFBQ2p1QixHQUFHNnBCLEtBQUssQ0FBQ2pFO29CQUFRLEVBQUMsT0FBTXhrQixHQUFFLENBQUM7b0JBQUNtZSxTQUFPcUc7Z0JBQU87Z0JBQUMsT0FBT0E7WUFBTztZQUFFc0ksWUFBVzNPLE1BQU0sRUFBQ25YLElBQUksRUFBQytsQixVQUFVLEVBQUN0SyxPQUFPLEVBQUNDLFFBQVE7Z0JBQUUsSUFBSS9uQixPQUFLdWQsS0FBS3dCLEtBQUssQ0FBQyxPQUFPeUUsVUFBUSxXQUFTQSxTQUFPdmYsR0FBR2ttQixPQUFPLENBQUMzRyxTQUFRblg7Z0JBQU0sSUFBSW9YLE9BQUtzRixXQUFXakIsU0FBUUM7Z0JBQVUsT0FBTzlqQixHQUFHd04sTUFBTSxDQUFDelIsTUFBS3lqQjtZQUFLO1lBQUV1RSxnQkFBZXhFLE1BQU0sRUFBQ25YLElBQUksRUFBQ3lLLElBQUksRUFBQ2dSLE9BQU8sRUFBQ0MsUUFBUSxFQUFDZCxNQUFNO2dCQUFFLElBQUlqbkIsT0FBS3FNO2dCQUFLLElBQUdtWCxRQUFPO29CQUFDQSxTQUFPLE9BQU9BLFVBQVEsV0FBU0EsU0FBT3ZmLEdBQUdrbUIsT0FBTyxDQUFDM0c7b0JBQVF4akIsT0FBS3FNLE9BQUtrUixLQUFLd0IsS0FBSyxDQUFDeUUsUUFBT25YLFFBQU1tWDtnQkFBTTtnQkFBQyxJQUFJQyxPQUFLc0YsV0FBV2pCLFNBQVFDO2dCQUFVLElBQUl0RyxPQUFLeGQsR0FBR3dOLE1BQU0sQ0FBQ3pSLE1BQUt5akI7Z0JBQU0sSUFBRzNNLE1BQUs7b0JBQUMsSUFBRyxPQUFPQSxRQUFNLFVBQVM7d0JBQUMsSUFBSStJLE1BQUksSUFBSWxWLE1BQU1tTSxLQUFLbFQsTUFBTTt3QkFBRSxJQUFJLElBQUk2RyxJQUFFLEdBQUVvTixNQUFJZixLQUFLbFQsTUFBTSxFQUFDNkcsSUFBRW9OLEtBQUksRUFBRXBOLEVBQUVvVixHQUFHLENBQUNwVixFQUFFLEdBQUNxTSxLQUFLVSxVQUFVLENBQUMvTTt3QkFBR3FNLE9BQUsrSTtvQkFBRztvQkFBQzViLEdBQUc0cUIsS0FBSyxDQUFDcE4sTUFBS2dDLE9BQUs7b0JBQUssSUFBSWxDLFNBQU90ZCxHQUFHbkQsSUFBSSxDQUFDMmdCLE1BQUs7b0JBQUt4ZCxHQUFHa0ksS0FBSyxDQUFDb1YsUUFBT3pLLE1BQUssR0FBRUEsS0FBS2xULE1BQU0sRUFBQyxHQUFFcWpCO29CQUFRaGpCLEdBQUc0ZCxLQUFLLENBQUNOO29CQUFRdGQsR0FBRzRxQixLQUFLLENBQUNwTixNQUFLZ0M7Z0JBQUs7WUFBQztZQUFFb04sY0FBYXJOLE1BQU0sRUFBQ25YLElBQUksRUFBQzhVLEtBQUssRUFBQ0MsTUFBTTtnQkFBRSxJQUFJcGhCLE9BQUt1ZCxLQUFLd0IsS0FBSyxDQUFDLE9BQU95RSxVQUFRLFdBQVNBLFNBQU92ZixHQUFHa21CLE9BQU8sQ0FBQzNHLFNBQVFuWDtnQkFBTSxJQUFJb1gsT0FBS3NGLFdBQVcsQ0FBQyxDQUFDNUgsT0FBTSxDQUFDLENBQUNDO2dCQUFRLElBQUcsQ0FBQ25kLEdBQUc0c0IsWUFBWSxDQUFDbEUsS0FBSyxFQUFDMW9CLEdBQUc0c0IsWUFBWSxDQUFDbEUsS0FBSyxHQUFDO2dCQUFHLElBQUkxTCxNQUFJaGQsR0FBRzRvQixPQUFPLENBQUM1b0IsR0FBRzRzQixZQUFZLENBQUNsRSxLQUFLLElBQUc7Z0JBQUcxb0IsR0FBR29kLGNBQWMsQ0FBQ0osS0FBSTtvQkFBQ25nQixNQUFLeWdCLE1BQU07d0JBQUVBLE9BQU9LLFFBQVEsR0FBQztvQkFBSztvQkFBRUMsT0FBTU4sTUFBTTt3QkFBRSxJQUFHSCxVQUFRQSxPQUFPcmUsTUFBTSxJQUFFcWUsT0FBT3JlLE1BQU0sQ0FBQ2EsTUFBTSxFQUFDOzRCQUFDd2QsT0FBTzt3QkFBRztvQkFBQztvQkFBRWxWLE1BQUtxVixNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUNvZSxHQUFHO3dCQUFFLElBQUlFLFlBQVU7d0JBQUUsSUFBSSxJQUFJelgsSUFBRSxHQUFFQSxJQUFFN0csUUFBTzZHLElBQUk7NEJBQUMsSUFBSTVEOzRCQUFPLElBQUc7Z0NBQUNBLFNBQU9zYTs0QkFBTyxFQUFDLE9BQU05YixHQUFFO2dDQUFDLE1BQU0sSUFBSXBCLEdBQUcwZCxVQUFVLENBQUM7NEJBQUc7NEJBQUMsSUFBRzlhLFdBQVNoSSxhQUFXcWpCLGNBQVksR0FBRTtnQ0FBQyxNQUFNLElBQUlqZSxHQUFHMGQsVUFBVSxDQUFDOzRCQUFFOzRCQUFDLElBQUc5YSxXQUFTLFFBQU1BLFdBQVNoSSxXQUFVOzRCQUFNcWpCOzRCQUFZbmYsTUFBTSxDQUFDZ2YsU0FBT3RYLEVBQUUsR0FBQzVEO3dCQUFNO3dCQUFDLElBQUdxYixXQUFVOzRCQUFDWCxPQUFPRSxJQUFJLENBQUNVLFNBQVMsR0FBQ0MsS0FBS0MsR0FBRzt3QkFBRTt3QkFBQyxPQUFPSDtvQkFBUztvQkFBRS9WLE9BQU1vVixNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUNvZSxHQUFHO3dCQUFFLElBQUksSUFBSXZYLElBQUUsR0FBRUEsSUFBRTdHLFFBQU82RyxJQUFJOzRCQUFDLElBQUc7Z0NBQUMyVyxPQUFPcmUsTUFBTSxDQUFDZ2YsU0FBT3RYLEVBQUU7NEJBQUMsRUFBQyxPQUFNcEYsR0FBRTtnQ0FBQyxNQUFNLElBQUlwQixHQUFHMGQsVUFBVSxDQUFDOzRCQUFHO3dCQUFDO3dCQUFDLElBQUcvZCxRQUFPOzRCQUFDMmQsT0FBT0UsSUFBSSxDQUFDVSxTQUFTLEdBQUNDLEtBQUtDLEdBQUc7d0JBQUU7d0JBQUMsT0FBTzVYO29CQUFDO2dCQUFDO2dCQUFHLE9BQU94RyxHQUFHaXFCLEtBQUssQ0FBQ2x1QixNQUFLeWpCLE1BQUt4QztZQUFJO1lBQUVvUixlQUFjcmdCLEdBQUc7Z0JBQUUsSUFBR0EsSUFBSXNnQixRQUFRLElBQUV0Z0IsSUFBSXVnQixRQUFRLElBQUV2Z0IsSUFBSXlTLElBQUksSUFBRXpTLElBQUk4UyxRQUFRLEVBQUMsT0FBTztnQkFBSyxJQUFHLE9BQU9qa0Isa0JBQWdCLGFBQVk7b0JBQUMsTUFBTSxJQUFJa1UsTUFBTTtnQkFBbU0sT0FBTSxJQUFHOVUsT0FBTTtvQkFBQyxJQUFHO3dCQUFDK1IsSUFBSThTLFFBQVEsR0FBQ3pFLG1CQUFtQnBnQixNQUFNK1IsSUFBSXJSLEdBQUcsR0FBRTt3QkFBTXFSLElBQUlnVCxTQUFTLEdBQUNoVCxJQUFJOFMsUUFBUSxDQUFDbGhCLE1BQU07b0JBQUEsRUFBQyxPQUFNeUIsR0FBRTt3QkFBQyxNQUFNLElBQUlwQixHQUFHMGQsVUFBVSxDQUFDO29CQUFHO2dCQUFDLE9BQUs7b0JBQUMsTUFBTSxJQUFJNU0sTUFBTTtnQkFBZ0Q7WUFBQztZQUFFeWQsZ0JBQWVoUCxNQUFNLEVBQUNuWCxJQUFJLEVBQUMxTCxHQUFHLEVBQUNtbkIsT0FBTyxFQUFDQyxRQUFRO2dCQUFFLFNBQVMwSztvQkFBaUIsSUFBSSxDQUFDQyxXQUFXLEdBQUM7b0JBQU0sSUFBSSxDQUFDQyxNQUFNLEdBQUMsRUFBRTtnQkFBQTtnQkFBQ0YsZUFBZXJrQixTQUFTLENBQUNDLEdBQUcsR0FBQyxTQUFTdWtCLG1CQUFtQjFhLEdBQUc7b0JBQUUsSUFBR0EsTUFBSSxJQUFJLENBQUN0VSxNQUFNLEdBQUMsS0FBR3NVLE1BQUksR0FBRTt3QkFBQyxPQUFPclo7b0JBQVM7b0JBQUMsSUFBSWcwQixjQUFZM2EsTUFBSSxJQUFJLENBQUM0YSxTQUFTO29CQUFDLElBQUlDLFdBQVM3YSxNQUFJLElBQUksQ0FBQzRhLFNBQVMsR0FBQztvQkFBRSxPQUFPLElBQUksQ0FBQ2huQixNQUFNLENBQUNpbkIsU0FBUyxDQUFDRixZQUFZO2dCQUFBO2dCQUFFSixlQUFlcmtCLFNBQVMsQ0FBQzRrQixhQUFhLEdBQUMsU0FBU0MsNkJBQTZCbm5CLE1BQU07b0JBQUUsSUFBSSxDQUFDQSxNQUFNLEdBQUNBO2dCQUFNO2dCQUFFMm1CLGVBQWVya0IsU0FBUyxDQUFDOGtCLFdBQVcsR0FBQyxTQUFTQztvQkFBNkIsSUFBSXZ5QixNQUFJLElBQUlDO29CQUFlRCxJQUFJRSxJQUFJLENBQUMsUUFBT0gsS0FBSTtvQkFBT0MsSUFBSUcsSUFBSSxDQUFDO29CQUFNLElBQUcsQ0FBRUgsQ0FBQUEsSUFBSWxCLE1BQU0sSUFBRSxPQUFLa0IsSUFBSWxCLE1BQU0sR0FBQyxPQUFLa0IsSUFBSWxCLE1BQU0sS0FBRyxHQUFFLEdBQUcsTUFBTSxJQUFJcVYsTUFBTSxtQkFBaUJwVSxNQUFJLGVBQWFDLElBQUlsQixNQUFNO29CQUFFLElBQUkwekIsYUFBV0MsT0FBT3p5QixJQUFJMHlCLGlCQUFpQixDQUFDO29CQUFtQixJQUFJQztvQkFBTyxJQUFJQyxpQkFBZSxDQUFDRCxTQUFPM3lCLElBQUkweUIsaUJBQWlCLENBQUMsZ0JBQWUsS0FBSUMsV0FBUztvQkFBUSxJQUFJRSxXQUFTLENBQUNGLFNBQU8zeUIsSUFBSTB5QixpQkFBaUIsQ0FBQyxtQkFBa0IsS0FBSUMsV0FBUztvQkFBTyxJQUFJVCxZQUFVLE9BQUs7b0JBQUssSUFBRyxDQUFDVSxnQkFBZVYsWUFBVU07b0JBQVcsSUFBSU0sUUFBTSxDQUFDL1QsTUFBS0M7d0JBQU0sSUFBR0QsT0FBS0MsSUFBRyxNQUFNLElBQUk3SyxNQUFNLG9CQUFrQjRLLE9BQUssT0FBS0MsS0FBRzt3QkFBNEIsSUFBR0EsS0FBR3dULGFBQVcsR0FBRSxNQUFNLElBQUlyZSxNQUFNLFVBQVFxZSxhQUFXO3dCQUF1QyxJQUFJeHlCLE1BQUksSUFBSUM7d0JBQWVELElBQUlFLElBQUksQ0FBQyxPQUFNSCxLQUFJO3dCQUFPLElBQUd5eUIsZUFBYU4sV0FBVWx5QixJQUFJK3lCLGdCQUFnQixDQUFDLFNBQVEsV0FBU2hVLE9BQUssTUFBSUM7d0JBQUloZixJQUFJSyxZQUFZLEdBQUM7d0JBQWMsSUFBR0wsSUFBSWd6QixnQkFBZ0IsRUFBQzs0QkFBQ2h6QixJQUFJZ3pCLGdCQUFnQixDQUFDO3dCQUFxQzt3QkFBQ2h6QixJQUFJRyxJQUFJLENBQUM7d0JBQU0sSUFBRyxDQUFFSCxDQUFBQSxJQUFJbEIsTUFBTSxJQUFFLE9BQUtrQixJQUFJbEIsTUFBTSxHQUFDLE9BQUtrQixJQUFJbEIsTUFBTSxLQUFHLEdBQUUsR0FBRyxNQUFNLElBQUlxVixNQUFNLG1CQUFpQnBVLE1BQUksZUFBYUMsSUFBSWxCLE1BQU07d0JBQUUsSUFBR2tCLElBQUlPLFFBQVEsS0FBR3RDLFdBQVU7NEJBQUMsT0FBTyxJQUFJcUMsV0FBV04sSUFBSU8sUUFBUSxJQUFFLEVBQUU7d0JBQUM7d0JBQUMsT0FBT2tmLG1CQUFtQnpmLElBQUlJLFlBQVksSUFBRSxJQUFHO29CQUFLO29CQUFFLElBQUk2eUIsWUFBVSxJQUFJO29CQUFDQSxVQUFVYixhQUFhLENBQUNELENBQUFBO3dCQUFXLElBQUlqVCxRQUFNaVQsV0FBU0Q7d0JBQVUsSUFBSS9TLE1BQUksQ0FBQ2dULFdBQVMsS0FBR0QsWUFBVTt3QkFBRS9TLE1BQUl0RCxLQUFLQyxHQUFHLENBQUNxRCxLQUFJcVQsYUFBVzt3QkFBRyxJQUFHLE9BQU9TLFVBQVVsQixNQUFNLENBQUNJLFNBQVMsSUFBRSxhQUFZOzRCQUFDYyxVQUFVbEIsTUFBTSxDQUFDSSxTQUFTLEdBQUNXLE1BQU01VCxPQUFNQzt3QkFBSTt3QkFBQyxJQUFHLE9BQU84VCxVQUFVbEIsTUFBTSxDQUFDSSxTQUFTLElBQUUsYUFBWSxNQUFNLElBQUloZSxNQUFNO3dCQUFpQixPQUFPOGUsVUFBVWxCLE1BQU0sQ0FBQ0ksU0FBUztvQkFBQTtvQkFBRyxJQUFHVSxZQUFVLENBQUNMLFlBQVc7d0JBQUNOLFlBQVVNLGFBQVc7d0JBQUVBLGFBQVcsSUFBSSxDQUFDdG5CLE1BQU0sQ0FBQyxHQUFHbEksTUFBTTt3QkFBQ2t2QixZQUFVTTt3QkFBVzl4QixJQUFJO29CQUE4RTtvQkFBQyxJQUFJLENBQUN3eUIsT0FBTyxHQUFDVjtvQkFBVyxJQUFJLENBQUNXLFVBQVUsR0FBQ2pCO29CQUFVLElBQUksQ0FBQ0osV0FBVyxHQUFDO2dCQUFJO2dCQUFFLElBQUcsT0FBTzd4QixrQkFBZ0IsYUFBWTtvQkFBQyxJQUFHLENBQUNoQix1QkFBc0IsTUFBSztvQkFBc0gsSUFBSWcwQixZQUFVLElBQUlwQjtvQkFBZXB6QixPQUFPOHNCLGdCQUFnQixDQUFDMEgsV0FBVTt3QkFBQ2p3QixRQUFPOzRCQUFDeUssS0FBSTtnQ0FBVyxJQUFHLENBQUMsSUFBSSxDQUFDcWtCLFdBQVcsRUFBQztvQ0FBQyxJQUFJLENBQUNRLFdBQVc7Z0NBQUU7Z0NBQUMsT0FBTyxJQUFJLENBQUNZLE9BQU87NEJBQUE7d0JBQUM7d0JBQUVoQixXQUFVOzRCQUFDemtCLEtBQUk7Z0NBQVcsSUFBRyxDQUFDLElBQUksQ0FBQ3FrQixXQUFXLEVBQUM7b0NBQUMsSUFBSSxDQUFDUSxXQUFXO2dDQUFFO2dDQUFDLE9BQU8sSUFBSSxDQUFDYSxVQUFVOzRCQUFBO3dCQUFDO29CQUFDO29CQUFHLElBQUkzQixhQUFXO3dCQUFDRSxVQUFTO3dCQUFNeE4sVUFBUytPO29CQUFTO2dCQUFDLE9BQUs7b0JBQUMsSUFBSXpCLGFBQVc7d0JBQUNFLFVBQVM7d0JBQU0zeEIsS0FBSUE7b0JBQUc7Z0JBQUM7Z0JBQUMsSUFBSThnQixPQUFLeGQsR0FBR2t1QixVQUFVLENBQUMzTyxRQUFPblgsTUFBSytsQixZQUFXdEssU0FBUUM7Z0JBQVUsSUFBR3FLLFdBQVd0TixRQUFRLEVBQUM7b0JBQUNyRCxLQUFLcUQsUUFBUSxHQUFDc04sV0FBV3ROLFFBQVE7Z0JBQUEsT0FBTSxJQUFHc04sV0FBV3p4QixHQUFHLEVBQUM7b0JBQUM4Z0IsS0FBS3FELFFBQVEsR0FBQztvQkFBS3JELEtBQUs5Z0IsR0FBRyxHQUFDeXhCLFdBQVd6eEIsR0FBRztnQkFBQTtnQkFBQ3RCLE9BQU84c0IsZ0JBQWdCLENBQUMxSyxNQUFLO29CQUFDdUQsV0FBVTt3QkFBQzNXLEtBQUk7NEJBQVcsT0FBTyxJQUFJLENBQUN5VyxRQUFRLENBQUNsaEIsTUFBTTt3QkFBQTtvQkFBQztnQkFBQztnQkFBRyxJQUFJMGQsYUFBVyxDQUFDO2dCQUFFLElBQUlzTSxPQUFLdnVCLE9BQU91dUIsSUFBSSxDQUFDbk0sS0FBS0gsVUFBVTtnQkFBRXNNLEtBQUt2akIsT0FBTyxDQUFDd2MsQ0FBQUE7b0JBQU0sSUFBSS9RLEtBQUcyTCxLQUFLSCxVQUFVLENBQUN1RixJQUFJO29CQUFDdkYsVUFBVSxDQUFDdUYsSUFBSSxHQUFDLFNBQVNtTjt3QkFBb0IvdkIsR0FBR291QixhQUFhLENBQUM1UTt3QkFBTSxPQUFPM0wsR0FBRy9GLEtBQUssQ0FBQyxNQUFLRDtvQkFBVTtnQkFBQztnQkFBRyxTQUFTbWtCLFlBQVkxUyxNQUFNLEVBQUN4ZSxNQUFNLEVBQUNnZixNQUFNLEVBQUNuZSxNQUFNLEVBQUNvakIsUUFBUTtvQkFBRSxJQUFJbEMsV0FBU3ZELE9BQU9FLElBQUksQ0FBQ3FELFFBQVE7b0JBQUMsSUFBR2tDLFlBQVVsQyxTQUFTbGhCLE1BQU0sRUFBQyxPQUFPO29CQUFFLElBQUlnSixPQUFLNlAsS0FBS0MsR0FBRyxDQUFDb0ksU0FBU2xoQixNQUFNLEdBQUNvakIsVUFBU3BqQjtvQkFBUSxJQUFHa2hCLFNBQVM5TyxLQUFLLEVBQUM7d0JBQUMsSUFBSSxJQUFJdkwsSUFBRSxHQUFFQSxJQUFFbUMsTUFBS25DLElBQUk7NEJBQUMxSCxNQUFNLENBQUNnZixTQUFPdFgsRUFBRSxHQUFDcWEsUUFBUSxDQUFDa0MsV0FBU3ZjLEVBQUU7d0JBQUE7b0JBQUMsT0FBSzt3QkFBQyxJQUFJLElBQUlBLElBQUUsR0FBRUEsSUFBRW1DLE1BQUtuQyxJQUFJOzRCQUFDMUgsTUFBTSxDQUFDZ2YsU0FBT3RYLEVBQUUsR0FBQ3FhLFNBQVN6VyxHQUFHLENBQUMyWSxXQUFTdmM7d0JBQUU7b0JBQUM7b0JBQUMsT0FBT21DO2dCQUFJO2dCQUFDMFUsV0FBV3BWLElBQUksR0FBQyxDQUFDcVYsUUFBT3hlLFFBQU9nZixRQUFPbmUsUUFBT29qQjtvQkFBWS9pQixHQUFHb3VCLGFBQWEsQ0FBQzVRO29CQUFNLE9BQU93UyxZQUFZMVMsUUFBT3hlLFFBQU9nZixRQUFPbmUsUUFBT29qQjtnQkFBUztnQkFBRTFGLFdBQVdpRCxJQUFJLEdBQUMsQ0FBQ2hELFFBQU8zZCxRQUFPb2pCLFVBQVNHLE1BQUtDO29CQUFTbmpCLEdBQUdvdUIsYUFBYSxDQUFDNVE7b0JBQU0sSUFBSTVaLE1BQUlzYixVQUFVdmY7b0JBQVEsSUFBRyxDQUFDaUUsS0FBSTt3QkFBQyxNQUFNLElBQUk1RCxHQUFHMGQsVUFBVSxDQUFDO29CQUFHO29CQUFDc1MsWUFBWTFTLFFBQU9sZixPQUFNd0YsS0FBSWpFLFFBQU9vakI7b0JBQVUsT0FBTTt3QkFBQ25mLEtBQUlBO3dCQUFJeUcsV0FBVTtvQkFBSTtnQkFBQztnQkFBRW1ULEtBQUtILFVBQVUsR0FBQ0E7Z0JBQVcsT0FBT0c7WUFBSTtRQUFDO1FBQUUsSUFBSXlTLFdBQVM7WUFBQ0Msa0JBQWlCO1lBQUVDLGFBQVlDLEtBQUssRUFBQ3IwQixJQUFJLEVBQUNzMEIsVUFBVTtnQkFBRSxJQUFHL1csS0FBS0MsS0FBSyxDQUFDeGQsT0FBTTtvQkFBQyxPQUFPQTtnQkFBSTtnQkFBQyxJQUFJMmU7Z0JBQUksSUFBRzBWLFVBQVEsQ0FBQyxLQUFJO29CQUFDMVYsTUFBSTFhLEdBQUd3YixHQUFHO2dCQUFFLE9BQUs7b0JBQUMsSUFBSThVLFlBQVVMLFNBQVNNLGVBQWUsQ0FBQ0g7b0JBQU8xVixNQUFJNFYsVUFBVXYwQixJQUFJO2dCQUFBO2dCQUFDLElBQUdBLEtBQUs0RCxNQUFNLElBQUUsR0FBRTtvQkFBQyxJQUFHLENBQUMwd0IsWUFBVzt3QkFBQyxNQUFNLElBQUlyd0IsR0FBRzBkLFVBQVUsQ0FBQztvQkFBRztvQkFBQyxPQUFPaEQ7Z0JBQUc7Z0JBQUMsT0FBT3BCLEtBQUt3QixLQUFLLENBQUNKLEtBQUkzZTtZQUFLO1lBQUV5MEIsUUFBTzFnQixJQUFJLEVBQUMvVCxJQUFJLEVBQUNtd0IsR0FBRztnQkFBRSxJQUFHO29CQUFDLElBQUl6QixPQUFLM2EsS0FBSy9UO2dCQUFLLEVBQUMsT0FBTXFGLEdBQUU7b0JBQUMsSUFBR0EsS0FBR0EsRUFBRW9jLElBQUksSUFBRWxFLEtBQUtZLFNBQVMsQ0FBQ25lLFVBQVF1ZCxLQUFLWSxTQUFTLENBQUNsYSxHQUFHa21CLE9BQU8sQ0FBQzlrQixFQUFFb2MsSUFBSSxJQUFHO3dCQUFDLE9BQU0sQ0FBQztvQkFBRTtvQkFBQyxNQUFNcGM7Z0JBQUM7Z0JBQUM1QyxNQUFNLENBQUMwdEIsT0FBSyxFQUFFLEdBQUN6QixLQUFLek4sR0FBRztnQkFBQ3hlLE1BQU0sQ0FBQzB0QixNQUFJLEtBQUcsRUFBRSxHQUFDekIsS0FBS2pMLElBQUk7Z0JBQUMvZ0IsT0FBTyxDQUFDeXRCLE1BQUksS0FBRyxFQUFFLEdBQUN6QixLQUFLN0ksS0FBSztnQkFBQ3BqQixNQUFNLENBQUMwdEIsTUFBSSxNQUFJLEVBQUUsR0FBQ3pCLEtBQUs1SSxHQUFHO2dCQUFDcmpCLE1BQU0sQ0FBQzB0QixNQUFJLE1BQUksRUFBRSxHQUFDekIsS0FBSzNJLEdBQUc7Z0JBQUN0akIsTUFBTSxDQUFDMHRCLE1BQUksTUFBSSxFQUFFLEdBQUN6QixLQUFLaE4sSUFBSTtnQkFBQ2xhLFVBQVE7b0JBQUNrbkIsS0FBSzloQixJQUFJLEtBQUc7b0JBQUdyRixDQUFBQSxhQUFXbW5CLEtBQUs5aEIsSUFBSSxFQUFDLENBQUM2UCxLQUFLaVksR0FBRyxDQUFDbnRCLGVBQWEsSUFBRUEsYUFBVyxJQUFFLENBQUNrVixLQUFLa1ksS0FBSyxDQUFDcHRCLGFBQVcsZ0JBQWMsSUFBRSxDQUFDLENBQUMsQ0FBQ2tWLEtBQUs0SixJQUFJLENBQUMsQ0FBQzllLGFBQVcsQ0FBRSxFQUFDLENBQUNBLGVBQWEsRUFBQyxJQUFHLGdCQUFjLElBQUU7aUJBQUcsRUFBQzlFLE1BQU0sQ0FBQzB0QixNQUFJLE1BQUksRUFBRSxHQUFDM29CLE9BQU8sQ0FBQyxFQUFFLEVBQUMvRSxNQUFNLENBQUMwdEIsTUFBSSxNQUFJLEVBQUUsR0FBQzNvQixPQUFPLENBQUMsRUFBRTtnQkFBQy9FLE1BQU0sQ0FBQzB0QixNQUFJLE1BQUksRUFBRSxHQUFDO2dCQUFLMXRCLE1BQU0sQ0FBQzB0QixNQUFJLE1BQUksRUFBRSxHQUFDekIsS0FBS3RJLE1BQU07Z0JBQUMsSUFBSUosUUFBTTBJLEtBQUsxSSxLQUFLLENBQUM0TyxPQUFPO2dCQUFHLElBQUkzTyxRQUFNeUksS0FBS3pJLEtBQUssQ0FBQzJPLE9BQU87Z0JBQUcsSUFBSTFPLFFBQU13SSxLQUFLeEksS0FBSyxDQUFDME8sT0FBTztnQkFBR3B0QixVQUFRO29CQUFDaVYsS0FBS2tZLEtBQUssQ0FBQzNPLFFBQU0sU0FBTztvQkFBR3plLENBQUFBLGFBQVdrVixLQUFLa1ksS0FBSyxDQUFDM08sUUFBTSxNQUFLLENBQUN2SixLQUFLaVksR0FBRyxDQUFDbnRCLGVBQWEsSUFBRUEsYUFBVyxJQUFFLENBQUNrVixLQUFLa1ksS0FBSyxDQUFDcHRCLGFBQVcsZ0JBQWMsSUFBRSxDQUFDLENBQUMsQ0FBQ2tWLEtBQUs0SixJQUFJLENBQUMsQ0FBQzllLGFBQVcsQ0FBRSxFQUFDLENBQUNBLGVBQWEsRUFBQyxJQUFHLGdCQUFjLElBQUU7aUJBQUcsRUFBQzlFLE1BQU0sQ0FBQzB0QixNQUFJLE1BQUksRUFBRSxHQUFDM29CLE9BQU8sQ0FBQyxFQUFFLEVBQUMvRSxNQUFNLENBQUMwdEIsTUFBSSxNQUFJLEVBQUUsR0FBQzNvQixPQUFPLENBQUMsRUFBRTtnQkFBQzlFLE9BQU8sQ0FBQ3l0QixNQUFJLE1BQUksRUFBRSxHQUFDbkssUUFBTSxNQUFJO2dCQUFJeGUsVUFBUTtvQkFBQ2lWLEtBQUtrWSxLQUFLLENBQUMxTyxRQUFNLFNBQU87b0JBQUcxZSxDQUFBQSxhQUFXa1YsS0FBS2tZLEtBQUssQ0FBQzFPLFFBQU0sTUFBSyxDQUFDeEosS0FBS2lZLEdBQUcsQ0FBQ250QixlQUFhLElBQUVBLGFBQVcsSUFBRSxDQUFDa1YsS0FBS2tZLEtBQUssQ0FBQ3B0QixhQUFXLGdCQUFjLElBQUUsQ0FBQyxDQUFDLENBQUNrVixLQUFLNEosSUFBSSxDQUFDLENBQUM5ZSxhQUFXLENBQUUsRUFBQyxDQUFDQSxlQUFhLEVBQUMsSUFBRyxnQkFBYyxJQUFFO2lCQUFHLEVBQUM5RSxNQUFNLENBQUMwdEIsTUFBSSxNQUFJLEVBQUUsR0FBQzNvQixPQUFPLENBQUMsRUFBRSxFQUFDL0UsTUFBTSxDQUFDMHRCLE1BQUksTUFBSSxFQUFFLEdBQUMzb0IsT0FBTyxDQUFDLEVBQUU7Z0JBQUM5RSxPQUFPLENBQUN5dEIsTUFBSSxNQUFJLEVBQUUsR0FBQ2xLLFFBQU0sTUFBSTtnQkFBSXplLFVBQVE7b0JBQUNpVixLQUFLa1ksS0FBSyxDQUFDek8sUUFBTSxTQUFPO29CQUFHM2UsQ0FBQUEsYUFBV2tWLEtBQUtrWSxLQUFLLENBQUN6TyxRQUFNLE1BQUssQ0FBQ3pKLEtBQUtpWSxHQUFHLENBQUNudEIsZUFBYSxJQUFFQSxhQUFXLElBQUUsQ0FBQ2tWLEtBQUtrWSxLQUFLLENBQUNwdEIsYUFBVyxnQkFBYyxJQUFFLENBQUMsQ0FBQyxDQUFDa1YsS0FBSzRKLElBQUksQ0FBQyxDQUFDOWUsYUFBVyxDQUFFLEVBQUMsQ0FBQ0EsZUFBYSxFQUFDLElBQUcsZ0JBQWMsSUFBRTtpQkFBRyxFQUFDOUUsTUFBTSxDQUFDMHRCLE1BQUksTUFBSSxFQUFFLEdBQUMzb0IsT0FBTyxDQUFDLEVBQUUsRUFBQy9FLE1BQU0sQ0FBQzB0QixNQUFJLE1BQUksRUFBRSxHQUFDM29CLE9BQU8sQ0FBQyxFQUFFO2dCQUFDOUUsT0FBTyxDQUFDeXRCLE1BQUksTUFBSSxFQUFFLEdBQUNqSyxRQUFNLE1BQUk7Z0JBQUkxZSxVQUFRO29CQUFDa25CLEtBQUs5SSxHQUFHLEtBQUc7b0JBQUdyZSxDQUFBQSxhQUFXbW5CLEtBQUs5SSxHQUFHLEVBQUMsQ0FBQ25KLEtBQUtpWSxHQUFHLENBQUNudEIsZUFBYSxJQUFFQSxhQUFXLElBQUUsQ0FBQ2tWLEtBQUtrWSxLQUFLLENBQUNwdEIsYUFBVyxnQkFBYyxJQUFFLENBQUMsQ0FBQyxDQUFDa1YsS0FBSzRKLElBQUksQ0FBQyxDQUFDOWUsYUFBVyxDQUFFLEVBQUMsQ0FBQ0EsZUFBYSxFQUFDLElBQUcsZ0JBQWMsSUFBRTtpQkFBRyxFQUFDOUUsTUFBTSxDQUFDMHRCLE1BQUksTUFBSSxFQUFFLEdBQUMzb0IsT0FBTyxDQUFDLEVBQUUsRUFBQy9FLE1BQU0sQ0FBQzB0QixNQUFJLE1BQUksRUFBRSxHQUFDM29CLE9BQU8sQ0FBQyxFQUFFO2dCQUFDLE9BQU87WUFBQztZQUFFcXRCLFNBQVFDLElBQUksRUFBQ3ZULE1BQU0sRUFBQzFKLEdBQUcsRUFBQ3VQLEtBQUssRUFBQ3JGLE1BQU07Z0JBQUUsSUFBRyxDQUFDOWQsR0FBRzhnQixNQUFNLENBQUN4RCxPQUFPRSxJQUFJLENBQUNnQyxJQUFJLEdBQUU7b0JBQUMsTUFBTSxJQUFJeGYsR0FBRzBkLFVBQVUsQ0FBQztnQkFBRztnQkFBQyxJQUFHeUYsUUFBTSxHQUFFO29CQUFDLE9BQU87Z0JBQUM7Z0JBQUMsSUFBSXJrQixTQUFPVCxPQUFPMFQsS0FBSyxDQUFDOGUsTUFBS0EsT0FBS2pkO2dCQUFLNVQsR0FBR3VnQixLQUFLLENBQUNqRCxRQUFPeGUsUUFBT2dmLFFBQU9sSyxLQUFJdVA7WUFBTTtZQUFFMk4sU0FBUWwyQjtZQUFVd1A7Z0JBQU0sSUFBSWhCLE1BQUk1SyxNQUFNLENBQUMsQ0FBQ3l4QixTQUFTYSxPQUFPLElBQUUsRUFBRTtnQkFBQ2IsU0FBU2EsT0FBTyxJQUFFO2dCQUFFLE9BQU8xbkI7WUFBRztZQUFFMm5CO2dCQUFPLE9BQU9kLFNBQVM3bEIsR0FBRztZQUFFO1lBQUU0bUIsUUFBT3B0QixHQUFHO2dCQUFFLElBQUl3RixNQUFJcUwsYUFBYTdRO2dCQUFLLE9BQU93RjtZQUFHO1lBQUVtbkIsaUJBQWdCM0ksRUFBRTtnQkFBRSxJQUFJdEssU0FBT3RkLEdBQUc2bkIsZ0JBQWdCLENBQUNEO2dCQUFJLE9BQU90SztZQUFNO1FBQUM7UUFBRSxJQUFJMlQsZUFBYSxDQUFDQyxXQUFVQztZQUFlLElBQUlDLFVBQVE7WUFBRXJZLGdCQUFnQjNTLE9BQU8sQ0FBQyxDQUFDaXJCLFFBQU83cUI7Z0JBQUssSUFBSTVDLE1BQUl1dEIsY0FBWUM7Z0JBQVEzeUIsT0FBTyxDQUFDeXlCLFlBQVUxcUIsSUFBRSxLQUFHLEVBQUUsR0FBQzVDO2dCQUFJeVYsY0FBY2dZLFFBQU96dEI7Z0JBQUt3dEIsV0FBU0MsT0FBTzF4QixNQUFNLEdBQUM7WUFBQztZQUFHLE9BQU87UUFBQztRQUFFLElBQUkyeEIscUJBQW1CLENBQUNDLGdCQUFlQztZQUFxQixJQUFJeFksVUFBUUQ7WUFBZ0J0YSxPQUFPLENBQUM4eUIsa0JBQWdCLEVBQUUsR0FBQ3ZZLFFBQVFyWixNQUFNO1lBQUMsSUFBSXl4QixVQUFRO1lBQUVwWSxRQUFRNVMsT0FBTyxDQUFDaXJCLENBQUFBLFNBQVFELFdBQVNDLE9BQU8xeEIsTUFBTSxHQUFDO1lBQUdsQixPQUFPLENBQUMreUIscUJBQW1CLEVBQUUsR0FBQ0o7WUFBUSxPQUFPO1FBQUM7UUFBRSxTQUFTSyxVQUFVN0osRUFBRTtZQUFFLElBQUc7Z0JBQUMsSUFBSXRLLFNBQU8yUyxTQUFTTSxlQUFlLENBQUMzSTtnQkFBSTVuQixHQUFHNGQsS0FBSyxDQUFDTjtnQkFBUSxPQUFPO1lBQUMsRUFBQyxPQUFNbGMsR0FBRTtnQkFBQyxJQUFHLE9BQU9wQixNQUFJLGVBQWEsQ0FBRW9CLENBQUFBLEVBQUVnSCxJQUFJLEtBQUcsWUFBVyxHQUFHLE1BQU1oSDtnQkFBRSxPQUFPQSxFQUFFb21CLEtBQUs7WUFBQTtRQUFDO1FBQUMsSUFBSWtLLFVBQVEsQ0FBQ3BVLFFBQU9xVSxLQUFJQyxRQUFPOVQ7WUFBVSxJQUFJMVUsTUFBSTtZQUFFLElBQUksSUFBSTVDLElBQUUsR0FBRUEsSUFBRW9yQixRQUFPcHJCLElBQUk7Z0JBQUMsSUFBSTVDLE1BQUluRixPQUFPLENBQUNrekIsT0FBSyxFQUFFO2dCQUFDLElBQUkvZCxNQUFJblYsT0FBTyxDQUFDa3pCLE1BQUksS0FBRyxFQUFFO2dCQUFDQSxPQUFLO2dCQUFFLElBQUlFLE9BQUs3eEIsR0FBR2lJLElBQUksQ0FBQ3FWLFFBQU9sZixPQUFNd0YsS0FBSWdRLEtBQUlrSztnQkFBUSxJQUFHK1QsT0FBSyxHQUFFLE9BQU0sQ0FBQztnQkFBRXpvQixPQUFLeW9CO2dCQUFLLElBQUdBLE9BQUtqZSxLQUFJO2dCQUFNLElBQUcsT0FBT2tLLFdBQVMsYUFBWTtvQkFBQ0EsVUFBUStUO2dCQUFJO1lBQUM7WUFBQyxPQUFPem9CO1FBQUc7UUFBRSxTQUFTMG9CLFNBQVNsSyxFQUFFLEVBQUMrSixHQUFHLEVBQUNDLE1BQU0sRUFBQ0csSUFBSTtZQUFFLElBQUc7Z0JBQUMsSUFBSXpVLFNBQU8yUyxTQUFTTSxlQUFlLENBQUMzSTtnQkFBSSxJQUFJcFEsTUFBSWthLFFBQVFwVSxRQUFPcVUsS0FBSUM7Z0JBQVFuekIsT0FBTyxDQUFDc3pCLFFBQU0sRUFBRSxHQUFDdmE7Z0JBQUksT0FBTztZQUFDLEVBQUMsT0FBTXBXLEdBQUU7Z0JBQUMsSUFBRyxPQUFPcEIsTUFBSSxlQUFhLENBQUVvQixDQUFBQSxFQUFFZ0gsSUFBSSxLQUFHLFlBQVcsR0FBRyxNQUFNaEg7Z0JBQUUsT0FBT0EsRUFBRW9tQixLQUFLO1lBQUE7UUFBQztRQUFDLElBQUl3Syw2QkFBMkIsQ0FBQ0MsSUFBR0MsS0FBS0EsS0FBRyxZQUFVLElBQUUsVUFBUSxDQUFDLENBQUNELEtBQUcsQ0FBQ0EsT0FBSyxLQUFHQyxLQUFHLGFBQVdDO1FBQUksU0FBU0MsU0FBU3hLLEVBQUUsRUFBQ3lLLFVBQVUsRUFBQ0MsV0FBVyxFQUFDclAsTUFBTSxFQUFDc1AsU0FBUztZQUFFLElBQUl6VSxTQUFPa1UsMkJBQTJCSyxZQUFXQztZQUFhLElBQUc7Z0JBQUMsSUFBR0UsTUFBTTFVLFNBQVEsT0FBTztnQkFBRyxJQUFJUixTQUFPMlMsU0FBU00sZUFBZSxDQUFDM0k7Z0JBQUk1bkIsR0FBR3FnQixNQUFNLENBQUMvQyxRQUFPUSxRQUFPbUY7Z0JBQVExZixVQUFRO29CQUFDK1osT0FBT3lGLFFBQVEsS0FBRztvQkFBR3pmLENBQUFBLGFBQVdnYSxPQUFPeUYsUUFBUSxFQUFDLENBQUN2SyxLQUFLaVksR0FBRyxDQUFDbnRCLGVBQWEsSUFBRUEsYUFBVyxJQUFFLENBQUNrVixLQUFLa1ksS0FBSyxDQUFDcHRCLGFBQVcsZ0JBQWMsSUFBRSxDQUFDLENBQUMsQ0FBQ2tWLEtBQUs0SixJQUFJLENBQUMsQ0FBQzllLGFBQVcsQ0FBRSxFQUFDLENBQUNBLGVBQWEsRUFBQyxJQUFHLGdCQUFjLElBQUU7aUJBQUcsRUFBQzlFLE1BQU0sQ0FBQyt6QixhQUFXLEVBQUUsR0FBQ2h2QixPQUFPLENBQUMsRUFBRSxFQUFDL0UsTUFBTSxDQUFDK3pCLFlBQVUsS0FBRyxFQUFFLEdBQUNodkIsT0FBTyxDQUFDLEVBQUU7Z0JBQUMsSUFBRytaLE9BQU9tTyxRQUFRLElBQUUzTixXQUFTLEtBQUdtRixXQUFTLEdBQUUzRixPQUFPbU8sUUFBUSxHQUFDO2dCQUFLLE9BQU87WUFBQyxFQUFDLE9BQU1ycUIsR0FBRTtnQkFBQyxJQUFHLE9BQU9wQixNQUFJLGVBQWEsQ0FBRW9CLENBQUFBLEVBQUVnSCxJQUFJLEtBQUcsWUFBVyxHQUFHLE1BQU1oSDtnQkFBRSxPQUFPQSxFQUFFb21CLEtBQUs7WUFBQTtRQUFDO1FBQUMsSUFBSWlMLFdBQVMsQ0FBQ25WLFFBQU9xVSxLQUFJQyxRQUFPOVQ7WUFBVSxJQUFJMVUsTUFBSTtZQUFFLElBQUksSUFBSTVDLElBQUUsR0FBRUEsSUFBRW9yQixRQUFPcHJCLElBQUk7Z0JBQUMsSUFBSTVDLE1BQUluRixPQUFPLENBQUNrekIsT0FBSyxFQUFFO2dCQUFDLElBQUkvZCxNQUFJblYsT0FBTyxDQUFDa3pCLE1BQUksS0FBRyxFQUFFO2dCQUFDQSxPQUFLO2dCQUFFLElBQUlFLE9BQUs3eEIsR0FBR2tJLEtBQUssQ0FBQ29WLFFBQU9sZixPQUFNd0YsS0FBSWdRLEtBQUlrSztnQkFBUSxJQUFHK1QsT0FBSyxHQUFFLE9BQU0sQ0FBQztnQkFBRXpvQixPQUFLeW9CO2dCQUFLLElBQUcsT0FBTy9ULFdBQVMsYUFBWTtvQkFBQ0EsVUFBUStUO2dCQUFJO1lBQUM7WUFBQyxPQUFPem9CO1FBQUc7UUFBRSxTQUFTc3BCLFVBQVU5SyxFQUFFLEVBQUMrSixHQUFHLEVBQUNDLE1BQU0sRUFBQ0csSUFBSTtZQUFFLElBQUc7Z0JBQUMsSUFBSXpVLFNBQU8yUyxTQUFTTSxlQUFlLENBQUMzSTtnQkFBSSxJQUFJcFEsTUFBSWliLFNBQVNuVixRQUFPcVUsS0FBSUM7Z0JBQVFuekIsT0FBTyxDQUFDc3pCLFFBQU0sRUFBRSxHQUFDdmE7Z0JBQUksT0FBTztZQUFDLEVBQUMsT0FBTXBXLEdBQUU7Z0JBQUMsSUFBRyxPQUFPcEIsTUFBSSxlQUFhLENBQUVvQixDQUFBQSxFQUFFZ0gsSUFBSSxLQUFHLFlBQVcsR0FBRyxNQUFNaEg7Z0JBQUUsT0FBT0EsRUFBRW9tQixLQUFLO1lBQUE7UUFBQztRQUFDLElBQUltTCxhQUFXQyxDQUFBQSxPQUFNQSxPQUFLLE1BQUksS0FBSUEsQ0FBQUEsT0FBSyxRQUFNLEtBQUdBLE9BQUssUUFBTTtRQUFHLElBQUlDLFdBQVMsQ0FBQ3pqQixPQUFNMGpCO1lBQVMsSUFBSUMsTUFBSTtZQUFFLElBQUksSUFBSXZzQixJQUFFLEdBQUVBLEtBQUdzc0IsT0FBTUMsT0FBSzNqQixLQUFLLENBQUM1SSxJQUFJLENBQUMsQ0FBQztZQUFDLE9BQU91c0I7UUFBRztRQUFFLElBQUlDLGtCQUFnQjtZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztTQUFHO1FBQUMsSUFBSUMscUJBQW1CO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1lBQUc7WUFBRztZQUFHO1NBQUc7UUFBQyxJQUFJQyxVQUFRLENBQUNDLE1BQUtDO1lBQVEsSUFBSUMsVUFBUSxJQUFJbFYsS0FBS2dWLEtBQUt4QyxPQUFPO1lBQUksTUFBTXlDLE9BQUssRUFBRTtnQkFBQyxJQUFJRSxPQUFLWCxXQUFXVSxRQUFRRSxXQUFXO2dCQUFJLElBQUlDLGVBQWFILFFBQVFJLFFBQVE7Z0JBQUcsSUFBSUMscUJBQW1CLENBQUNKLE9BQUtOLGtCQUFnQkMsa0JBQWlCLENBQUUsQ0FBQ08sYUFBYTtnQkFBQyxJQUFHSixPQUFLTSxxQkFBbUJMLFFBQVFNLE9BQU8sSUFBRztvQkFBQ1AsUUFBTU0scUJBQW1CTCxRQUFRTSxPQUFPLEtBQUc7b0JBQUVOLFFBQVFPLE9BQU8sQ0FBQztvQkFBRyxJQUFHSixlQUFhLElBQUc7d0JBQUNILFFBQVFRLFFBQVEsQ0FBQ0wsZUFBYTtvQkFBRSxPQUFLO3dCQUFDSCxRQUFRUSxRQUFRLENBQUM7d0JBQUdSLFFBQVFTLFdBQVcsQ0FBQ1QsUUFBUUUsV0FBVyxLQUFHO29CQUFFO2dCQUFDLE9BQUs7b0JBQUNGLFFBQVFPLE9BQU8sQ0FBQ1AsUUFBUU0sT0FBTyxLQUFHUDtvQkFBTSxPQUFPQztnQkFBTztZQUFDO1lBQUMsT0FBT0E7UUFBTztRQUFFLElBQUlVLHFCQUFtQixDQUFDM2tCLE9BQU10UTtZQUFVVixNQUFNb2pCLEdBQUcsQ0FBQ3BTLE9BQU10UTtRQUFPO1FBQUUsSUFBSWsxQixZQUFVLENBQUNDLEdBQUVDLFNBQVFDLFFBQU9DO1lBQU0sSUFBSUMsVUFBUTUxQixPQUFPLENBQUMyMUIsS0FBRyxNQUFJLEVBQUU7WUFBQyxJQUFJakIsT0FBSztnQkFBQ21CLFFBQU85MUIsTUFBTSxDQUFDNDFCLE1BQUksRUFBRTtnQkFBQ0csUUFBTy8xQixNQUFNLENBQUM0MUIsS0FBRyxLQUFHLEVBQUU7Z0JBQUNJLFNBQVFoMkIsTUFBTSxDQUFDNDFCLEtBQUcsS0FBRyxFQUFFO2dCQUFDSyxTQUFRajJCLE1BQU0sQ0FBQzQxQixLQUFHLE1BQUksRUFBRTtnQkFBQ00sUUFBT2wyQixNQUFNLENBQUM0MUIsS0FBRyxNQUFJLEVBQUU7Z0JBQUNPLFNBQVFuMkIsTUFBTSxDQUFDNDFCLEtBQUcsTUFBSSxFQUFFO2dCQUFDUSxTQUFRcDJCLE1BQU0sQ0FBQzQxQixLQUFHLE1BQUksRUFBRTtnQkFBQ1MsU0FBUXIyQixNQUFNLENBQUM0MUIsS0FBRyxNQUFJLEVBQUU7Z0JBQUNVLFVBQVN0MkIsTUFBTSxDQUFDNDFCLEtBQUcsTUFBSSxFQUFFO2dCQUFDVyxXQUFVdjJCLE1BQU0sQ0FBQzQxQixLQUFHLE1BQUksRUFBRTtnQkFBQ0MsU0FBUUEsVUFBUTVmLGFBQWE0ZixXQUFTO1lBQUU7WUFBRSxJQUFJVyxVQUFRdmdCLGFBQWEwZjtZQUFRLElBQUljLG9CQUFrQjtnQkFBQyxNQUFLO2dCQUF1QixNQUFLO2dCQUFXLE1BQUs7Z0JBQVcsTUFBSztnQkFBSyxNQUFLO2dCQUFjLE1BQUs7Z0JBQVEsTUFBSztnQkFBVyxNQUFLO2dCQUFXLE1BQUs7Z0JBQVcsT0FBTTtnQkFBSyxPQUFNO2dCQUFLLE9BQU07Z0JBQVcsT0FBTTtnQkFBVyxPQUFNO2dCQUFLLE9BQU07Z0JBQUssT0FBTTtnQkFBSyxPQUFNO2dCQUFLLE9BQU07Z0JBQUssT0FBTTtnQkFBSyxPQUFNO2dCQUFLLE9BQU07Z0JBQUssT0FBTTtnQkFBSyxPQUFNO2dCQUFLLE9BQU07Z0JBQUssT0FBTTtnQkFBSyxPQUFNO2dCQUFLLE9BQU07Z0JBQUssT0FBTTtZQUFJO1lBQUUsSUFBSSxJQUFJQyxRQUFRRCxrQkFBa0I7Z0JBQUNELFVBQVFBLFFBQVF4NEIsT0FBTyxDQUFDLElBQUkyNEIsT0FBT0QsTUFBSyxNQUFLRCxpQkFBaUIsQ0FBQ0MsS0FBSztZQUFDO1lBQUMsSUFBSUUsV0FBUztnQkFBQztnQkFBUztnQkFBUztnQkFBVTtnQkFBWTtnQkFBVztnQkFBUzthQUFXO1lBQUMsSUFBSUMsU0FBTztnQkFBQztnQkFBVTtnQkFBVztnQkFBUTtnQkFBUTtnQkFBTTtnQkFBTztnQkFBTztnQkFBUztnQkFBWTtnQkFBVTtnQkFBVzthQUFXO1lBQUMsU0FBU0MsaUJBQWlCcHFCLEtBQUssRUFBQ3FxQixNQUFNLEVBQUNDLFNBQVM7Z0JBQUUsSUFBSXhpQixNQUFJLE9BQU85SCxTQUFPLFdBQVNBLE1BQU02RixRQUFRLEtBQUc3RixTQUFPO2dCQUFHLE1BQU04SCxJQUFJclQsTUFBTSxHQUFDNDFCLE9BQU87b0JBQUN2aUIsTUFBSXdpQixTQUFTLENBQUMsRUFBRSxHQUFDeGlCO2dCQUFHO2dCQUFDLE9BQU9BO1lBQUc7WUFBQyxTQUFTeWlCLGFBQWF2cUIsS0FBSyxFQUFDcXFCLE1BQU07Z0JBQUUsT0FBT0QsaUJBQWlCcHFCLE9BQU1xcUIsUUFBTztZQUFJO1lBQUMsU0FBU0csYUFBYUMsS0FBSyxFQUFDQyxLQUFLO2dCQUFFLFNBQVNDLElBQUkzcUIsS0FBSztvQkFBRSxPQUFPQSxRQUFNLElBQUUsQ0FBQyxJQUFFQSxRQUFNLElBQUUsSUFBRTtnQkFBQztnQkFBQyxJQUFJNHFCO2dCQUFRLElBQUcsQ0FBQ0EsVUFBUUQsSUFBSUYsTUFBTXBDLFdBQVcsS0FBR3FDLE1BQU1yQyxXQUFXLEdBQUUsTUFBSyxHQUFFO29CQUFDLElBQUcsQ0FBQ3VDLFVBQVFELElBQUlGLE1BQU1sQyxRQUFRLEtBQUdtQyxNQUFNbkMsUUFBUSxHQUFFLE1BQUssR0FBRTt3QkFBQ3FDLFVBQVFELElBQUlGLE1BQU1oQyxPQUFPLEtBQUdpQyxNQUFNakMsT0FBTztvQkFBRztnQkFBQztnQkFBQyxPQUFPbUM7WUFBTztZQUFDLFNBQVNDLHNCQUFzQkMsU0FBUztnQkFBRSxPQUFPQSxVQUFVQyxNQUFNO29CQUFJLEtBQUs7d0JBQUUsT0FBTyxJQUFJOVgsS0FBSzZYLFVBQVV6QyxXQUFXLEtBQUcsR0FBRSxJQUFHO29CQUFJLEtBQUs7d0JBQUUsT0FBT3lDO29CQUFVLEtBQUs7d0JBQUUsT0FBTyxJQUFJN1gsS0FBSzZYLFVBQVV6QyxXQUFXLElBQUcsR0FBRTtvQkFBRyxLQUFLO3dCQUFFLE9BQU8sSUFBSXBWLEtBQUs2WCxVQUFVekMsV0FBVyxJQUFHLEdBQUU7b0JBQUcsS0FBSzt3QkFBRSxPQUFPLElBQUlwVixLQUFLNlgsVUFBVXpDLFdBQVcsSUFBRyxHQUFFO29CQUFHLEtBQUs7d0JBQUUsT0FBTyxJQUFJcFYsS0FBSzZYLFVBQVV6QyxXQUFXLEtBQUcsR0FBRSxJQUFHO29CQUFJLEtBQUs7d0JBQUUsT0FBTyxJQUFJcFYsS0FBSzZYLFVBQVV6QyxXQUFXLEtBQUcsR0FBRSxJQUFHO2dCQUFHO1lBQUM7WUFBQyxTQUFTMkMsaUJBQWlCL0MsSUFBSTtnQkFBRSxJQUFJZ0QsV0FBU2pELFFBQVEsSUFBSS9VLEtBQUtnVixLQUFLd0IsT0FBTyxHQUFDLE1BQUssR0FBRSxJQUFHeEIsS0FBSzBCLE9BQU87Z0JBQUUsSUFBSXVCLG9CQUFrQixJQUFJalksS0FBS2dZLFNBQVM1QyxXQUFXLElBQUcsR0FBRTtnQkFBRyxJQUFJOEMsb0JBQWtCLElBQUlsWSxLQUFLZ1ksU0FBUzVDLFdBQVcsS0FBRyxHQUFFLEdBQUU7Z0JBQUcsSUFBSStDLHlCQUF1QlAsc0JBQXNCSztnQkFBbUIsSUFBSUcseUJBQXVCUixzQkFBc0JNO2dCQUFtQixJQUFHWCxhQUFhWSx3QkFBdUJILGFBQVcsR0FBRTtvQkFBQyxJQUFHVCxhQUFhYSx3QkFBdUJKLGFBQVcsR0FBRTt3QkFBQyxPQUFPQSxTQUFTNUMsV0FBVyxLQUFHO29CQUFDO29CQUFDLE9BQU80QyxTQUFTNUMsV0FBVztnQkFBRTtnQkFBQyxPQUFPNEMsU0FBUzVDLFdBQVcsS0FBRztZQUFDO1lBQUMsSUFBSWlELG9CQUFrQjtnQkFBQyxNQUFLckQsQ0FBQUEsT0FBTWlDLFFBQVEsQ0FBQ2pDLEtBQUt5QixPQUFPLENBQUMsQ0FBQzZCLFNBQVMsQ0FBQyxHQUFFO2dCQUFHLE1BQUt0RCxDQUFBQSxPQUFNaUMsUUFBUSxDQUFDakMsS0FBS3lCLE9BQU8sQ0FBQztnQkFBQyxNQUFLekIsQ0FBQUEsT0FBTWtDLE1BQU0sQ0FBQ2xDLEtBQUt1QixNQUFNLENBQUMsQ0FBQytCLFNBQVMsQ0FBQyxHQUFFO2dCQUFHLE1BQUt0RCxDQUFBQSxPQUFNa0MsTUFBTSxDQUFDbEMsS0FBS3VCLE1BQU0sQ0FBQztnQkFBQyxNQUFLdkIsQ0FBQUE7b0JBQU8sSUFBSVAsT0FBS08sS0FBS3dCLE9BQU8sR0FBQztvQkFBSyxPQUFPYyxhQUFhN0MsT0FBSyxNQUFJLEdBQUU7Z0JBQUU7Z0JBQUUsTUFBS08sQ0FBQUEsT0FBTXNDLGFBQWF0QyxLQUFLc0IsT0FBTyxFQUFDO2dCQUFHLE1BQUt0QixDQUFBQSxPQUFNbUMsaUJBQWlCbkMsS0FBS3NCLE9BQU8sRUFBQyxHQUFFO2dCQUFLLE1BQUt0QixDQUFBQSxPQUFNK0MsaUJBQWlCL0MsTUFBTXBpQixRQUFRLEdBQUcwbEIsU0FBUyxDQUFDO2dCQUFHLE1BQUt0RCxDQUFBQSxPQUFNK0MsaUJBQWlCL0M7Z0JBQU0sTUFBS0EsQ0FBQUEsT0FBTXNDLGFBQWF0QyxLQUFLcUIsT0FBTyxFQUFDO2dCQUFHLE1BQUtyQixDQUFBQTtvQkFBTyxJQUFJdUQsYUFBV3ZELEtBQUtxQixPQUFPO29CQUFDLElBQUdrQyxjQUFZLEdBQUVBLGFBQVc7eUJBQVEsSUFBR0EsYUFBVyxJQUFHQSxjQUFZO29CQUFHLE9BQU9qQixhQUFhaUIsWUFBVztnQkFBRTtnQkFBRSxNQUFLdkQsQ0FBQUEsT0FBTXNDLGFBQWF0QyxLQUFLc0IsT0FBTyxHQUFDNUIsU0FBU0YsV0FBV1EsS0FBS3dCLE9BQU8sR0FBQyxRQUFNM0Isa0JBQWdCQyxvQkFBbUJFLEtBQUt1QixNQUFNLEdBQUMsSUFBRztnQkFBRyxNQUFLdkIsQ0FBQUEsT0FBTXNDLGFBQWF0QyxLQUFLdUIsTUFBTSxHQUFDLEdBQUU7Z0JBQUcsTUFBS3ZCLENBQUFBLE9BQU1zQyxhQUFhdEMsS0FBS29CLE1BQU0sRUFBQztnQkFBRyxNQUFLLElBQUk7Z0JBQUssTUFBS3BCLENBQUFBO29CQUFPLElBQUdBLEtBQUtxQixPQUFPLElBQUUsS0FBR3JCLEtBQUtxQixPQUFPLEdBQUMsSUFBRzt3QkFBQyxPQUFNO29CQUFJO29CQUFDLE9BQU07Z0JBQUk7Z0JBQUUsTUFBS3JCLENBQUFBLE9BQU1zQyxhQUFhdEMsS0FBS21CLE1BQU0sRUFBQztnQkFBRyxNQUFLLElBQUk7Z0JBQUssTUFBS25CLENBQUFBLE9BQU1BLEtBQUt5QixPQUFPLElBQUU7Z0JBQUUsTUFBS3pCLENBQUFBO29CQUFPLElBQUlDLE9BQUtELEtBQUswQixPQUFPLEdBQUMsSUFBRTFCLEtBQUt5QixPQUFPO29CQUFDLE9BQU9hLGFBQWFqZCxLQUFLa1ksS0FBSyxDQUFDMEMsT0FBSyxJQUFHO2dCQUFFO2dCQUFFLE1BQUtELENBQUFBO29CQUFPLElBQUk1VSxNQUFJL0YsS0FBS2tZLEtBQUssQ0FBQyxDQUFDeUMsS0FBSzBCLE9BQU8sR0FBQyxJQUFFLENBQUMxQixLQUFLeUIsT0FBTyxHQUFDLEtBQUcsS0FBRztvQkFBRyxJQUFHLENBQUN6QixLQUFLeUIsT0FBTyxHQUFDLE1BQUl6QixLQUFLMEIsT0FBTyxHQUFDLEtBQUcsS0FBRyxHQUFFO3dCQUFDdFc7b0JBQUs7b0JBQUMsSUFBRyxDQUFDQSxLQUFJO3dCQUFDQSxNQUFJO3dCQUFHLElBQUlvWSxRQUFNLENBQUN4RCxLQUFLeUIsT0FBTyxHQUFDLElBQUV6QixLQUFLMEIsT0FBTyxHQUFDLEtBQUc7d0JBQUUsSUFBRzhCLFNBQU8sS0FBR0EsU0FBTyxLQUFHaEUsV0FBV1EsS0FBS3dCLE9BQU8sR0FBQyxNQUFJLElBQUc7NEJBQUNwVzt3QkFBSztvQkFBQyxPQUFNLElBQUdBLE9BQUssSUFBRzt3QkFBQyxJQUFJcVksT0FBSyxDQUFDekQsS0FBS3lCLE9BQU8sR0FBQyxNQUFJekIsS0FBSzBCLE9BQU8sSUFBRTt3QkFBRSxJQUFHK0IsUUFBTSxLQUFJQSxDQUFBQSxRQUFNLEtBQUcsQ0FBQ2pFLFdBQVdRLEtBQUt3QixPQUFPLElBQUdwVyxNQUFJO29CQUFDO29CQUFDLE9BQU9rWCxhQUFhbFgsS0FBSTtnQkFBRTtnQkFBRSxNQUFLNFUsQ0FBQUEsT0FBTUEsS0FBS3lCLE9BQU87Z0JBQUMsTUFBS3pCLENBQUFBO29CQUFPLElBQUlDLE9BQUtELEtBQUswQixPQUFPLEdBQUMsSUFBRSxDQUFDMUIsS0FBS3lCLE9BQU8sR0FBQyxLQUFHO29CQUFFLE9BQU9hLGFBQWFqZCxLQUFLa1ksS0FBSyxDQUFDMEMsT0FBSyxJQUFHO2dCQUFFO2dCQUFFLE1BQUtELENBQUFBLE9BQU0sQ0FBQ0EsS0FBS3dCLE9BQU8sR0FBQyxJQUFHLEVBQUc1akIsUUFBUSxHQUFHMGxCLFNBQVMsQ0FBQztnQkFBRyxNQUFLdEQsQ0FBQUEsT0FBTUEsS0FBS3dCLE9BQU8sR0FBQztnQkFBSyxNQUFLeEIsQ0FBQUE7b0JBQU8sSUFBSTBELE1BQUkxRCxLQUFLNEIsU0FBUztvQkFBQyxJQUFJK0IsUUFBTUQsT0FBSztvQkFBRUEsTUFBSXJlLEtBQUtpWSxHQUFHLENBQUNvRyxPQUFLO29CQUFHQSxNQUFJQSxNQUFJLEtBQUcsTUFBSUEsTUFBSTtvQkFBRyxPQUFNLENBQUNDLFFBQU0sTUFBSSxHQUFFLElBQUc5dEIsT0FBTyxTQUFPNnRCLEtBQUs5a0IsS0FBSyxDQUFDLENBQUM7Z0JBQUU7Z0JBQUUsTUFBS29oQixDQUFBQSxPQUFNQSxLQUFLa0IsT0FBTztnQkFBQyxNQUFLLElBQUk7WUFBRztZQUFFVyxVQUFRQSxRQUFReDRCLE9BQU8sQ0FBQyxPQUFNO1lBQVEsSUFBSSxJQUFJMDRCLFFBQVFzQixrQkFBa0I7Z0JBQUMsSUFBR3hCLFFBQVFobEIsUUFBUSxDQUFDa2xCLE9BQU07b0JBQUNGLFVBQVFBLFFBQVF4NEIsT0FBTyxDQUFDLElBQUkyNEIsT0FBT0QsTUFBSyxNQUFLc0IsaUJBQWlCLENBQUN0QixLQUFLLENBQUMvQjtnQkFBTTtZQUFDO1lBQUM2QixVQUFRQSxRQUFReDRCLE9BQU8sQ0FBQyxTQUFRO1lBQUssSUFBSXU2QixRQUFNM2EsbUJBQW1CNFksU0FBUTtZQUFPLElBQUcrQixNQUFNcDNCLE1BQU0sR0FBQ3UwQixTQUFRO2dCQUFDLE9BQU87WUFBQztZQUFDSCxtQkFBbUJnRCxPQUFNOUM7WUFBRyxPQUFPOEMsTUFBTXAzQixNQUFNLEdBQUM7UUFBQztRQUFFLElBQUlxM0IsY0FBWSxDQUFDL0MsR0FBRUMsU0FBUUMsUUFBT0MsSUFBRzZDLE1BQU1qRCxVQUFVQyxHQUFFQyxTQUFRQyxRQUFPQztRQUFJLElBQUk4QyxXQUFTQyxDQUFBQTtZQUFRLElBQUlybkIsT0FBS3ZWLE1BQU0sQ0FBQyxNQUFJNDhCLE1BQU07WUFBQyxPQUFPcm5CO1FBQUk7UUFBRSxJQUFJc25CLHNCQUFvQnBrQixDQUFBQTtZQUFNLElBQUlySyxPQUFLZ0wsZ0JBQWdCWCxPQUFLO1lBQUUsSUFBSTVKLE1BQUlpdUIsV0FBVzF1QjtZQUFNOEssYUFBYVQsS0FBSTVKLEtBQUlUO1lBQU0sT0FBT1M7UUFBRztRQUFFLElBQUlrdUIsUUFBTSxDQUFDSCxPQUFNSSxZQUFXcnBCLFVBQVNzQixNQUFLZ1c7WUFBUSxJQUFJZ1MsTUFBSTtnQkFBQyxVQUFTeGtCLENBQUFBO29CQUFNLElBQUk1SixNQUFJO29CQUFFLElBQUc0SixRQUFNLFFBQU1BLFFBQU1wWSxhQUFXb1ksUUFBTSxHQUFFO3dCQUFDNUosTUFBSWd1QixvQkFBb0Jwa0I7b0JBQUk7b0JBQUMsT0FBTzVKO2dCQUFHO2dCQUFFLFNBQVF3UyxDQUFBQTtvQkFBTSxJQUFJeFMsTUFBSWl1QixXQUFXemIsSUFBSWpjLE1BQU07b0JBQUVvMEIsbUJBQW1CblksS0FBSXhTO29CQUFLLE9BQU9BO2dCQUFHO1lBQUM7WUFBRSxTQUFTcXVCLG1CQUFtQnJ1QixHQUFHO2dCQUFFLElBQUdtdUIsZUFBYSxVQUFTO29CQUFDLE9BQU85aUIsYUFBYXJMO2dCQUFJO2dCQUFDLElBQUdtdUIsZUFBYSxXQUFVLE9BQU9HLFFBQVF0dUI7Z0JBQUssT0FBT0E7WUFBRztZQUFDLElBQUkwRyxPQUFLb25CLFNBQVNDO1lBQU8sSUFBSVEsUUFBTSxFQUFFO1lBQUMsSUFBSTltQixRQUFNO1lBQUUsSUFBR3JCLE1BQUs7Z0JBQUMsSUFBSSxJQUFJaEosSUFBRSxHQUFFQSxJQUFFZ0osS0FBSzdQLE1BQU0sRUFBQzZHLElBQUk7b0JBQUMsSUFBSW94QixZQUFVSixHQUFHLENBQUN0cEIsUUFBUSxDQUFDMUgsRUFBRSxDQUFDO29CQUFDLElBQUdveEIsV0FBVTt3QkFBQyxJQUFHL21CLFVBQVEsR0FBRUEsUUFBTWduQjt3QkFBWUYsS0FBSyxDQUFDbnhCLEVBQUUsR0FBQ294QixVQUFVcG9CLElBQUksQ0FBQ2hKLEVBQUU7b0JBQUMsT0FBSzt3QkFBQ214QixLQUFLLENBQUNueEIsRUFBRSxHQUFDZ0osSUFBSSxDQUFDaEosRUFBRTtvQkFBQTtnQkFBQztZQUFDO1lBQUMsSUFBSTRDLE1BQUkwRyxLQUFLaEUsS0FBSyxDQUFDLE1BQUs2ckI7WUFBTyxTQUFTRyxPQUFPMXVCLEdBQUc7Z0JBQUUsSUFBR3lILFVBQVEsR0FBRWtuQixhQUFhbG5CO2dCQUFPLE9BQU80bUIsbUJBQW1CcnVCO1lBQUk7WUFBQ0EsTUFBSTB1QixPQUFPMXVCO1lBQUssT0FBT0E7UUFBRztRQUFFdkQsZ0JBQWN0TCxNQUFNLENBQUMsZ0JBQWdCLEdBQUMsTUFBTXNMLHNCQUFzQmlMO1lBQU1yRSxZQUFZMUcsT0FBTyxDQUFDO2dCQUFDLEtBQUssQ0FBQ0E7Z0JBQVMsSUFBSSxDQUFDcUMsSUFBSSxHQUFDO1lBQWU7UUFBQztRQUFFVTtRQUF3QlEsZUFBYS9PLE1BQU0sQ0FBQyxlQUFlLEdBQUMsTUFBTStPLHFCQUFxQndIO1lBQU1yRSxZQUFZMUcsT0FBTyxDQUFDO2dCQUFDLEtBQUssQ0FBQ0E7Z0JBQVMsSUFBSSxDQUFDcUMsSUFBSSxHQUFDO1lBQWM7UUFBQztRQUFFNkI7UUFBc0JnQjtRQUFhK0YsbUJBQWlCelcsTUFBTSxDQUFDLG1CQUFtQixHQUFDa1csWUFBWUssT0FBTTtRQUFvQixJQUFJZ1csU0FBTyxTQUFTdkgsTUFBTSxFQUFDblgsSUFBSSxFQUFDb1gsSUFBSSxFQUFDL0IsSUFBSTtZQUFFLElBQUcsQ0FBQzhCLFFBQU87Z0JBQUNBLFNBQU8sSUFBSTtZQUFBO1lBQUMsSUFBSSxDQUFDQSxNQUFNLEdBQUNBO1lBQU8sSUFBSSxDQUFDRixLQUFLLEdBQUNFLE9BQU9GLEtBQUs7WUFBQyxJQUFJLENBQUMyRyxPQUFPLEdBQUM7WUFBSyxJQUFJLENBQUNsbEIsRUFBRSxHQUFDZCxHQUFHa2xCLFNBQVM7WUFBRyxJQUFJLENBQUM5YyxJQUFJLEdBQUNBO1lBQUssSUFBSSxDQUFDb1gsSUFBSSxHQUFDQTtZQUFLLElBQUksQ0FBQ0ksUUFBUSxHQUFDLENBQUM7WUFBRSxJQUFJLENBQUN2QyxVQUFVLEdBQUMsQ0FBQztZQUFFLElBQUksQ0FBQ0ksSUFBSSxHQUFDQTtRQUFJO1FBQUUsSUFBSXVhLFdBQVMsTUFBSTtRQUFHLElBQUlDLFlBQVU7UUFBSTc4QixPQUFPOHNCLGdCQUFnQixDQUFDcEIsT0FBTzNjLFNBQVMsRUFBQztZQUFDbEMsTUFBSztnQkFBQ21DLEtBQUk7b0JBQVcsT0FBTSxDQUFDLElBQUksQ0FBQ29WLElBQUksR0FBQ3dZLFFBQU8sTUFBS0E7Z0JBQVE7Z0JBQUV4VyxLQUFJLFNBQVNqRCxHQUFHO29CQUFFQSxNQUFJLElBQUksQ0FBQ2lCLElBQUksSUFBRXdZLFdBQVMsSUFBSSxDQUFDeFksSUFBSSxJQUFFLENBQUN3WTtnQkFBUTtZQUFDO1lBQUU5dkIsT0FBTTtnQkFBQ2tDLEtBQUk7b0JBQVcsT0FBTSxDQUFDLElBQUksQ0FBQ29WLElBQUksR0FBQ3lZLFNBQVEsTUFBS0E7Z0JBQVM7Z0JBQUV6VyxLQUFJLFNBQVNqRCxHQUFHO29CQUFFQSxNQUFJLElBQUksQ0FBQ2lCLElBQUksSUFBRXlZLFlBQVUsSUFBSSxDQUFDelksSUFBSSxJQUFFLENBQUN5WTtnQkFBUztZQUFDO1lBQUUzSixVQUFTO2dCQUFDbGtCLEtBQUk7b0JBQVcsT0FBT3BLLEdBQUc0Z0IsS0FBSyxDQUFDLElBQUksQ0FBQ3BCLElBQUk7Z0JBQUM7WUFBQztZQUFFNk8sVUFBUztnQkFBQ2prQixLQUFJO29CQUFXLE9BQU9wSyxHQUFHaWhCLFFBQVEsQ0FBQyxJQUFJLENBQUN6QixJQUFJO2dCQUFDO1lBQUM7UUFBQztRQUFHeGYsR0FBRzhtQixNQUFNLEdBQUNBO1FBQU85bUIsR0FBR2s0QixtQkFBbUIsR0FBQzFUO1FBQXVCeGtCLEdBQUdzdEIsVUFBVTtRQUFHLElBQUl2cUIsY0FBWTtZQUFDa1MsR0FBRS9QO1lBQWErakIsR0FBRWppQjtZQUE4QnVULEdBQUU5UjtZQUF5QjB2QixHQUFFdHVCO1lBQXVCdXVCLEdBQUU5c0I7WUFBd0Irc0IsR0FBRWhzQjtZQUF1Qm9ELEdBQUV2QztZQUE2Qm9yQixHQUFFNXFCO1lBQXdCc2MsR0FBRXRZO1lBQTJCdFEsR0FBRTZRO1lBQTBCcFQsR0FBRTJUO1lBQThCK2xCLEdBQUU3akI7WUFBNkI4akIsR0FBRW5pQjtZQUE4Qm9pQixHQUFFNWhCO1lBQThCeE4sR0FBRTJOO1lBQXNDK0QsR0FBRTVEO1lBQXVCM1EsR0FBRTZRO1lBQU9lLEdBQUVkO1lBQXNCaEUsR0FBRXlFO1lBQXdCL0osR0FBRWlqQjtZQUFhZ0QsR0FBRTNDO1lBQW1Cb0gsR0FBRWpIO1lBQVVrSCxHQUFFN0c7WUFBUzNwQixHQUFFaXFCO1lBQVN3RyxHQUFFbEc7WUFBVW1HLEdBQUU3QjtRQUFXO1FBQUUsSUFBSTl6QixjQUFZTDtRQUFhLElBQUlpMkIscUJBQW1CLElBQUksQ0FBQ0EscUJBQW1CNTFCLFdBQVcsQ0FBQyxJQUFJO1FBQUksSUFBSTRKLGlCQUFlaXNCLENBQUFBLEtBQUksQ0FBQ2pzQixpQkFBZTVKLFdBQVcsQ0FBQyxJQUFJLEVBQUU2MUI7UUFBSSxJQUFJQyxvQkFBa0IsSUFBSSxDQUFDQSxvQkFBa0I5MUIsV0FBVyxDQUFDLG1CQUFtQjtRQUFJLElBQUlvUyxVQUFRL2EsTUFBTSxDQUFDLFVBQVUsR0FBQ3crQixDQUFBQSxLQUFJLENBQUN6akIsVUFBUS9hLE1BQU0sQ0FBQyxVQUFVLEdBQUMySSxXQUFXLENBQUMsSUFBSSxFQUFFNjFCO1FBQUksSUFBSWhzQixRQUFNeFMsTUFBTSxDQUFDLFFBQVEsR0FBQ3crQixDQUFBQSxLQUFJLENBQUNoc0IsUUFBTXhTLE1BQU0sQ0FBQyxRQUFRLEdBQUMySSxXQUFXLENBQUMsSUFBSSxFQUFFNjFCO1FBQUksSUFBSWxCLFlBQVUsSUFBSSxDQUFDQSxZQUFVMzBCLFdBQVcsQ0FBQyxJQUFJO1FBQUksSUFBSTYwQixlQUFhZ0IsQ0FBQUEsS0FBSSxDQUFDaEIsZUFBYTcwQixXQUFXLENBQUMsSUFBSSxFQUFFNjFCO1FBQUksSUFBSTFCLGFBQVcwQixDQUFBQSxLQUFJLENBQUMxQixhQUFXbjBCLFdBQVcsQ0FBQyxJQUFJLEVBQUU2MUI7UUFBSSxJQUFJRSxzQ0FBb0NGLENBQUFBLEtBQUksQ0FBQ0Usc0NBQW9DLzFCLFdBQVcsQ0FBQyxxQ0FBcUMsRUFBRTYxQjtRQUFJLElBQUlqMEIseUJBQXVCaTBCLENBQUFBLEtBQUksQ0FBQ2owQix5QkFBdUI1QixXQUFXLENBQUMsSUFBSSxFQUFFNjFCO1FBQUksSUFBSUcsZUFBYTMrQixNQUFNLENBQUMsZUFBZSxHQUFDLENBQUN3K0IsSUFBR0ksSUFBR0MsSUFBR0MsSUFBR0MsS0FBSyxDQUFDSixlQUFhMytCLE1BQU0sQ0FBQyxlQUFlLEdBQUMySSxXQUFXLENBQUMsSUFBSSxFQUFFNjFCLElBQUdJLElBQUdDLElBQUdDLElBQUdDO1FBQUksSUFBSUMsaUJBQWVoL0IsTUFBTSxDQUFDLGlCQUFpQixHQUFDLENBQUN3K0IsSUFBR0ksSUFBR0MsSUFBR0MsSUFBR0MsSUFBR0UsSUFBR0MsS0FBSyxDQUFDRixpQkFBZWgvQixNQUFNLENBQUMsaUJBQWlCLEdBQUMySSxXQUFXLENBQUMsSUFBSSxFQUFFNjFCLElBQUdJLElBQUdDLElBQUdDLElBQUdDLElBQUdFLElBQUdDO1FBQUksSUFBSUMsaUJBQWVuL0IsTUFBTSxDQUFDLGlCQUFpQixHQUFDLENBQUN3K0IsSUFBR0ksSUFBR0MsSUFBR0MsSUFBR0MsSUFBR0UsSUFBR0MsS0FBSyxDQUFDQyxpQkFBZW4vQixNQUFNLENBQUMsaUJBQWlCLEdBQUMySSxXQUFXLENBQUMsSUFBSSxFQUFFNjFCLElBQUdJLElBQUdDLElBQUdDLElBQUdDLElBQUdFLElBQUdDO1FBQUksSUFBSUUsa0JBQWdCcC9CLE1BQU0sQ0FBQyxrQkFBa0IsR0FBQyxDQUFDdytCLElBQUdJLElBQUdDLElBQUdDLElBQUdDLElBQUdFLElBQUdDLElBQUdHLElBQUdDLEtBQUssQ0FBQ0Ysa0JBQWdCcC9CLE1BQU0sQ0FBQyxrQkFBa0IsR0FBQzJJLFdBQVcsQ0FBQyxJQUFJLEVBQUU2MUIsSUFBR0ksSUFBR0MsSUFBR0MsSUFBR0MsSUFBR0UsSUFBR0MsSUFBR0csSUFBR0M7UUFBSSxJQUFJQyxtQkFBaUJ2L0IsTUFBTSxDQUFDLG1CQUFtQixHQUFDLENBQUN3K0IsSUFBR0ksSUFBR0MsSUFBR0MsSUFBR0MsSUFBR0UsSUFBR0MsSUFBR0csSUFBR0MsSUFBR0UsS0FBSyxDQUFDRCxtQkFBaUJ2L0IsTUFBTSxDQUFDLG1CQUFtQixHQUFDMkksV0FBVyxDQUFDLElBQUksRUFBRTYxQixJQUFHSSxJQUFHQyxJQUFHQyxJQUFHQyxJQUFHRSxJQUFHQyxJQUFHRyxJQUFHQyxJQUFHRTtRQUFJeC9CLE1BQU0sQ0FBQyxRQUFRLEdBQUMrOEI7UUFBTSxJQUFJMEM7UUFBVXA1Qix3QkFBc0IsU0FBU3E1QjtZQUFZLElBQUcsQ0FBQ0QsV0FBVUU7WUFBTSxJQUFHLENBQUNGLFdBQVVwNUIsd0JBQXNCcTVCO1FBQVM7UUFBRSxTQUFTQztZQUFNLElBQUd4NUIsa0JBQWdCLEdBQUU7Z0JBQUM7WUFBTTtZQUFDaEI7WUFBUyxJQUFHZ0Isa0JBQWdCLEdBQUU7Z0JBQUM7WUFBTTtZQUFDLFNBQVN5NUI7Z0JBQVEsSUFBR0gsV0FBVTtnQkFBT0EsWUFBVTtnQkFBS3ovQixNQUFNLENBQUMsWUFBWSxHQUFDO2dCQUFLLElBQUd3RCxPQUFNO2dCQUFPZ0M7Z0JBQWNqRixvQkFBb0JQO2dCQUFRLElBQUdBLE1BQU0sQ0FBQyx1QkFBdUIsRUFBQ0EsTUFBTSxDQUFDLHVCQUF1QjtnQkFBRzhGO1lBQVM7WUFBQyxJQUFHOUYsTUFBTSxDQUFDLFlBQVksRUFBQztnQkFBQ0EsTUFBTSxDQUFDLFlBQVksQ0FBQztnQkFBYzYvQixXQUFXO29CQUFXQSxXQUFXO3dCQUFXNy9CLE1BQU0sQ0FBQyxZQUFZLENBQUM7b0JBQUcsR0FBRTtvQkFBRzQvQjtnQkFBTyxHQUFFO1lBQUUsT0FBSztnQkFBQ0E7WUFBTztRQUFDO1FBQUMsSUFBRzUvQixNQUFNLENBQUMsVUFBVSxFQUFDO1lBQUMsSUFBRyxPQUFPQSxNQUFNLENBQUMsVUFBVSxJQUFFLFlBQVdBLE1BQU0sQ0FBQyxVQUFVLEdBQUM7Z0JBQUNBLE1BQU0sQ0FBQyxVQUFVO2FBQUM7WUFBQyxNQUFNQSxNQUFNLENBQUMsVUFBVSxDQUFDb0YsTUFBTSxHQUFDLEVBQUU7Z0JBQUNwRixNQUFNLENBQUMsVUFBVSxDQUFDK0ssR0FBRztZQUFJO1FBQUM7UUFBQzQwQjtRQUd2ajJGLE9BQU9yL0IsVUFBVXcvQixLQUFLO0lBQ3hCO0FBRUE7O0FBRUEsK0RBQWU5L0IsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNwbGluZXRvb2wvcnVudGltZS9idWlsZC9ib29sZWFuLmpzPzY5YjEiXSwic291cmNlc0NvbnRlbnQiOlsiXG52YXIgTW9kdWxlID0gKCgpID0+IHtcbiAgdmFyIF9zY3JpcHREaXIgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmN1cnJlbnRTY3JpcHQgPyBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyA6IHVuZGVmaW5lZDtcbiAgXG4gIHJldHVybiAoXG5mdW5jdGlvbihtb2R1bGVBcmcgPSB7fSkge1xuXG52YXIgTW9kdWxlPW1vZHVsZUFyZzt2YXIgcmVhZHlQcm9taXNlUmVzb2x2ZSxyZWFkeVByb21pc2VSZWplY3Q7TW9kdWxlW1wicmVhZHlcIl09bmV3IFByb21pc2UoKHJlc29sdmUscmVqZWN0KT0+e3JlYWR5UHJvbWlzZVJlc29sdmU9cmVzb2x2ZTtyZWFkeVByb21pc2VSZWplY3Q9cmVqZWN0fSk7dmFyIG1vZHVsZU92ZXJyaWRlcz1PYmplY3QuYXNzaWduKHt9LE1vZHVsZSk7dmFyIGFyZ3VtZW50c189W107dmFyIHRoaXNQcm9ncmFtPVwiLi90aGlzLnByb2dyYW1cIjt2YXIgcXVpdF89KHN0YXR1cyx0b1Rocm93KT0+e3Rocm93IHRvVGhyb3d9O3ZhciBFTlZJUk9OTUVOVF9JU19XRUI9dHJ1ZTt2YXIgRU5WSVJPTk1FTlRfSVNfV09SS0VSPWZhbHNlO3ZhciBzY3JpcHREaXJlY3Rvcnk9XCJcIjtmdW5jdGlvbiBsb2NhdGVGaWxlKHBhdGgpe2lmKE1vZHVsZVtcImxvY2F0ZUZpbGVcIl0pe3JldHVybiBNb2R1bGVbXCJsb2NhdGVGaWxlXCJdKHBhdGgsc2NyaXB0RGlyZWN0b3J5KX1yZXR1cm4gc2NyaXB0RGlyZWN0b3J5K3BhdGh9dmFyIHJlYWRfLHJlYWRBc3luYyxyZWFkQmluYXJ5O2lmKEVOVklST05NRU5UX0lTX1dFQnx8RU5WSVJPTk1FTlRfSVNfV09SS0VSKXtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3NjcmlwdERpcmVjdG9yeT1zZWxmLmxvY2F0aW9uLmhyZWZ9ZWxzZSBpZih0eXBlb2YgZG9jdW1lbnQhPVwidW5kZWZpbmVkXCImJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3NjcmlwdERpcmVjdG9yeT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY31pZihfc2NyaXB0RGlyKXtzY3JpcHREaXJlY3Rvcnk9X3NjcmlwdERpcn1pZihzY3JpcHREaXJlY3RvcnkuaW5kZXhPZihcImJsb2I6XCIpIT09MCl7c2NyaXB0RGlyZWN0b3J5PXNjcmlwdERpcmVjdG9yeS5zdWJzdHIoMCxzY3JpcHREaXJlY3RvcnkucmVwbGFjZSgvWz8jXS4qLyxcIlwiKS5sYXN0SW5kZXhPZihcIi9cIikrMSl9ZWxzZXtzY3JpcHREaXJlY3Rvcnk9XCJcIn17cmVhZF89dXJsPT57dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5zZW5kKG51bGwpO3JldHVybiB4aHIucmVzcG9uc2VUZXh0fTtpZihFTlZJUk9OTUVOVF9JU19XT1JLRVIpe3JlYWRCaW5hcnk9dXJsPT57dmFyIHhocj1uZXcgWE1MSHR0cFJlcXVlc3Q7eGhyLm9wZW4oXCJHRVRcIix1cmwsZmFsc2UpO3hoci5yZXNwb25zZVR5cGU9XCJhcnJheWJ1ZmZlclwiO3hoci5zZW5kKG51bGwpO3JldHVybiBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpfX1yZWFkQXN5bmM9KHVybCxvbmxvYWQsb25lcnJvcik9Pnt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCx0cnVlKTt4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjt4aHIub25sb2FkPSgpPT57aWYoeGhyLnN0YXR1cz09MjAwfHx4aHIuc3RhdHVzPT0wJiZ4aHIucmVzcG9uc2Upe29ubG9hZCh4aHIucmVzcG9uc2UpO3JldHVybn1vbmVycm9yKCl9O3hoci5vbmVycm9yPW9uZXJyb3I7eGhyLnNlbmQobnVsbCl9fX1lbHNle312YXIgb3V0PU1vZHVsZVtcInByaW50XCJdfHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO3ZhciBlcnI9TW9kdWxlW1wicHJpbnRFcnJcIl18fGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtPYmplY3QuYXNzaWduKE1vZHVsZSxtb2R1bGVPdmVycmlkZXMpO21vZHVsZU92ZXJyaWRlcz1udWxsO2lmKE1vZHVsZVtcImFyZ3VtZW50c1wiXSlhcmd1bWVudHNfPU1vZHVsZVtcImFyZ3VtZW50c1wiXTtpZihNb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXSl0aGlzUHJvZ3JhbT1Nb2R1bGVbXCJ0aGlzUHJvZ3JhbVwiXTtpZihNb2R1bGVbXCJxdWl0XCJdKXF1aXRfPU1vZHVsZVtcInF1aXRcIl07dmFyIHdhc21CaW5hcnk7aWYoTW9kdWxlW1wid2FzbUJpbmFyeVwiXSl3YXNtQmluYXJ5PU1vZHVsZVtcIndhc21CaW5hcnlcIl07aWYodHlwZW9mIFdlYkFzc2VtYmx5IT1cIm9iamVjdFwiKXthYm9ydChcIm5vIG5hdGl2ZSB3YXNtIHN1cHBvcnQgZGV0ZWN0ZWRcIil9dmFyIHdhc21NZW1vcnk7dmFyIEFCT1JUPWZhbHNlO3ZhciBFWElUU1RBVFVTO2Z1bmN0aW9uIGFzc2VydChjb25kaXRpb24sdGV4dCl7aWYoIWNvbmRpdGlvbil7YWJvcnQodGV4dCl9fXZhciBIRUFQOCxIRUFQVTgsSEVBUDE2LEhFQVBVMTYsSEVBUDMyLEhFQVBVMzIsSEVBUEYzMixIRUFQRjY0O2Z1bmN0aW9uIHVwZGF0ZU1lbW9yeVZpZXdzKCl7dmFyIGI9d2FzbU1lbW9yeS5idWZmZXI7TW9kdWxlW1wiSEVBUDhcIl09SEVBUDg9bmV3IEludDhBcnJheShiKTtNb2R1bGVbXCJIRUFQMTZcIl09SEVBUDE2PW5ldyBJbnQxNkFycmF5KGIpO01vZHVsZVtcIkhFQVBVOFwiXT1IRUFQVTg9bmV3IFVpbnQ4QXJyYXkoYik7TW9kdWxlW1wiSEVBUFUxNlwiXT1IRUFQVTE2PW5ldyBVaW50MTZBcnJheShiKTtNb2R1bGVbXCJIRUFQMzJcIl09SEVBUDMyPW5ldyBJbnQzMkFycmF5KGIpO01vZHVsZVtcIkhFQVBVMzJcIl09SEVBUFUzMj1uZXcgVWludDMyQXJyYXkoYik7TW9kdWxlW1wiSEVBUEYzMlwiXT1IRUFQRjMyPW5ldyBGbG9hdDMyQXJyYXkoYik7TW9kdWxlW1wiSEVBUEY2NFwiXT1IRUFQRjY0PW5ldyBGbG9hdDY0QXJyYXkoYil9dmFyIF9fQVRQUkVSVU5fXz1bXTt2YXIgX19BVElOSVRfXz1bXTt2YXIgX19BVFBPU1RSVU5fXz1bXTt2YXIgcnVudGltZUluaXRpYWxpemVkPWZhbHNlO2Z1bmN0aW9uIHByZVJ1bigpe2lmKE1vZHVsZVtcInByZVJ1blwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInByZVJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInByZVJ1blwiXT1bTW9kdWxlW1wicHJlUnVuXCJdXTt3aGlsZShNb2R1bGVbXCJwcmVSdW5cIl0ubGVuZ3RoKXthZGRPblByZVJ1bihNb2R1bGVbXCJwcmVSdW5cIl0uc2hpZnQoKSl9fWNhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRQUkVSVU5fXyl9ZnVuY3Rpb24gaW5pdFJ1bnRpbWUoKXtydW50aW1lSW5pdGlhbGl6ZWQ9dHJ1ZTtpZighTW9kdWxlW1wibm9GU0luaXRcIl0mJiFGUy5pbml0LmluaXRpYWxpemVkKUZTLmluaXQoKTtGUy5pZ25vcmVQZXJtaXNzaW9ucz1mYWxzZTtUVFkuaW5pdCgpO2NhbGxSdW50aW1lQ2FsbGJhY2tzKF9fQVRJTklUX18pfWZ1bmN0aW9uIHBvc3RSdW4oKXtpZihNb2R1bGVbXCJwb3N0UnVuXCJdKXtpZih0eXBlb2YgTW9kdWxlW1wicG9zdFJ1blwiXT09XCJmdW5jdGlvblwiKU1vZHVsZVtcInBvc3RSdW5cIl09W01vZHVsZVtcInBvc3RSdW5cIl1dO3doaWxlKE1vZHVsZVtcInBvc3RSdW5cIl0ubGVuZ3RoKXthZGRPblBvc3RSdW4oTW9kdWxlW1wicG9zdFJ1blwiXS5zaGlmdCgpKX19Y2FsbFJ1bnRpbWVDYWxsYmFja3MoX19BVFBPU1RSVU5fXyl9ZnVuY3Rpb24gYWRkT25QcmVSdW4oY2Ipe19fQVRQUkVSVU5fXy51bnNoaWZ0KGNiKX1mdW5jdGlvbiBhZGRPbkluaXQoY2Ipe19fQVRJTklUX18udW5zaGlmdChjYil9ZnVuY3Rpb24gYWRkT25Qb3N0UnVuKGNiKXtfX0FUUE9TVFJVTl9fLnVuc2hpZnQoY2IpfXZhciBydW5EZXBlbmRlbmNpZXM9MDt2YXIgcnVuRGVwZW5kZW5jeVdhdGNoZXI9bnVsbDt2YXIgZGVwZW5kZW5jaWVzRnVsZmlsbGVkPW51bGw7ZnVuY3Rpb24gZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeShpZCl7cmV0dXJuIGlkfWZ1bmN0aW9uIGFkZFJ1bkRlcGVuZGVuY3koaWQpe3J1bkRlcGVuZGVuY2llcysrO2lmKE1vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0pe01vZHVsZVtcIm1vbml0b3JSdW5EZXBlbmRlbmNpZXNcIl0ocnVuRGVwZW5kZW5jaWVzKX19ZnVuY3Rpb24gcmVtb3ZlUnVuRGVwZW5kZW5jeShpZCl7cnVuRGVwZW5kZW5jaWVzLS07aWYoTW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXSl7TW9kdWxlW1wibW9uaXRvclJ1bkRlcGVuZGVuY2llc1wiXShydW5EZXBlbmRlbmNpZXMpfWlmKHJ1bkRlcGVuZGVuY2llcz09MCl7aWYocnVuRGVwZW5kZW5jeVdhdGNoZXIhPT1udWxsKXtjbGVhckludGVydmFsKHJ1bkRlcGVuZGVuY3lXYXRjaGVyKTtydW5EZXBlbmRlbmN5V2F0Y2hlcj1udWxsfWlmKGRlcGVuZGVuY2llc0Z1bGZpbGxlZCl7dmFyIGNhbGxiYWNrPWRlcGVuZGVuY2llc0Z1bGZpbGxlZDtkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9bnVsbDtjYWxsYmFjaygpfX19ZnVuY3Rpb24gYWJvcnQod2hhdCl7aWYoTW9kdWxlW1wib25BYm9ydFwiXSl7TW9kdWxlW1wib25BYm9ydFwiXSh3aGF0KX13aGF0PVwiQWJvcnRlZChcIit3aGF0K1wiKVwiO2Vycih3aGF0KTtBQk9SVD10cnVlO0VYSVRTVEFUVVM9MTt3aGF0Kz1cIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby5cIjt2YXIgZT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKHdoYXQpO3JlYWR5UHJvbWlzZVJlamVjdChlKTt0aHJvdyBlfXZhciBkYXRhVVJJUHJlZml4PVwiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LFwiO3ZhciBpc0RhdGFVUkk9ZmlsZW5hbWU9PmZpbGVuYW1lLnN0YXJ0c1dpdGgoZGF0YVVSSVByZWZpeCk7dmFyIHdhc21CaW5hcnlGaWxlO3dhc21CaW5hcnlGaWxlPVwiYm9vbGVhbi53YXNtXCI7aWYoIWlzRGF0YVVSSSh3YXNtQmluYXJ5RmlsZSkpe3dhc21CaW5hcnlGaWxlPWxvY2F0ZUZpbGUod2FzbUJpbmFyeUZpbGUpfWZ1bmN0aW9uIGdldEJpbmFyeVN5bmMoZmlsZSl7aWYoZmlsZT09d2FzbUJpbmFyeUZpbGUmJndhc21CaW5hcnkpe3JldHVybiBuZXcgVWludDhBcnJheSh3YXNtQmluYXJ5KX1pZihyZWFkQmluYXJ5KXtyZXR1cm4gcmVhZEJpbmFyeShmaWxlKX10aHJvd1wiYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWRcIn1mdW5jdGlvbiBnZXRCaW5hcnlQcm9taXNlKGJpbmFyeUZpbGUpe2lmKCF3YXNtQmluYXJ5JiYoRU5WSVJPTk1FTlRfSVNfV0VCfHxFTlZJUk9OTUVOVF9JU19XT1JLRVIpKXtpZih0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZldGNoKGJpbmFyeUZpbGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4ocmVzcG9uc2U9PntpZighcmVzcG9uc2VbXCJva1wiXSl7dGhyb3dcImZhaWxlZCB0byBsb2FkIHdhc20gYmluYXJ5IGZpbGUgYXQgJ1wiK2JpbmFyeUZpbGUrXCInXCJ9cmV0dXJuIHJlc3BvbnNlW1wiYXJyYXlCdWZmZXJcIl0oKX0pLmNhdGNoKCgpPT5nZXRCaW5hcnlTeW5jKGJpbmFyeUZpbGUpKX19cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCk9PmdldEJpbmFyeVN5bmMoYmluYXJ5RmlsZSkpfWZ1bmN0aW9uIGluc3RhbnRpYXRlQXJyYXlCdWZmZXIoYmluYXJ5RmlsZSxpbXBvcnRzLHJlY2VpdmVyKXtyZXR1cm4gZ2V0QmluYXJ5UHJvbWlzZShiaW5hcnlGaWxlKS50aGVuKGJpbmFyeT0+V2ViQXNzZW1ibHkuaW5zdGFudGlhdGUoYmluYXJ5LGltcG9ydHMpKS50aGVuKGluc3RhbmNlPT5pbnN0YW5jZSkudGhlbihyZWNlaXZlcixyZWFzb249PntlcnIoYGZhaWxlZCB0byBhc3luY2hyb25vdXNseSBwcmVwYXJlIHdhc206ICR7cmVhc29ufWApO2Fib3J0KHJlYXNvbil9KX1mdW5jdGlvbiBpbnN0YW50aWF0ZUFzeW5jKGJpbmFyeSxiaW5hcnlGaWxlLGltcG9ydHMsY2FsbGJhY2spe2lmKCFiaW5hcnkmJnR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZz09XCJmdW5jdGlvblwiJiYhaXNEYXRhVVJJKGJpbmFyeUZpbGUpJiZ0eXBlb2YgZmV0Y2g9PVwiZnVuY3Rpb25cIil7cmV0dXJuIGZldGNoKGJpbmFyeUZpbGUse2NyZWRlbnRpYWxzOlwic2FtZS1vcmlnaW5cIn0pLnRoZW4ocmVzcG9uc2U9Pnt2YXIgcmVzdWx0PVdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlU3RyZWFtaW5nKHJlc3BvbnNlLGltcG9ydHMpO3JldHVybiByZXN1bHQudGhlbihjYWxsYmFjayxmdW5jdGlvbihyZWFzb24pe2Vycihgd2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICR7cmVhc29ufWApO2VycihcImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uXCIpO3JldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl9KX0pfXJldHVybiBpbnN0YW50aWF0ZUFycmF5QnVmZmVyKGJpbmFyeUZpbGUsaW1wb3J0cyxjYWxsYmFjayl9ZnVuY3Rpb24gY3JlYXRlV2FzbSgpe3ZhciBpbmZvPXtcImFcIjp3YXNtSW1wb3J0c307ZnVuY3Rpb24gcmVjZWl2ZUluc3RhbmNlKGluc3RhbmNlLG1vZHVsZSl7d2FzbUV4cG9ydHM9aW5zdGFuY2UuZXhwb3J0czt3YXNtTWVtb3J5PXdhc21FeHBvcnRzW1wiQVwiXTt1cGRhdGVNZW1vcnlWaWV3cygpO3dhc21UYWJsZT13YXNtRXhwb3J0c1tcIkNcIl07YWRkT25Jbml0KHdhc21FeHBvcnRzW1wiQlwiXSk7cmVtb3ZlUnVuRGVwZW5kZW5jeShcIndhc20taW5zdGFudGlhdGVcIik7cmV0dXJuIHdhc21FeHBvcnRzfWFkZFJ1bkRlcGVuZGVuY3koXCJ3YXNtLWluc3RhbnRpYXRlXCIpO2Z1bmN0aW9uIHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KHJlc3VsdCl7cmVjZWl2ZUluc3RhbmNlKHJlc3VsdFtcImluc3RhbmNlXCJdKX1pZihNb2R1bGVbXCJpbnN0YW50aWF0ZVdhc21cIl0pe3RyeXtyZXR1cm4gTW9kdWxlW1wiaW5zdGFudGlhdGVXYXNtXCJdKGluZm8scmVjZWl2ZUluc3RhbmNlKX1jYXRjaChlKXtlcnIoYE1vZHVsZS5pbnN0YW50aWF0ZVdhc20gY2FsbGJhY2sgZmFpbGVkIHdpdGggZXJyb3I6ICR7ZX1gKTtyZWFkeVByb21pc2VSZWplY3QoZSl9fWluc3RhbnRpYXRlQXN5bmMod2FzbUJpbmFyeSx3YXNtQmluYXJ5RmlsZSxpbmZvLHJlY2VpdmVJbnN0YW50aWF0aW9uUmVzdWx0KS5jYXRjaChyZWFkeVByb21pc2VSZWplY3QpO3JldHVybnt9fXZhciB0ZW1wRG91YmxlO3ZhciB0ZW1wSTY0O3ZhciBjYWxsUnVudGltZUNhbGxiYWNrcz1jYWxsYmFja3M9Pnt3aGlsZShjYWxsYmFja3MubGVuZ3RoPjApe2NhbGxiYWNrcy5zaGlmdCgpKE1vZHVsZSl9fTt2YXIgbm9FeGl0UnVudGltZT1Nb2R1bGVbXCJub0V4aXRSdW50aW1lXCJdfHx0cnVlO2Z1bmN0aW9uIEV4Y2VwdGlvbkluZm8oZXhjUHRyKXt0aGlzLmV4Y1B0cj1leGNQdHI7dGhpcy5wdHI9ZXhjUHRyLTI0O3RoaXMuc2V0X3R5cGU9ZnVuY3Rpb24odHlwZSl7SEVBUFUzMlt0aGlzLnB0cis0Pj4yXT10eXBlfTt0aGlzLmdldF90eXBlPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIrND4+Ml19O3RoaXMuc2V0X2Rlc3RydWN0b3I9ZnVuY3Rpb24oZGVzdHJ1Y3Rvcil7SEVBUFUzMlt0aGlzLnB0cis4Pj4yXT1kZXN0cnVjdG9yfTt0aGlzLmdldF9kZXN0cnVjdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIEhFQVBVMzJbdGhpcy5wdHIrOD4+Ml19O3RoaXMuc2V0X2NhdWdodD1mdW5jdGlvbihjYXVnaHQpe2NhdWdodD1jYXVnaHQ/MTowO0hFQVA4W3RoaXMucHRyKzEyPj4wXT1jYXVnaHR9O3RoaXMuZ2V0X2NhdWdodD1mdW5jdGlvbigpe3JldHVybiBIRUFQOFt0aGlzLnB0cisxMj4+MF0hPTB9O3RoaXMuc2V0X3JldGhyb3duPWZ1bmN0aW9uKHJldGhyb3duKXtyZXRocm93bj1yZXRocm93bj8xOjA7SEVBUDhbdGhpcy5wdHIrMTM+PjBdPXJldGhyb3dufTt0aGlzLmdldF9yZXRocm93bj1mdW5jdGlvbigpe3JldHVybiBIRUFQOFt0aGlzLnB0cisxMz4+MF0hPTB9O3RoaXMuaW5pdD1mdW5jdGlvbih0eXBlLGRlc3RydWN0b3Ipe3RoaXMuc2V0X2FkanVzdGVkX3B0cigwKTt0aGlzLnNldF90eXBlKHR5cGUpO3RoaXMuc2V0X2Rlc3RydWN0b3IoZGVzdHJ1Y3Rvcil9O3RoaXMuc2V0X2FkanVzdGVkX3B0cj1mdW5jdGlvbihhZGp1c3RlZFB0cil7SEVBUFUzMlt0aGlzLnB0cisxNj4+Ml09YWRqdXN0ZWRQdHJ9O3RoaXMuZ2V0X2FkanVzdGVkX3B0cj1mdW5jdGlvbigpe3JldHVybiBIRUFQVTMyW3RoaXMucHRyKzE2Pj4yXX07dGhpcy5nZXRfZXhjZXB0aW9uX3B0cj1mdW5jdGlvbigpe3ZhciBpc1BvaW50ZXI9X19fY3hhX2lzX3BvaW50ZXJfdHlwZSh0aGlzLmdldF90eXBlKCkpO2lmKGlzUG9pbnRlcil7cmV0dXJuIEhFQVBVMzJbdGhpcy5leGNQdHI+PjJdfXZhciBhZGp1c3RlZD10aGlzLmdldF9hZGp1c3RlZF9wdHIoKTtpZihhZGp1c3RlZCE9PTApcmV0dXJuIGFkanVzdGVkO3JldHVybiB0aGlzLmV4Y1B0cn19dmFyIGV4Y2VwdGlvbkxhc3Q9MDt2YXIgdW5jYXVnaHRFeGNlcHRpb25Db3VudD0wO3ZhciBfX19jeGFfdGhyb3c9KHB0cix0eXBlLGRlc3RydWN0b3IpPT57dmFyIGluZm89bmV3IEV4Y2VwdGlvbkluZm8ocHRyKTtpbmZvLmluaXQodHlwZSxkZXN0cnVjdG9yKTtleGNlcHRpb25MYXN0PXB0cjt1bmNhdWdodEV4Y2VwdGlvbkNvdW50Kys7dGhyb3cgZXhjZXB0aW9uTGFzdH07dmFyIHR1cGxlUmVnaXN0cmF0aW9ucz17fTt2YXIgcnVuRGVzdHJ1Y3RvcnM9ZGVzdHJ1Y3RvcnM9Pnt3aGlsZShkZXN0cnVjdG9ycy5sZW5ndGgpe3ZhciBwdHI9ZGVzdHJ1Y3RvcnMucG9wKCk7dmFyIGRlbD1kZXN0cnVjdG9ycy5wb3AoKTtkZWwocHRyKX19O2Z1bmN0aW9uIHNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVAzMltwb2ludGVyPj4yXSl9dmFyIGF3YWl0aW5nRGVwZW5kZW5jaWVzPXt9O3ZhciByZWdpc3RlcmVkVHlwZXM9e307dmFyIHR5cGVEZXBlbmRlbmNpZXM9e307dmFyIEludGVybmFsRXJyb3I7dmFyIHRocm93SW50ZXJuYWxFcnJvcj1tZXNzYWdlPT57dGhyb3cgbmV3IEludGVybmFsRXJyb3IobWVzc2FnZSl9O3ZhciB3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZD0obXlUeXBlcyxkZXBlbmRlbnRUeXBlcyxnZXRUeXBlQ29udmVydGVycyk9PntteVR5cGVzLmZvckVhY2goZnVuY3Rpb24odHlwZSl7dHlwZURlcGVuZGVuY2llc1t0eXBlXT1kZXBlbmRlbnRUeXBlc30pO2Z1bmN0aW9uIG9uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpe3ZhciBteVR5cGVDb252ZXJ0ZXJzPWdldFR5cGVDb252ZXJ0ZXJzKHR5cGVDb252ZXJ0ZXJzKTtpZihteVR5cGVDb252ZXJ0ZXJzLmxlbmd0aCE9PW15VHlwZXMubGVuZ3RoKXt0aHJvd0ludGVybmFsRXJyb3IoXCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50XCIpfWZvcih2YXIgaT0wO2k8bXlUeXBlcy5sZW5ndGg7KytpKXtyZWdpc3RlclR5cGUobXlUeXBlc1tpXSxteVR5cGVDb252ZXJ0ZXJzW2ldKX19dmFyIHR5cGVDb252ZXJ0ZXJzPW5ldyBBcnJheShkZXBlbmRlbnRUeXBlcy5sZW5ndGgpO3ZhciB1bnJlZ2lzdGVyZWRUeXBlcz1bXTt2YXIgcmVnaXN0ZXJlZD0wO2RlcGVuZGVudFR5cGVzLmZvckVhY2goKGR0LGkpPT57aWYocmVnaXN0ZXJlZFR5cGVzLmhhc093blByb3BlcnR5KGR0KSl7dHlwZUNvbnZlcnRlcnNbaV09cmVnaXN0ZXJlZFR5cGVzW2R0XX1lbHNle3VucmVnaXN0ZXJlZFR5cGVzLnB1c2goZHQpO2lmKCFhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShkdCkpe2F3YWl0aW5nRGVwZW5kZW5jaWVzW2R0XT1bXX1hd2FpdGluZ0RlcGVuZGVuY2llc1tkdF0ucHVzaCgoKT0+e3R5cGVDb252ZXJ0ZXJzW2ldPXJlZ2lzdGVyZWRUeXBlc1tkdF07KytyZWdpc3RlcmVkO2lmKHJlZ2lzdGVyZWQ9PT11bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpe29uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpfX0pfX0pO2lmKDA9PT11bnJlZ2lzdGVyZWRUeXBlcy5sZW5ndGgpe29uQ29tcGxldGUodHlwZUNvbnZlcnRlcnMpfX07dmFyIF9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX2FycmF5PXJhd1R1cGxlVHlwZT0+e3ZhciByZWc9dHVwbGVSZWdpc3RyYXRpb25zW3Jhd1R1cGxlVHlwZV07ZGVsZXRlIHR1cGxlUmVnaXN0cmF0aW9uc1tyYXdUdXBsZVR5cGVdO3ZhciBlbGVtZW50cz1yZWcuZWxlbWVudHM7dmFyIGVsZW1lbnRzTGVuZ3RoPWVsZW1lbnRzLmxlbmd0aDt2YXIgZWxlbWVudFR5cGVzPWVsZW1lbnRzLm1hcChlbHQ9PmVsdC5nZXR0ZXJSZXR1cm5UeXBlKS5jb25jYXQoZWxlbWVudHMubWFwKGVsdD0+ZWx0LnNldHRlckFyZ3VtZW50VHlwZSkpO3ZhciByYXdDb25zdHJ1Y3Rvcj1yZWcucmF3Q29uc3RydWN0b3I7dmFyIHJhd0Rlc3RydWN0b3I9cmVnLnJhd0Rlc3RydWN0b3I7d2hlbkRlcGVuZGVudFR5cGVzQXJlUmVzb2x2ZWQoW3Jhd1R1cGxlVHlwZV0sZWxlbWVudFR5cGVzLGZ1bmN0aW9uKGVsZW1lbnRUeXBlcyl7ZWxlbWVudHMuZm9yRWFjaCgoZWx0LGkpPT57dmFyIGdldHRlclJldHVyblR5cGU9ZWxlbWVudFR5cGVzW2ldO3ZhciBnZXR0ZXI9ZWx0LmdldHRlcjt2YXIgZ2V0dGVyQ29udGV4dD1lbHQuZ2V0dGVyQ29udGV4dDt2YXIgc2V0dGVyQXJndW1lbnRUeXBlPWVsZW1lbnRUeXBlc1tpK2VsZW1lbnRzTGVuZ3RoXTt2YXIgc2V0dGVyPWVsdC5zZXR0ZXI7dmFyIHNldHRlckNvbnRleHQ9ZWx0LnNldHRlckNvbnRleHQ7ZWx0LnJlYWQ9cHRyPT5nZXR0ZXJSZXR1cm5UeXBlW1wiZnJvbVdpcmVUeXBlXCJdKGdldHRlcihnZXR0ZXJDb250ZXh0LHB0cikpO2VsdC53cml0ZT0ocHRyLG8pPT57dmFyIGRlc3RydWN0b3JzPVtdO3NldHRlcihzZXR0ZXJDb250ZXh0LHB0cixzZXR0ZXJBcmd1bWVudFR5cGVbXCJ0b1dpcmVUeXBlXCJdKGRlc3RydWN0b3JzLG8pKTtydW5EZXN0cnVjdG9ycyhkZXN0cnVjdG9ycyl9fSk7cmV0dXJuW3tuYW1lOnJlZy5uYW1lLFwiZnJvbVdpcmVUeXBlXCI6cHRyPT57dmFyIHJ2PW5ldyBBcnJheShlbGVtZW50c0xlbmd0aCk7Zm9yKHZhciBpPTA7aTxlbGVtZW50c0xlbmd0aDsrK2kpe3J2W2ldPWVsZW1lbnRzW2ldLnJlYWQocHRyKX1yYXdEZXN0cnVjdG9yKHB0cik7cmV0dXJuIHJ2fSxcInRvV2lyZVR5cGVcIjooZGVzdHJ1Y3RvcnMsbyk9PntpZihlbGVtZW50c0xlbmd0aCE9PW8ubGVuZ3RoKXt0aHJvdyBuZXcgVHlwZUVycm9yKGBJbmNvcnJlY3QgbnVtYmVyIG9mIHR1cGxlIGVsZW1lbnRzIGZvciAke3JlZy5uYW1lfTogZXhwZWN0ZWQ9JHtlbGVtZW50c0xlbmd0aH0sIGFjdHVhbD0ke28ubGVuZ3RofWApfXZhciBwdHI9cmF3Q29uc3RydWN0b3IoKTtmb3IodmFyIGk9MDtpPGVsZW1lbnRzTGVuZ3RoOysraSl7ZWxlbWVudHNbaV0ud3JpdGUocHRyLG9baV0pfWlmKGRlc3RydWN0b3JzIT09bnVsbCl7ZGVzdHJ1Y3RvcnMucHVzaChyYXdEZXN0cnVjdG9yLHB0cil9cmV0dXJuIHB0cn0sXCJhcmdQYWNrQWR2YW5jZVwiOkdlbmVyaWNXaXJlVHlwZVNpemUsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbjpyYXdEZXN0cnVjdG9yfV19KX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludD0ocHJpbWl0aXZlVHlwZSxuYW1lLHNpemUsbWluUmFuZ2UsbWF4UmFuZ2UpPT57fTt2YXIgZW1iaW5kX2luaXRfY2hhckNvZGVzPSgpPT57dmFyIGNvZGVzPW5ldyBBcnJheSgyNTYpO2Zvcih2YXIgaT0wO2k8MjU2OysraSl7Y29kZXNbaV09U3RyaW5nLmZyb21DaGFyQ29kZShpKX1lbWJpbmRfY2hhckNvZGVzPWNvZGVzfTt2YXIgZW1iaW5kX2NoYXJDb2Rlczt2YXIgcmVhZExhdGluMVN0cmluZz1wdHI9Pnt2YXIgcmV0PVwiXCI7dmFyIGM9cHRyO3doaWxlKEhFQVBVOFtjXSl7cmV0Kz1lbWJpbmRfY2hhckNvZGVzW0hFQVBVOFtjKytdXX1yZXR1cm4gcmV0fTt2YXIgQmluZGluZ0Vycm9yO3ZhciB0aHJvd0JpbmRpbmdFcnJvcj1tZXNzYWdlPT57dGhyb3cgbmV3IEJpbmRpbmdFcnJvcihtZXNzYWdlKX07ZnVuY3Rpb24gc2hhcmVkUmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnM9e30pe3ZhciBuYW1lPXJlZ2lzdGVyZWRJbnN0YW5jZS5uYW1lO2lmKCFyYXdUeXBlKXt0aHJvd0JpbmRpbmdFcnJvcihgdHlwZSBcIiR7bmFtZX1cIiBtdXN0IGhhdmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHR5cGVpZCBwb2ludGVyYCl9aWYocmVnaXN0ZXJlZFR5cGVzLmhhc093blByb3BlcnR5KHJhd1R5cGUpKXtpZihvcHRpb25zLmlnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnMpe3JldHVybn1lbHNle3Rocm93QmluZGluZ0Vycm9yKGBDYW5ub3QgcmVnaXN0ZXIgdHlwZSAnJHtuYW1lfScgdHdpY2VgKX19cmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdPXJlZ2lzdGVyZWRJbnN0YW5jZTtkZWxldGUgdHlwZURlcGVuZGVuY2llc1tyYXdUeXBlXTtpZihhd2FpdGluZ0RlcGVuZGVuY2llcy5oYXNPd25Qcm9wZXJ0eShyYXdUeXBlKSl7dmFyIGNhbGxiYWNrcz1hd2FpdGluZ0RlcGVuZGVuY2llc1tyYXdUeXBlXTtkZWxldGUgYXdhaXRpbmdEZXBlbmRlbmNpZXNbcmF3VHlwZV07Y2FsbGJhY2tzLmZvckVhY2goY2I9PmNiKCkpfX1mdW5jdGlvbiByZWdpc3RlclR5cGUocmF3VHlwZSxyZWdpc3RlcmVkSW5zdGFuY2Usb3B0aW9ucz17fSl7aWYoIShcImFyZ1BhY2tBZHZhbmNlXCJpbiByZWdpc3RlcmVkSW5zdGFuY2UpKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZVwiKX1yZXR1cm4gc2hhcmVkUmVnaXN0ZXJUeXBlKHJhd1R5cGUscmVnaXN0ZXJlZEluc3RhbmNlLG9wdGlvbnMpfXZhciBHZW5lcmljV2lyZVR5cGVTaXplPTg7dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2Jvb2w9KHJhd1R5cGUsbmFtZSx0cnVlVmFsdWUsZmFsc2VWYWx1ZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiOmZ1bmN0aW9uKHd0KXtyZXR1cm4hIXd0fSxcInRvV2lyZVR5cGVcIjpmdW5jdGlvbihkZXN0cnVjdG9ycyxvKXtyZXR1cm4gbz90cnVlVmFsdWU6ZmFsc2VWYWx1ZX0sXCJhcmdQYWNrQWR2YW5jZVwiOkdlbmVyaWNXaXJlVHlwZVNpemUsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOmZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVBVOFtwb2ludGVyXSl9LGRlc3RydWN0b3JGdW5jdGlvbjpudWxsfSl9O2Z1bmN0aW9uIGhhbmRsZUFsbG9jYXRvckluaXQoKXtPYmplY3QuYXNzaWduKEhhbmRsZUFsbG9jYXRvci5wcm90b3R5cGUse2dldChpZCl7cmV0dXJuIHRoaXMuYWxsb2NhdGVkW2lkXX0saGFzKGlkKXtyZXR1cm4gdGhpcy5hbGxvY2F0ZWRbaWRdIT09dW5kZWZpbmVkfSxhbGxvY2F0ZShoYW5kbGUpe3ZhciBpZD10aGlzLmZyZWVsaXN0LnBvcCgpfHx0aGlzLmFsbG9jYXRlZC5sZW5ndGg7dGhpcy5hbGxvY2F0ZWRbaWRdPWhhbmRsZTtyZXR1cm4gaWR9LGZyZWUoaWQpe3RoaXMuYWxsb2NhdGVkW2lkXT11bmRlZmluZWQ7dGhpcy5mcmVlbGlzdC5wdXNoKGlkKX19KX1mdW5jdGlvbiBIYW5kbGVBbGxvY2F0b3IoKXt0aGlzLmFsbG9jYXRlZD1bdW5kZWZpbmVkXTt0aGlzLmZyZWVsaXN0PVtdfXZhciBlbXZhbF9oYW5kbGVzPW5ldyBIYW5kbGVBbGxvY2F0b3I7dmFyIF9fZW12YWxfZGVjcmVmPWhhbmRsZT0+e2lmKGhhbmRsZT49ZW12YWxfaGFuZGxlcy5yZXNlcnZlZCYmMD09PS0tZW12YWxfaGFuZGxlcy5nZXQoaGFuZGxlKS5yZWZjb3VudCl7ZW12YWxfaGFuZGxlcy5mcmVlKGhhbmRsZSl9fTt2YXIgY291bnRfZW12YWxfaGFuZGxlcz0oKT0+e3ZhciBjb3VudD0wO2Zvcih2YXIgaT1lbXZhbF9oYW5kbGVzLnJlc2VydmVkO2k8ZW12YWxfaGFuZGxlcy5hbGxvY2F0ZWQubGVuZ3RoOysraSl7aWYoZW12YWxfaGFuZGxlcy5hbGxvY2F0ZWRbaV0hPT11bmRlZmluZWQpeysrY291bnR9fXJldHVybiBjb3VudH07dmFyIGluaXRfZW12YWw9KCk9PntlbXZhbF9oYW5kbGVzLmFsbG9jYXRlZC5wdXNoKHt2YWx1ZTp1bmRlZmluZWR9LHt2YWx1ZTpudWxsfSx7dmFsdWU6dHJ1ZX0se3ZhbHVlOmZhbHNlfSk7ZW12YWxfaGFuZGxlcy5yZXNlcnZlZD1lbXZhbF9oYW5kbGVzLmFsbG9jYXRlZC5sZW5ndGg7TW9kdWxlW1wiY291bnRfZW12YWxfaGFuZGxlc1wiXT1jb3VudF9lbXZhbF9oYW5kbGVzfTt2YXIgRW12YWw9e3RvVmFsdWU6aGFuZGxlPT57aWYoIWhhbmRsZSl7dGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgdXNlIGRlbGV0ZWQgdmFsLiBoYW5kbGUgPSBcIitoYW5kbGUpfXJldHVybiBlbXZhbF9oYW5kbGVzLmdldChoYW5kbGUpLnZhbHVlfSx0b0hhbmRsZTp2YWx1ZT0+e3N3aXRjaCh2YWx1ZSl7Y2FzZSB1bmRlZmluZWQ6cmV0dXJuIDE7Y2FzZSBudWxsOnJldHVybiAyO2Nhc2UgdHJ1ZTpyZXR1cm4gMztjYXNlIGZhbHNlOnJldHVybiA0O2RlZmF1bHQ6e3JldHVybiBlbXZhbF9oYW5kbGVzLmFsbG9jYXRlKHtyZWZjb3VudDoxLHZhbHVlOnZhbHVlfSl9fX19O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9lbXZhbD0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6aGFuZGxlPT57dmFyIHJ2PUVtdmFsLnRvVmFsdWUoaGFuZGxlKTtfX2VtdmFsX2RlY3JlZihoYW5kbGUpO3JldHVybiBydn0sXCJ0b1dpcmVUeXBlXCI6KGRlc3RydWN0b3JzLHZhbHVlKT0+RW12YWwudG9IYW5kbGUodmFsdWUpLFwiYXJnUGFja0FkdmFuY2VcIjpHZW5lcmljV2lyZVR5cGVTaXplLFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjpzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlcixkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pfTt2YXIgZW5zdXJlT3ZlcmxvYWRUYWJsZT0ocHJvdG8sbWV0aG9kTmFtZSxodW1hbk5hbWUpPT57aWYodW5kZWZpbmVkPT09cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZSl7dmFyIHByZXZGdW5jPXByb3RvW21ldGhvZE5hbWVdO3Byb3RvW21ldGhvZE5hbWVdPWZ1bmN0aW9uKCl7aWYoIXByb3RvW21ldGhvZE5hbWVdLm92ZXJsb2FkVGFibGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzLmxlbmd0aCkpe3Rocm93QmluZGluZ0Vycm9yKGBGdW5jdGlvbiAnJHtodW1hbk5hbWV9JyBjYWxsZWQgd2l0aCBhbiBpbnZhbGlkIG51bWJlciBvZiBhcmd1bWVudHMgKCR7YXJndW1lbnRzLmxlbmd0aH0pIC0gZXhwZWN0cyBvbmUgb2YgKCR7cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZX0pIWApfXJldHVybiBwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW2FyZ3VtZW50cy5sZW5ndGhdLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07cHJvdG9bbWV0aG9kTmFtZV0ub3ZlcmxvYWRUYWJsZT1bXTtwcm90b1ttZXRob2ROYW1lXS5vdmVybG9hZFRhYmxlW3ByZXZGdW5jLmFyZ0NvdW50XT1wcmV2RnVuY319O3ZhciBleHBvc2VQdWJsaWNTeW1ib2w9KG5hbWUsdmFsdWUsbnVtQXJndW1lbnRzKT0+e2lmKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSl7aWYodW5kZWZpbmVkPT09bnVtQXJndW1lbnRzfHx1bmRlZmluZWQhPT1Nb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZSYmdW5kZWZpbmVkIT09TW9kdWxlW25hbWVdLm92ZXJsb2FkVGFibGVbbnVtQXJndW1lbnRzXSl7dGhyb3dCaW5kaW5nRXJyb3IoYENhbm5vdCByZWdpc3RlciBwdWJsaWMgbmFtZSAnJHtuYW1lfScgdHdpY2VgKX1lbnN1cmVPdmVybG9hZFRhYmxlKE1vZHVsZSxuYW1lLG5hbWUpO2lmKE1vZHVsZS5oYXNPd25Qcm9wZXJ0eShudW1Bcmd1bWVudHMpKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAoJHtudW1Bcmd1bWVudHN9KSFgKX1Nb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZVtudW1Bcmd1bWVudHNdPXZhbHVlfWVsc2V7TW9kdWxlW25hbWVdPXZhbHVlO2lmKHVuZGVmaW5lZCE9PW51bUFyZ3VtZW50cyl7TW9kdWxlW25hbWVdLm51bUFyZ3VtZW50cz1udW1Bcmd1bWVudHN9fX07dmFyIGVudW1SZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCxzaWduZWQpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDE6cmV0dXJuIHNpZ25lZD9mdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQOFtwb2ludGVyPj4wXSl9OmZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVBVOFtwb2ludGVyPj4wXSl9O2Nhc2UgMjpyZXR1cm4gc2lnbmVkP2Z1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVAxNltwb2ludGVyPj4xXSl9OmZ1bmN0aW9uKHBvaW50ZXIpe3JldHVybiB0aGlzW1wiZnJvbVdpcmVUeXBlXCJdKEhFQVBVMTZbcG9pbnRlcj4+MV0pfTtjYXNlIDQ6cmV0dXJuIHNpZ25lZD9mdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQMzJbcG9pbnRlcj4+Ml0pfTpmdW5jdGlvbihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQVTMyW3BvaW50ZXI+PjJdKX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2VudW09KHJhd1R5cGUsbmFtZSxzaXplLGlzU2lnbmVkKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtmdW5jdGlvbiBjdG9yKCl7fWN0b3IudmFsdWVzPXt9O3JlZ2lzdGVyVHlwZShyYXdUeXBlLHtuYW1lOm5hbWUsY29uc3RydWN0b3I6Y3RvcixcImZyb21XaXJlVHlwZVwiOmZ1bmN0aW9uKGMpe3JldHVybiB0aGlzLmNvbnN0cnVjdG9yLnZhbHVlc1tjXX0sXCJ0b1dpcmVUeXBlXCI6KGRlc3RydWN0b3JzLGMpPT5jLnZhbHVlLFwiYXJnUGFja0FkdmFuY2VcIjpHZW5lcmljV2lyZVR5cGVTaXplLFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjplbnVtUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplLGlzU2lnbmVkKSxkZXN0cnVjdG9yRnVuY3Rpb246bnVsbH0pO2V4cG9zZVB1YmxpY1N5bWJvbChuYW1lLGN0b3IpfTt2YXIgY3JlYXRlTmFtZWRGdW5jdGlvbj0obmFtZSxib2R5KT0+T2JqZWN0LmRlZmluZVByb3BlcnR5KGJvZHksXCJuYW1lXCIse3ZhbHVlOm5hbWV9KTt2YXIgZ2V0VHlwZU5hbWU9dHlwZT0+e3ZhciBwdHI9X19fZ2V0VHlwZU5hbWUodHlwZSk7dmFyIHJ2PXJlYWRMYXRpbjFTdHJpbmcocHRyKTtfZnJlZShwdHIpO3JldHVybiBydn07dmFyIHJlcXVpcmVSZWdpc3RlcmVkVHlwZT0ocmF3VHlwZSxodW1hbk5hbWUpPT57dmFyIGltcGw9cmVnaXN0ZXJlZFR5cGVzW3Jhd1R5cGVdO2lmKHVuZGVmaW5lZD09PWltcGwpe3Rocm93QmluZGluZ0Vycm9yKGh1bWFuTmFtZStcIiBoYXMgdW5rbm93biB0eXBlIFwiK2dldFR5cGVOYW1lKHJhd1R5cGUpKX1yZXR1cm4gaW1wbH07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2VudW1fdmFsdWU9KHJhd0VudW1UeXBlLG5hbWUsZW51bVZhbHVlKT0+e3ZhciBlbnVtVHlwZT1yZXF1aXJlUmVnaXN0ZXJlZFR5cGUocmF3RW51bVR5cGUsXCJlbnVtXCIpO25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgRW51bT1lbnVtVHlwZS5jb25zdHJ1Y3Rvcjt2YXIgVmFsdWU9T2JqZWN0LmNyZWF0ZShlbnVtVHlwZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUse3ZhbHVlOnt2YWx1ZTplbnVtVmFsdWV9LGNvbnN0cnVjdG9yOnt2YWx1ZTpjcmVhdGVOYW1lZEZ1bmN0aW9uKGAke2VudW1UeXBlLm5hbWV9XyR7bmFtZX1gLGZ1bmN0aW9uKCl7fSl9fSk7RW51bS52YWx1ZXNbZW51bVZhbHVlXT1WYWx1ZTtFbnVtW25hbWVdPVZhbHVlfTt2YXIgZmxvYXRSZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCk9Pntzd2l0Y2god2lkdGgpe2Nhc2UgNDpyZXR1cm4gZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUEYzMltwb2ludGVyPj4yXSl9O2Nhc2UgODpyZXR1cm4gZnVuY3Rpb24ocG9pbnRlcil7cmV0dXJuIHRoaXNbXCJmcm9tV2lyZVR5cGVcIl0oSEVBUEY2NFtwb2ludGVyPj4zXSl9O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcihgaW52YWxpZCBmbG9hdCB3aWR0aCAoJHt3aWR0aH0pOiAke25hbWV9YCl9fTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQ9KHJhd1R5cGUsbmFtZSxzaXplKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6dmFsdWU9PnZhbHVlLFwidG9XaXJlVHlwZVwiOihkZXN0cnVjdG9ycyx2YWx1ZSk9PnZhbHVlLFwiYXJnUGFja0FkdmFuY2VcIjpHZW5lcmljV2lyZVR5cGVTaXplLFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjpmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyKG5hbWUsc2l6ZSksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KX07ZnVuY3Rpb24gbmV3RnVuYyhjb25zdHJ1Y3Rvcixhcmd1bWVudExpc3Qpe2lmKCEoY29uc3RydWN0b3IgaW5zdGFuY2VvZiBGdW5jdGlvbikpe3Rocm93IG5ldyBUeXBlRXJyb3IoYG5ld18gY2FsbGVkIHdpdGggY29uc3RydWN0b3IgdHlwZSAke3R5cGVvZiBjb25zdHJ1Y3Rvcn0gd2hpY2ggaXMgbm90IGEgZnVuY3Rpb25gKX12YXIgZHVtbXk9Y3JlYXRlTmFtZWRGdW5jdGlvbihjb25zdHJ1Y3Rvci5uYW1lfHxcInVua25vd25GdW5jdGlvbk5hbWVcIixmdW5jdGlvbigpe30pO2R1bW15LnByb3RvdHlwZT1jb25zdHJ1Y3Rvci5wcm90b3R5cGU7dmFyIG9iaj1uZXcgZHVtbXk7dmFyIHI9Y29uc3RydWN0b3IuYXBwbHkob2JqLGFyZ3VtZW50TGlzdCk7cmV0dXJuIHIgaW5zdGFuY2VvZiBPYmplY3Q/cjpvYmp9ZnVuY3Rpb24gY3JhZnRJbnZva2VyRnVuY3Rpb24oaHVtYW5OYW1lLGFyZ1R5cGVzLGNsYXNzVHlwZSxjcHBJbnZva2VyRnVuYyxjcHBUYXJnZXRGdW5jLGlzQXN5bmMpe3ZhciBhcmdDb3VudD1hcmdUeXBlcy5sZW5ndGg7aWYoYXJnQ291bnQ8Mil7dGhyb3dCaW5kaW5nRXJyb3IoXCJhcmdUeXBlcyBhcnJheSBzaXplIG1pc21hdGNoISBNdXN0IGF0IGxlYXN0IGdldCByZXR1cm4gdmFsdWUgYW5kICd0aGlzJyB0eXBlcyFcIil9dmFyIGlzQ2xhc3NNZXRob2RGdW5jPWFyZ1R5cGVzWzFdIT09bnVsbCYmY2xhc3NUeXBlIT09bnVsbDt2YXIgbmVlZHNEZXN0cnVjdG9yU3RhY2s9ZmFsc2U7Zm9yKHZhciBpPTE7aTxhcmdUeXBlcy5sZW5ndGg7KytpKXtpZihhcmdUeXBlc1tpXSE9PW51bGwmJmFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbj09PXVuZGVmaW5lZCl7bmVlZHNEZXN0cnVjdG9yU3RhY2s9dHJ1ZTticmVha319dmFyIHJldHVybnM9YXJnVHlwZXNbMF0ubmFtZSE9PVwidm9pZFwiO3ZhciBhcmdzTGlzdD1cIlwiO3ZhciBhcmdzTGlzdFdpcmVkPVwiXCI7Zm9yKHZhciBpPTA7aTxhcmdDb3VudC0yOysraSl7YXJnc0xpc3QrPShpIT09MD9cIiwgXCI6XCJcIikrXCJhcmdcIitpO2FyZ3NMaXN0V2lyZWQrPShpIT09MD9cIiwgXCI6XCJcIikrXCJhcmdcIitpK1wiV2lyZWRcIn12YXIgaW52b2tlckZuQm9keT1gXFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCR7YXJnc0xpc3R9KSB7XFxuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gJHthcmdDb3VudC0yfSkge1xcbiAgICAgICAgICB0aHJvd0JpbmRpbmdFcnJvcignZnVuY3Rpb24gJHtodW1hbk5hbWV9IGNhbGxlZCB3aXRoICcgKyBhcmd1bWVudHMubGVuZ3RoICsgJyBhcmd1bWVudHMsIGV4cGVjdGVkICR7YXJnQ291bnQtMn0nKTtcXG4gICAgICAgIH1gO2lmKG5lZWRzRGVzdHJ1Y3RvclN0YWNrKXtpbnZva2VyRm5Cb2R5Kz1cInZhciBkZXN0cnVjdG9ycyA9IFtdO1xcblwifXZhciBkdG9yU3RhY2s9bmVlZHNEZXN0cnVjdG9yU3RhY2s/XCJkZXN0cnVjdG9yc1wiOlwibnVsbFwiO3ZhciBhcmdzMT1bXCJ0aHJvd0JpbmRpbmdFcnJvclwiLFwiaW52b2tlclwiLFwiZm5cIixcInJ1bkRlc3RydWN0b3JzXCIsXCJyZXRUeXBlXCIsXCJjbGFzc1BhcmFtXCJdO3ZhciBhcmdzMj1bdGhyb3dCaW5kaW5nRXJyb3IsY3BwSW52b2tlckZ1bmMsY3BwVGFyZ2V0RnVuYyxydW5EZXN0cnVjdG9ycyxhcmdUeXBlc1swXSxhcmdUeXBlc1sxXV07aWYoaXNDbGFzc01ldGhvZEZ1bmMpe2ludm9rZXJGbkJvZHkrPVwidmFyIHRoaXNXaXJlZCA9IGNsYXNzUGFyYW0udG9XaXJlVHlwZShcIitkdG9yU3RhY2srXCIsIHRoaXMpO1xcblwifWZvcih2YXIgaT0wO2k8YXJnQ291bnQtMjsrK2kpe2ludm9rZXJGbkJvZHkrPVwidmFyIGFyZ1wiK2krXCJXaXJlZCA9IGFyZ1R5cGVcIitpK1wiLnRvV2lyZVR5cGUoXCIrZHRvclN0YWNrK1wiLCBhcmdcIitpK1wiKTsgLy8gXCIrYXJnVHlwZXNbaSsyXS5uYW1lK1wiXFxuXCI7YXJnczEucHVzaChcImFyZ1R5cGVcIitpKTthcmdzMi5wdXNoKGFyZ1R5cGVzW2krMl0pfWlmKGlzQ2xhc3NNZXRob2RGdW5jKXthcmdzTGlzdFdpcmVkPVwidGhpc1dpcmVkXCIrKGFyZ3NMaXN0V2lyZWQubGVuZ3RoPjA/XCIsIFwiOlwiXCIpK2FyZ3NMaXN0V2lyZWR9aW52b2tlckZuQm9keSs9KHJldHVybnN8fGlzQXN5bmM/XCJ2YXIgcnYgPSBcIjpcIlwiKStcImludm9rZXIoZm5cIisoYXJnc0xpc3RXaXJlZC5sZW5ndGg+MD9cIiwgXCI6XCJcIikrYXJnc0xpc3RXaXJlZCtcIik7XFxuXCI7aWYobmVlZHNEZXN0cnVjdG9yU3RhY2spe2ludm9rZXJGbkJvZHkrPVwicnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpO1xcblwifWVsc2V7Zm9yKHZhciBpPWlzQ2xhc3NNZXRob2RGdW5jPzE6MjtpPGFyZ1R5cGVzLmxlbmd0aDsrK2kpe3ZhciBwYXJhbU5hbWU9aT09PTE/XCJ0aGlzV2lyZWRcIjpcImFyZ1wiKyhpLTIpK1wiV2lyZWRcIjtpZihhcmdUeXBlc1tpXS5kZXN0cnVjdG9yRnVuY3Rpb24hPT1udWxsKXtpbnZva2VyRm5Cb2R5Kz1wYXJhbU5hbWUrXCJfZHRvcihcIitwYXJhbU5hbWUrXCIpOyAvLyBcIithcmdUeXBlc1tpXS5uYW1lK1wiXFxuXCI7YXJnczEucHVzaChwYXJhbU5hbWUrXCJfZHRvclwiKTthcmdzMi5wdXNoKGFyZ1R5cGVzW2ldLmRlc3RydWN0b3JGdW5jdGlvbil9fX1pZihyZXR1cm5zKXtpbnZva2VyRm5Cb2R5Kz1cInZhciByZXQgPSByZXRUeXBlLmZyb21XaXJlVHlwZShydik7XFxuXCIrXCJyZXR1cm4gcmV0O1xcblwifWVsc2V7fWludm9rZXJGbkJvZHkrPVwifVxcblwiO2FyZ3MxLnB1c2goaW52b2tlckZuQm9keSk7dmFyIGludm9rZXJGbj1uZXdGdW5jKEZ1bmN0aW9uLGFyZ3MxKS5hcHBseShudWxsLGFyZ3MyKTtyZXR1cm4gY3JlYXRlTmFtZWRGdW5jdGlvbihodW1hbk5hbWUsaW52b2tlckZuKX12YXIgaGVhcDMyVmVjdG9yVG9BcnJheT0oY291bnQsZmlyc3RFbGVtZW50KT0+e3ZhciBhcnJheT1bXTtmb3IodmFyIGk9MDtpPGNvdW50O2krKyl7YXJyYXkucHVzaChIRUFQVTMyW2ZpcnN0RWxlbWVudCtpKjQ+PjJdKX1yZXR1cm4gYXJyYXl9O3ZhciByZXBsYWNlUHVibGljU3ltYm9sPShuYW1lLHZhbHVlLG51bUFyZ3VtZW50cyk9PntpZighTW9kdWxlLmhhc093blByb3BlcnR5KG5hbWUpKXt0aHJvd0ludGVybmFsRXJyb3IoXCJSZXBsYWNpbmcgbm9uZXhpc3RhbnQgcHVibGljIHN5bWJvbFwiKX1pZih1bmRlZmluZWQhPT1Nb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZSYmdW5kZWZpbmVkIT09bnVtQXJndW1lbnRzKXtNb2R1bGVbbmFtZV0ub3ZlcmxvYWRUYWJsZVtudW1Bcmd1bWVudHNdPXZhbHVlfWVsc2V7TW9kdWxlW25hbWVdPXZhbHVlO01vZHVsZVtuYW1lXS5hcmdDb3VudD1udW1Bcmd1bWVudHN9fTt2YXIgZHluQ2FsbExlZ2FjeT0oc2lnLHB0cixhcmdzKT0+e3ZhciBmPU1vZHVsZVtcImR5bkNhbGxfXCIrc2lnXTtyZXR1cm4gYXJncyYmYXJncy5sZW5ndGg/Zi5hcHBseShudWxsLFtwdHJdLmNvbmNhdChhcmdzKSk6Zi5jYWxsKG51bGwscHRyKX07dmFyIHdhc21UYWJsZU1pcnJvcj1bXTt2YXIgd2FzbVRhYmxlO3ZhciBnZXRXYXNtVGFibGVFbnRyeT1mdW5jUHRyPT57dmFyIGZ1bmM9d2FzbVRhYmxlTWlycm9yW2Z1bmNQdHJdO2lmKCFmdW5jKXtpZihmdW5jUHRyPj13YXNtVGFibGVNaXJyb3IubGVuZ3RoKXdhc21UYWJsZU1pcnJvci5sZW5ndGg9ZnVuY1B0cisxO3dhc21UYWJsZU1pcnJvcltmdW5jUHRyXT1mdW5jPXdhc21UYWJsZS5nZXQoZnVuY1B0cil9cmV0dXJuIGZ1bmN9O3ZhciBkeW5DYWxsPShzaWcscHRyLGFyZ3MpPT57aWYoc2lnLmluY2x1ZGVzKFwialwiKSl7cmV0dXJuIGR5bkNhbGxMZWdhY3koc2lnLHB0cixhcmdzKX12YXIgcnRuPWdldFdhc21UYWJsZUVudHJ5KHB0cikuYXBwbHkobnVsbCxhcmdzKTtyZXR1cm4gcnRufTt2YXIgZ2V0RHluQ2FsbGVyPShzaWcscHRyKT0+e3ZhciBhcmdDYWNoZT1bXTtyZXR1cm4gZnVuY3Rpb24oKXthcmdDYWNoZS5sZW5ndGg9MDtPYmplY3QuYXNzaWduKGFyZ0NhY2hlLGFyZ3VtZW50cyk7cmV0dXJuIGR5bkNhbGwoc2lnLHB0cixhcmdDYWNoZSl9fTt2YXIgZW1iaW5kX19yZXF1aXJlRnVuY3Rpb249KHNpZ25hdHVyZSxyYXdGdW5jdGlvbik9PntzaWduYXR1cmU9cmVhZExhdGluMVN0cmluZyhzaWduYXR1cmUpO2Z1bmN0aW9uIG1ha2VEeW5DYWxsZXIoKXtpZihzaWduYXR1cmUuaW5jbHVkZXMoXCJqXCIpKXtyZXR1cm4gZ2V0RHluQ2FsbGVyKHNpZ25hdHVyZSxyYXdGdW5jdGlvbil9cmV0dXJuIGdldFdhc21UYWJsZUVudHJ5KHJhd0Z1bmN0aW9uKX12YXIgZnA9bWFrZUR5bkNhbGxlcigpO2lmKHR5cGVvZiBmcCE9XCJmdW5jdGlvblwiKXt0aHJvd0JpbmRpbmdFcnJvcihgdW5rbm93biBmdW5jdGlvbiBwb2ludGVyIHdpdGggc2lnbmF0dXJlICR7c2lnbmF0dXJlfTogJHtyYXdGdW5jdGlvbn1gKX1yZXR1cm4gZnB9O3ZhciBleHRlbmRFcnJvcj0oYmFzZUVycm9yVHlwZSxlcnJvck5hbWUpPT57dmFyIGVycm9yQ2xhc3M9Y3JlYXRlTmFtZWRGdW5jdGlvbihlcnJvck5hbWUsZnVuY3Rpb24obWVzc2FnZSl7dGhpcy5uYW1lPWVycm9yTmFtZTt0aGlzLm1lc3NhZ2U9bWVzc2FnZTt2YXIgc3RhY2s9bmV3IEVycm9yKG1lc3NhZ2UpLnN0YWNrO2lmKHN0YWNrIT09dW5kZWZpbmVkKXt0aGlzLnN0YWNrPXRoaXMudG9TdHJpbmcoKStcIlxcblwiK3N0YWNrLnJlcGxhY2UoL15FcnJvcig6W15cXG5dKik/XFxuLyxcIlwiKX19KTtlcnJvckNsYXNzLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGJhc2VFcnJvclR5cGUucHJvdG90eXBlKTtlcnJvckNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lcnJvckNsYXNzO2Vycm9yQ2xhc3MucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7aWYodGhpcy5tZXNzYWdlPT09dW5kZWZpbmVkKXtyZXR1cm4gdGhpcy5uYW1lfWVsc2V7cmV0dXJuYCR7dGhpcy5uYW1lfTogJHt0aGlzLm1lc3NhZ2V9YH19O3JldHVybiBlcnJvckNsYXNzfTt2YXIgVW5ib3VuZFR5cGVFcnJvcjt2YXIgdGhyb3dVbmJvdW5kVHlwZUVycm9yPShtZXNzYWdlLHR5cGVzKT0+e3ZhciB1bmJvdW5kVHlwZXM9W107dmFyIHNlZW49e307ZnVuY3Rpb24gdmlzaXQodHlwZSl7aWYoc2Vlblt0eXBlXSl7cmV0dXJufWlmKHJlZ2lzdGVyZWRUeXBlc1t0eXBlXSl7cmV0dXJufWlmKHR5cGVEZXBlbmRlbmNpZXNbdHlwZV0pe3R5cGVEZXBlbmRlbmNpZXNbdHlwZV0uZm9yRWFjaCh2aXNpdCk7cmV0dXJufXVuYm91bmRUeXBlcy5wdXNoKHR5cGUpO3NlZW5bdHlwZV09dHJ1ZX10eXBlcy5mb3JFYWNoKHZpc2l0KTt0aHJvdyBuZXcgVW5ib3VuZFR5cGVFcnJvcihgJHttZXNzYWdlfTogYCt1bmJvdW5kVHlwZXMubWFwKGdldFR5cGVOYW1lKS5qb2luKFtcIiwgXCJdKSl9O3ZhciBnZXRGdW5jdGlvbk5hbWU9c2lnbmF0dXJlPT57c2lnbmF0dXJlPXNpZ25hdHVyZS50cmltKCk7Y29uc3QgYXJnc0luZGV4PXNpZ25hdHVyZS5pbmRleE9mKFwiKFwiKTtpZihhcmdzSW5kZXghPT0tMSl7cmV0dXJuIHNpZ25hdHVyZS5zdWJzdHIoMCxhcmdzSW5kZXgpfWVsc2V7cmV0dXJuIHNpZ25hdHVyZX19O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbj0obmFtZSxhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIsc2lnbmF0dXJlLHJhd0ludm9rZXIsZm4saXNBc3luYyk9Pnt2YXIgYXJnVHlwZXM9aGVhcDMyVmVjdG9yVG9BcnJheShhcmdDb3VudCxyYXdBcmdUeXBlc0FkZHIpO25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtuYW1lPWdldEZ1bmN0aW9uTmFtZShuYW1lKTtyYXdJbnZva2VyPWVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNpZ25hdHVyZSxyYXdJbnZva2VyKTtleHBvc2VQdWJsaWNTeW1ib2wobmFtZSxmdW5jdGlvbigpe3Rocm93VW5ib3VuZFR5cGVFcnJvcihgQ2Fubm90IGNhbGwgJHtuYW1lfSBkdWUgdG8gdW5ib3VuZCB0eXBlc2AsYXJnVHlwZXMpfSxhcmdDb3VudC0xKTt3aGVuRGVwZW5kZW50VHlwZXNBcmVSZXNvbHZlZChbXSxhcmdUeXBlcyxmdW5jdGlvbihhcmdUeXBlcyl7dmFyIGludm9rZXJBcmdzQXJyYXk9W2FyZ1R5cGVzWzBdLG51bGxdLmNvbmNhdChhcmdUeXBlcy5zbGljZSgxKSk7cmVwbGFjZVB1YmxpY1N5bWJvbChuYW1lLGNyYWZ0SW52b2tlckZ1bmN0aW9uKG5hbWUsaW52b2tlckFyZ3NBcnJheSxudWxsLHJhd0ludm9rZXIsZm4saXNBc3luYyksYXJnQ291bnQtMSk7cmV0dXJuW119KX07dmFyIGludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlcj0obmFtZSx3aWR0aCxzaWduZWQpPT57c3dpdGNoKHdpZHRoKXtjYXNlIDE6cmV0dXJuIHNpZ25lZD9wb2ludGVyPT5IRUFQOFtwb2ludGVyPj4wXTpwb2ludGVyPT5IRUFQVThbcG9pbnRlcj4+MF07Y2FzZSAyOnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDE2W3BvaW50ZXI+PjFdOnBvaW50ZXI9PkhFQVBVMTZbcG9pbnRlcj4+MV07Y2FzZSA0OnJldHVybiBzaWduZWQ/cG9pbnRlcj0+SEVBUDMyW3BvaW50ZXI+PjJdOnBvaW50ZXI9PkhFQVBVMzJbcG9pbnRlcj4+Ml07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGludGVnZXIgd2lkdGggKCR7d2lkdGh9KTogJHtuYW1lfWApfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXI9KHByaW1pdGl2ZVR5cGUsbmFtZSxzaXplLG1pblJhbmdlLG1heFJhbmdlKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtpZihtYXhSYW5nZT09PS0xKXttYXhSYW5nZT00Mjk0OTY3Mjk1fXZhciBmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlO2lmKG1pblJhbmdlPT09MCl7dmFyIGJpdHNoaWZ0PTMyLTgqc2l6ZTtmcm9tV2lyZVR5cGU9dmFsdWU9PnZhbHVlPDxiaXRzaGlmdD4+PmJpdHNoaWZ0fXZhciBpc1Vuc2lnbmVkVHlwZT1uYW1lLmluY2x1ZGVzKFwidW5zaWduZWRcIik7dmFyIGNoZWNrQXNzZXJ0aW9ucz0odmFsdWUsdG9UeXBlTmFtZSk9Pnt9O3ZhciB0b1dpcmVUeXBlO2lmKGlzVW5zaWduZWRUeXBlKXt0b1dpcmVUeXBlPWZ1bmN0aW9uKGRlc3RydWN0b3JzLHZhbHVlKXtjaGVja0Fzc2VydGlvbnModmFsdWUsdGhpcy5uYW1lKTtyZXR1cm4gdmFsdWU+Pj4wfX1lbHNle3RvV2lyZVR5cGU9ZnVuY3Rpb24oZGVzdHJ1Y3RvcnMsdmFsdWUpe2NoZWNrQXNzZXJ0aW9ucyh2YWx1ZSx0aGlzLm5hbWUpO3JldHVybiB2YWx1ZX19cmVnaXN0ZXJUeXBlKHByaW1pdGl2ZVR5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiOmZyb21XaXJlVHlwZSxcInRvV2lyZVR5cGVcIjp0b1dpcmVUeXBlLFwiYXJnUGFja0FkdmFuY2VcIjpHZW5lcmljV2lyZVR5cGVTaXplLFwicmVhZFZhbHVlRnJvbVBvaW50ZXJcIjppbnRlZ2VyUmVhZFZhbHVlRnJvbVBvaW50ZXIobmFtZSxzaXplLG1pblJhbmdlIT09MCksZGVzdHJ1Y3RvckZ1bmN0aW9uOm51bGx9KX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3PShyYXdUeXBlLGRhdGFUeXBlSW5kZXgsbmFtZSk9Pnt2YXIgdHlwZU1hcHBpbmc9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5XTt2YXIgVEE9dHlwZU1hcHBpbmdbZGF0YVR5cGVJbmRleF07ZnVuY3Rpb24gZGVjb2RlTWVtb3J5VmlldyhoYW5kbGUpe3ZhciBzaXplPUhFQVBVMzJbaGFuZGxlPj4yXTt2YXIgZGF0YT1IRUFQVTMyW2hhbmRsZSs0Pj4yXTtyZXR1cm4gbmV3IFRBKEhFQVA4LmJ1ZmZlcixkYXRhLHNpemUpfW5hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6ZGVjb2RlTWVtb3J5VmlldyxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6ZGVjb2RlTWVtb3J5Vmlld30se2lnbm9yZUR1cGxpY2F0ZVJlZ2lzdHJhdGlvbnM6dHJ1ZX0pfTtmdW5jdGlvbiByZWFkUG9pbnRlcihwb2ludGVyKXtyZXR1cm4gdGhpc1tcImZyb21XaXJlVHlwZVwiXShIRUFQVTMyW3BvaW50ZXI+PjJdKX12YXIgc3RyaW5nVG9VVEY4QXJyYXk9KHN0cixoZWFwLG91dElkeCxtYXhCeXRlc1RvV3JpdGUpPT57aWYoIShtYXhCeXRlc1RvV3JpdGU+MCkpcmV0dXJuIDA7dmFyIHN0YXJ0SWR4PW91dElkeDt2YXIgZW5kSWR4PW91dElkeCttYXhCeXRlc1RvV3JpdGUtMTtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgdT1zdHIuY2hhckNvZGVBdChpKTtpZih1Pj01NTI5NiYmdTw9NTczNDMpe3ZhciB1MT1zdHIuY2hhckNvZGVBdCgrK2kpO3U9NjU1MzYrKCh1JjEwMjMpPDwxMCl8dTEmMTAyM31pZih1PD0xMjcpe2lmKG91dElkeD49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPXV9ZWxzZSBpZih1PD0yMDQ3KXtpZihvdXRJZHgrMT49ZW5kSWR4KWJyZWFrO2hlYXBbb3V0SWR4KytdPTE5Mnx1Pj42O2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2UgaWYodTw9NjU1MzUpe2lmKG91dElkeCsyPj1lbmRJZHgpYnJlYWs7aGVhcFtvdXRJZHgrK109MjI0fHU+PjEyO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfWVsc2V7aWYob3V0SWR4KzM+PWVuZElkeClicmVhaztoZWFwW291dElkeCsrXT0yNDB8dT4+MTg7aGVhcFtvdXRJZHgrK109MTI4fHU+PjEyJjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1Pj42JjYzO2hlYXBbb3V0SWR4KytdPTEyOHx1JjYzfX1oZWFwW291dElkeF09MDtyZXR1cm4gb3V0SWR4LXN0YXJ0SWR4fTt2YXIgc3RyaW5nVG9VVEY4PShzdHIsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk9PnN0cmluZ1RvVVRGOEFycmF5KHN0cixIRUFQVTgsb3V0UHRyLG1heEJ5dGVzVG9Xcml0ZSk7dmFyIGxlbmd0aEJ5dGVzVVRGOD1zdHI9Pnt2YXIgbGVuPTA7Zm9yKHZhciBpPTA7aTxzdHIubGVuZ3RoOysraSl7dmFyIGM9c3RyLmNoYXJDb2RlQXQoaSk7aWYoYzw9MTI3KXtsZW4rK31lbHNlIGlmKGM8PTIwNDcpe2xlbis9Mn1lbHNlIGlmKGM+PTU1Mjk2JiZjPD01NzM0Myl7bGVuKz00OysraX1lbHNle2xlbis9M319cmV0dXJuIGxlbn07dmFyIFVURjhEZWNvZGVyPXR5cGVvZiBUZXh0RGVjb2RlciE9XCJ1bmRlZmluZWRcIj9uZXcgVGV4dERlY29kZXIoXCJ1dGY4XCIpOnVuZGVmaW5lZDt2YXIgVVRGOEFycmF5VG9TdHJpbmc9KGhlYXBPckFycmF5LGlkeCxtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgZW5kSWR4PWlkeCttYXhCeXRlc1RvUmVhZDt2YXIgZW5kUHRyPWlkeDt3aGlsZShoZWFwT3JBcnJheVtlbmRQdHJdJiYhKGVuZFB0cj49ZW5kSWR4KSkrK2VuZFB0cjtpZihlbmRQdHItaWR4PjE2JiZoZWFwT3JBcnJheS5idWZmZXImJlVURjhEZWNvZGVyKXtyZXR1cm4gVVRGOERlY29kZXIuZGVjb2RlKGhlYXBPckFycmF5LnN1YmFycmF5KGlkeCxlbmRQdHIpKX12YXIgc3RyPVwiXCI7d2hpbGUoaWR4PGVuZFB0cil7dmFyIHUwPWhlYXBPckFycmF5W2lkeCsrXTtpZighKHUwJjEyOCkpe3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSh1MCk7Y29udGludWV9dmFyIHUxPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjI0KT09MTkyKXtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoKHUwJjMxKTw8Nnx1MSk7Y29udGludWV9dmFyIHUyPWhlYXBPckFycmF5W2lkeCsrXSY2MztpZigodTAmMjQwKT09MjI0KXt1MD0odTAmMTUpPDwxMnx1MTw8Nnx1Mn1lbHNle3UwPSh1MCY3KTw8MTh8dTE8PDEyfHUyPDw2fGhlYXBPckFycmF5W2lkeCsrXSY2M31pZih1MDw2NTUzNil7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHUwKX1lbHNle3ZhciBjaD11MC02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfX1yZXR1cm4gc3RyfTt2YXIgVVRGOFRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT5wdHI/VVRGOEFycmF5VG9TdHJpbmcoSEVBUFU4LHB0cixtYXhCeXRlc1RvUmVhZCk6XCJcIjt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZz0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTt2YXIgc3RkU3RyaW5nSXNVVEY4PW5hbWU9PT1cInN0ZDo6c3RyaW5nXCI7cmVnaXN0ZXJUeXBlKHJhd1R5cGUse25hbWU6bmFtZSxcImZyb21XaXJlVHlwZVwiKHZhbHVlKXt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBwYXlsb2FkPXZhbHVlKzQ7dmFyIHN0cjtpZihzdGRTdHJpbmdJc1VURjgpe3ZhciBkZWNvZGVTdGFydFB0cj1wYXlsb2FkO2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj1wYXlsb2FkK2k7aWYoaT09bGVuZ3RofHxIRUFQVThbY3VycmVudEJ5dGVQdHJdPT0wKXt2YXIgbWF4UmVhZD1jdXJyZW50Qnl0ZVB0ci1kZWNvZGVTdGFydFB0cjt2YXIgc3RyaW5nU2VnbWVudD1VVEY4VG9TdHJpbmcoZGVjb2RlU3RhcnRQdHIsbWF4UmVhZCk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudH1lbHNle3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnR9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrMX19fWVsc2V7dmFyIGE9bmV3IEFycmF5KGxlbmd0aCk7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXthW2ldPVN0cmluZy5mcm9tQ2hhckNvZGUoSEVBUFU4W3BheWxvYWQraV0pfXN0cj1hLmpvaW4oXCJcIil9X2ZyZWUodmFsdWUpO3JldHVybiBzdHJ9LFwidG9XaXJlVHlwZVwiKGRlc3RydWN0b3JzLHZhbHVlKXtpZih2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXt2YWx1ZT1uZXcgVWludDhBcnJheSh2YWx1ZSl9dmFyIGxlbmd0aDt2YXIgdmFsdWVJc09mVHlwZVN0cmluZz10eXBlb2YgdmFsdWU9PVwic3RyaW5nXCI7aWYoISh2YWx1ZUlzT2ZUeXBlU3RyaW5nfHx2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXl8fHZhbHVlIGluc3RhbmNlb2YgSW50OEFycmF5KSl7dGhyb3dCaW5kaW5nRXJyb3IoXCJDYW5ub3QgcGFzcyBub24tc3RyaW5nIHRvIHN0ZDo6c3RyaW5nXCIpfWlmKHN0ZFN0cmluZ0lzVVRGOCYmdmFsdWVJc09mVHlwZVN0cmluZyl7bGVuZ3RoPWxlbmd0aEJ5dGVzVVRGOCh2YWx1ZSl9ZWxzZXtsZW5ndGg9dmFsdWUubGVuZ3RofXZhciBiYXNlPV9tYWxsb2MoNCtsZW5ndGgrMSk7dmFyIHB0cj1iYXNlKzQ7SEVBUFUzMltiYXNlPj4yXT1sZW5ndGg7aWYoc3RkU3RyaW5nSXNVVEY4JiZ2YWx1ZUlzT2ZUeXBlU3RyaW5nKXtzdHJpbmdUb1VURjgodmFsdWUscHRyLGxlbmd0aCsxKX1lbHNle2lmKHZhbHVlSXNPZlR5cGVTdHJpbmcpe2Zvcih2YXIgaT0wO2k8bGVuZ3RoOysraSl7dmFyIGNoYXJDb2RlPXZhbHVlLmNoYXJDb2RlQXQoaSk7aWYoY2hhckNvZGU+MjU1KXtfZnJlZShwdHIpO3Rocm93QmluZGluZ0Vycm9yKFwiU3RyaW5nIGhhcyBVVEYtMTYgY29kZSB1bml0cyB0aGF0IGRvIG5vdCBmaXQgaW4gOCBiaXRzXCIpfUhFQVBVOFtwdHIraV09Y2hhckNvZGV9fWVsc2V7Zm9yKHZhciBpPTA7aTxsZW5ndGg7KytpKXtIRUFQVThbcHRyK2ldPXZhbHVlW2ldfX19aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLGJhc2UpfXJldHVybiBiYXNlfSxcImFyZ1BhY2tBZHZhbmNlXCI6R2VuZXJpY1dpcmVUeXBlU2l6ZSxcInJlYWRWYWx1ZUZyb21Qb2ludGVyXCI6cmVhZFBvaW50ZXIsZGVzdHJ1Y3RvckZ1bmN0aW9uKHB0cil7X2ZyZWUocHRyKX19KX07dmFyIFVURjE2RGVjb2Rlcj10eXBlb2YgVGV4dERlY29kZXIhPVwidW5kZWZpbmVkXCI/bmV3IFRleHREZWNvZGVyKFwidXRmLTE2bGVcIik6dW5kZWZpbmVkO3ZhciBVVEYxNlRvU3RyaW5nPShwdHIsbWF4Qnl0ZXNUb1JlYWQpPT57dmFyIGVuZFB0cj1wdHI7dmFyIGlkeD1lbmRQdHI+PjE7dmFyIG1heElkeD1pZHgrbWF4Qnl0ZXNUb1JlYWQvMjt3aGlsZSghKGlkeD49bWF4SWR4KSYmSEVBUFUxNltpZHhdKSsraWR4O2VuZFB0cj1pZHg8PDE7aWYoZW5kUHRyLXB0cj4zMiYmVVRGMTZEZWNvZGVyKXJldHVybiBVVEYxNkRlY29kZXIuZGVjb2RlKEhFQVBVOC5zdWJhcnJheShwdHIsZW5kUHRyKSk7dmFyIHN0cj1cIlwiO2Zvcih2YXIgaT0wOyEoaT49bWF4Qnl0ZXNUb1JlYWQvMik7KytpKXt2YXIgY29kZVVuaXQ9SEVBUDE2W3B0citpKjI+PjFdO2lmKGNvZGVVbml0PT0wKWJyZWFrO3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZShjb2RlVW5pdCl9cmV0dXJuIHN0cn07dmFyIHN0cmluZ1RvVVRGMTY9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+e2lmKG1heEJ5dGVzVG9Xcml0ZT09PXVuZGVmaW5lZCl7bWF4Qnl0ZXNUb1dyaXRlPTIxNDc0ODM2NDd9aWYobWF4Qnl0ZXNUb1dyaXRlPDIpcmV0dXJuIDA7bWF4Qnl0ZXNUb1dyaXRlLT0yO3ZhciBzdGFydFB0cj1vdXRQdHI7dmFyIG51bUNoYXJzVG9Xcml0ZT1tYXhCeXRlc1RvV3JpdGU8c3RyLmxlbmd0aCoyP21heEJ5dGVzVG9Xcml0ZS8yOnN0ci5sZW5ndGg7Zm9yKHZhciBpPTA7aTxudW1DaGFyc1RvV3JpdGU7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7SEVBUDE2W291dFB0cj4+MV09Y29kZVVuaXQ7b3V0UHRyKz0yfUhFQVAxNltvdXRQdHI+PjFdPTA7cmV0dXJuIG91dFB0ci1zdGFydFB0cn07dmFyIGxlbmd0aEJ5dGVzVVRGMTY9c3RyPT5zdHIubGVuZ3RoKjI7dmFyIFVURjMyVG9TdHJpbmc9KHB0cixtYXhCeXRlc1RvUmVhZCk9Pnt2YXIgaT0wO3ZhciBzdHI9XCJcIjt3aGlsZSghKGk+PW1heEJ5dGVzVG9SZWFkLzQpKXt2YXIgdXRmMzI9SEVBUDMyW3B0citpKjQ+PjJdO2lmKHV0ZjMyPT0wKWJyZWFrOysraTtpZih1dGYzMj49NjU1MzYpe3ZhciBjaD11dGYzMi02NTUzNjtzdHIrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8Y2g+PjEwLDU2MzIwfGNoJjEwMjMpfWVsc2V7c3RyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHV0ZjMyKX19cmV0dXJuIHN0cn07dmFyIHN0cmluZ1RvVVRGMzI9KHN0cixvdXRQdHIsbWF4Qnl0ZXNUb1dyaXRlKT0+e2lmKG1heEJ5dGVzVG9Xcml0ZT09PXVuZGVmaW5lZCl7bWF4Qnl0ZXNUb1dyaXRlPTIxNDc0ODM2NDd9aWYobWF4Qnl0ZXNUb1dyaXRlPDQpcmV0dXJuIDA7dmFyIHN0YXJ0UHRyPW91dFB0cjt2YXIgZW5kUHRyPXN0YXJ0UHRyK21heEJ5dGVzVG9Xcml0ZS00O2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe3ZhciBjb2RlVW5pdD1zdHIuY2hhckNvZGVBdChpKTtpZihjb2RlVW5pdD49NTUyOTYmJmNvZGVVbml0PD01NzM0Myl7dmFyIHRyYWlsU3Vycm9nYXRlPXN0ci5jaGFyQ29kZUF0KCsraSk7Y29kZVVuaXQ9NjU1MzYrKChjb2RlVW5pdCYxMDIzKTw8MTApfHRyYWlsU3Vycm9nYXRlJjEwMjN9SEVBUDMyW291dFB0cj4+Ml09Y29kZVVuaXQ7b3V0UHRyKz00O2lmKG91dFB0cis0PmVuZFB0cilicmVha31IRUFQMzJbb3V0UHRyPj4yXT0wO3JldHVybiBvdXRQdHItc3RhcnRQdHJ9O3ZhciBsZW5ndGhCeXRlc1VURjMyPXN0cj0+e3ZhciBsZW49MDtmb3IodmFyIGk9MDtpPHN0ci5sZW5ndGg7KytpKXt2YXIgY29kZVVuaXQ9c3RyLmNoYXJDb2RlQXQoaSk7aWYoY29kZVVuaXQ+PTU1Mjk2JiZjb2RlVW5pdDw9NTczNDMpKytpO2xlbis9NH1yZXR1cm4gbGVufTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmc9KHJhd1R5cGUsY2hhclNpemUsbmFtZSk9PntuYW1lPXJlYWRMYXRpbjFTdHJpbmcobmFtZSk7dmFyIGRlY29kZVN0cmluZyxlbmNvZGVTdHJpbmcsZ2V0SGVhcCxsZW5ndGhCeXRlc1VURixzaGlmdDtpZihjaGFyU2l6ZT09PTIpe2RlY29kZVN0cmluZz1VVEYxNlRvU3RyaW5nO2VuY29kZVN0cmluZz1zdHJpbmdUb1VURjE2O2xlbmd0aEJ5dGVzVVRGPWxlbmd0aEJ5dGVzVVRGMTY7Z2V0SGVhcD0oKT0+SEVBUFUxNjtzaGlmdD0xfWVsc2UgaWYoY2hhclNpemU9PT00KXtkZWNvZGVTdHJpbmc9VVRGMzJUb1N0cmluZztlbmNvZGVTdHJpbmc9c3RyaW5nVG9VVEYzMjtsZW5ndGhCeXRlc1VURj1sZW5ndGhCeXRlc1VURjMyO2dldEhlYXA9KCk9PkhFQVBVMzI7c2hpZnQ9Mn1yZWdpc3RlclR5cGUocmF3VHlwZSx7bmFtZTpuYW1lLFwiZnJvbVdpcmVUeXBlXCI6dmFsdWU9Pnt2YXIgbGVuZ3RoPUhFQVBVMzJbdmFsdWU+PjJdO3ZhciBIRUFQPWdldEhlYXAoKTt2YXIgc3RyO3ZhciBkZWNvZGVTdGFydFB0cj12YWx1ZSs0O2Zvcih2YXIgaT0wO2k8PWxlbmd0aDsrK2kpe3ZhciBjdXJyZW50Qnl0ZVB0cj12YWx1ZSs0K2kqY2hhclNpemU7aWYoaT09bGVuZ3RofHxIRUFQW2N1cnJlbnRCeXRlUHRyPj5zaGlmdF09PTApe3ZhciBtYXhSZWFkQnl0ZXM9Y3VycmVudEJ5dGVQdHItZGVjb2RlU3RhcnRQdHI7dmFyIHN0cmluZ1NlZ21lbnQ9ZGVjb2RlU3RyaW5nKGRlY29kZVN0YXJ0UHRyLG1heFJlYWRCeXRlcyk7aWYoc3RyPT09dW5kZWZpbmVkKXtzdHI9c3RyaW5nU2VnbWVudH1lbHNle3N0cis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKTtzdHIrPXN0cmluZ1NlZ21lbnR9ZGVjb2RlU3RhcnRQdHI9Y3VycmVudEJ5dGVQdHIrY2hhclNpemV9fV9mcmVlKHZhbHVlKTtyZXR1cm4gc3RyfSxcInRvV2lyZVR5cGVcIjooZGVzdHJ1Y3RvcnMsdmFsdWUpPT57aWYoISh0eXBlb2YgdmFsdWU9PVwic3RyaW5nXCIpKXt0aHJvd0JpbmRpbmdFcnJvcihgQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgJHtuYW1lfWApfXZhciBsZW5ndGg9bGVuZ3RoQnl0ZXNVVEYodmFsdWUpO3ZhciBwdHI9X21hbGxvYyg0K2xlbmd0aCtjaGFyU2l6ZSk7SEVBUFUzMltwdHI+PjJdPWxlbmd0aD4+c2hpZnQ7ZW5jb2RlU3RyaW5nKHZhbHVlLHB0cis0LGxlbmd0aCtjaGFyU2l6ZSk7aWYoZGVzdHJ1Y3RvcnMhPT1udWxsKXtkZXN0cnVjdG9ycy5wdXNoKF9mcmVlLHB0cil9cmV0dXJuIHB0cn0sXCJhcmdQYWNrQWR2YW5jZVwiOkdlbmVyaWNXaXJlVHlwZVNpemUsXCJyZWFkVmFsdWVGcm9tUG9pbnRlclwiOnNpbXBsZVJlYWRWYWx1ZUZyb21Qb2ludGVyLGRlc3RydWN0b3JGdW5jdGlvbihwdHIpe19mcmVlKHB0cil9fSl9O3ZhciBfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9hcnJheT0ocmF3VHlwZSxuYW1lLGNvbnN0cnVjdG9yU2lnbmF0dXJlLHJhd0NvbnN0cnVjdG9yLGRlc3RydWN0b3JTaWduYXR1cmUscmF3RGVzdHJ1Y3Rvcik9Pnt0dXBsZVJlZ2lzdHJhdGlvbnNbcmF3VHlwZV09e25hbWU6cmVhZExhdGluMVN0cmluZyhuYW1lKSxyYXdDb25zdHJ1Y3RvcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihjb25zdHJ1Y3RvclNpZ25hdHVyZSxyYXdDb25zdHJ1Y3RvcikscmF3RGVzdHJ1Y3RvcjplbWJpbmRfX3JlcXVpcmVGdW5jdGlvbihkZXN0cnVjdG9yU2lnbmF0dXJlLHJhd0Rlc3RydWN0b3IpLGVsZW1lbnRzOltdfX07dmFyIF9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX2FycmF5X2VsZW1lbnQ9KHJhd1R1cGxlVHlwZSxnZXR0ZXJSZXR1cm5UeXBlLGdldHRlclNpZ25hdHVyZSxnZXR0ZXIsZ2V0dGVyQ29udGV4dCxzZXR0ZXJBcmd1bWVudFR5cGUsc2V0dGVyU2lnbmF0dXJlLHNldHRlcixzZXR0ZXJDb250ZXh0KT0+e3R1cGxlUmVnaXN0cmF0aW9uc1tyYXdUdXBsZVR5cGVdLmVsZW1lbnRzLnB1c2goe2dldHRlclJldHVyblR5cGU6Z2V0dGVyUmV0dXJuVHlwZSxnZXR0ZXI6ZW1iaW5kX19yZXF1aXJlRnVuY3Rpb24oZ2V0dGVyU2lnbmF0dXJlLGdldHRlciksZ2V0dGVyQ29udGV4dDpnZXR0ZXJDb250ZXh0LHNldHRlckFyZ3VtZW50VHlwZTpzZXR0ZXJBcmd1bWVudFR5cGUsc2V0dGVyOmVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uKHNldHRlclNpZ25hdHVyZSxzZXR0ZXIpLHNldHRlckNvbnRleHQ6c2V0dGVyQ29udGV4dH0pfTt2YXIgX19lbWJpbmRfcmVnaXN0ZXJfdm9pZD0ocmF3VHlwZSxuYW1lKT0+e25hbWU9cmVhZExhdGluMVN0cmluZyhuYW1lKTtyZWdpc3RlclR5cGUocmF3VHlwZSx7aXNWb2lkOnRydWUsbmFtZTpuYW1lLFwiYXJnUGFja0FkdmFuY2VcIjowLFwiZnJvbVdpcmVUeXBlXCI6KCk9PnVuZGVmaW5lZCxcInRvV2lyZVR5cGVcIjooZGVzdHJ1Y3RvcnMsbyk9PnVuZGVmaW5lZH0pfTt2YXIgX2Fib3J0PSgpPT57YWJvcnQoXCJcIil9O3ZhciBfZW1zY3JpcHRlbl9tZW1jcHlfanM9KGRlc3Qsc3JjLG51bSk9PkhFQVBVOC5jb3B5V2l0aGluKGRlc3Qsc3JjLHNyYytudW0pO3ZhciBnZXRIZWFwTWF4PSgpPT4yMTQ3NDgzNjQ4O3ZhciBncm93TWVtb3J5PXNpemU9Pnt2YXIgYj13YXNtTWVtb3J5LmJ1ZmZlcjt2YXIgcGFnZXM9KHNpemUtYi5ieXRlTGVuZ3RoKzY1NTM1KS82NTUzNjt0cnl7d2FzbU1lbW9yeS5ncm93KHBhZ2VzKTt1cGRhdGVNZW1vcnlWaWV3cygpO3JldHVybiAxfWNhdGNoKGUpe319O3ZhciBfZW1zY3JpcHRlbl9yZXNpemVfaGVhcD1yZXF1ZXN0ZWRTaXplPT57dmFyIG9sZFNpemU9SEVBUFU4Lmxlbmd0aDtyZXF1ZXN0ZWRTaXplPj4+PTA7dmFyIG1heEhlYXBTaXplPWdldEhlYXBNYXgoKTtpZihyZXF1ZXN0ZWRTaXplPm1heEhlYXBTaXplKXtyZXR1cm4gZmFsc2V9dmFyIGFsaWduVXA9KHgsbXVsdGlwbGUpPT54KyhtdWx0aXBsZS14JW11bHRpcGxlKSVtdWx0aXBsZTtmb3IodmFyIGN1dERvd249MTtjdXREb3duPD00O2N1dERvd24qPTIpe3ZhciBvdmVyR3Jvd25IZWFwU2l6ZT1vbGRTaXplKigxKy4yL2N1dERvd24pO292ZXJHcm93bkhlYXBTaXplPU1hdGgubWluKG92ZXJHcm93bkhlYXBTaXplLHJlcXVlc3RlZFNpemUrMTAwNjYzMjk2KTt2YXIgbmV3U2l6ZT1NYXRoLm1pbihtYXhIZWFwU2l6ZSxhbGlnblVwKE1hdGgubWF4KHJlcXVlc3RlZFNpemUsb3Zlckdyb3duSGVhcFNpemUpLDY1NTM2KSk7dmFyIHJlcGxhY2VtZW50PWdyb3dNZW1vcnkobmV3U2l6ZSk7aWYocmVwbGFjZW1lbnQpe3JldHVybiB0cnVlfX1yZXR1cm4gZmFsc2V9O3ZhciBFTlY9e307dmFyIGdldEV4ZWN1dGFibGVOYW1lPSgpPT50aGlzUHJvZ3JhbXx8XCIuL3RoaXMucHJvZ3JhbVwiO3ZhciBnZXRFbnZTdHJpbmdzPSgpPT57aWYoIWdldEVudlN0cmluZ3Muc3RyaW5ncyl7dmFyIGxhbmc9KHR5cGVvZiBuYXZpZ2F0b3I9PVwib2JqZWN0XCImJm5hdmlnYXRvci5sYW5ndWFnZXMmJm5hdmlnYXRvci5sYW5ndWFnZXNbMF18fFwiQ1wiKS5yZXBsYWNlKFwiLVwiLFwiX1wiKStcIi5VVEYtOFwiO3ZhciBlbnY9e1wiVVNFUlwiOlwid2ViX3VzZXJcIixcIkxPR05BTUVcIjpcIndlYl91c2VyXCIsXCJQQVRIXCI6XCIvXCIsXCJQV0RcIjpcIi9cIixcIkhPTUVcIjpcIi9ob21lL3dlYl91c2VyXCIsXCJMQU5HXCI6bGFuZyxcIl9cIjpnZXRFeGVjdXRhYmxlTmFtZSgpfTtmb3IodmFyIHggaW4gRU5WKXtpZihFTlZbeF09PT11bmRlZmluZWQpZGVsZXRlIGVudlt4XTtlbHNlIGVudlt4XT1FTlZbeF19dmFyIHN0cmluZ3M9W107Zm9yKHZhciB4IGluIGVudil7c3RyaW5ncy5wdXNoKGAke3h9PSR7ZW52W3hdfWApfWdldEVudlN0cmluZ3Muc3RyaW5ncz1zdHJpbmdzfXJldHVybiBnZXRFbnZTdHJpbmdzLnN0cmluZ3N9O3ZhciBzdHJpbmdUb0FzY2lpPShzdHIsYnVmZmVyKT0+e2Zvcih2YXIgaT0wO2k8c3RyLmxlbmd0aDsrK2kpe0hFQVA4W2J1ZmZlcisrPj4wXT1zdHIuY2hhckNvZGVBdChpKX1IRUFQOFtidWZmZXI+PjBdPTB9O3ZhciBQQVRIPXtpc0FiczpwYXRoPT5wYXRoLmNoYXJBdCgwKT09PVwiL1wiLHNwbGl0UGF0aDpmaWxlbmFtZT0+e3ZhciBzcGxpdFBhdGhSZT0vXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztyZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSl9LG5vcm1hbGl6ZUFycmF5OihwYXJ0cyxhbGxvd0Fib3ZlUm9vdCk9Pnt2YXIgdXA9MDtmb3IodmFyIGk9cGFydHMubGVuZ3RoLTE7aT49MDtpLS0pe3ZhciBsYXN0PXBhcnRzW2ldO2lmKGxhc3Q9PT1cIi5cIil7cGFydHMuc3BsaWNlKGksMSl9ZWxzZSBpZihsYXN0PT09XCIuLlwiKXtwYXJ0cy5zcGxpY2UoaSwxKTt1cCsrfWVsc2UgaWYodXApe3BhcnRzLnNwbGljZShpLDEpO3VwLS19fWlmKGFsbG93QWJvdmVSb290KXtmb3IoO3VwO3VwLS0pe3BhcnRzLnVuc2hpZnQoXCIuLlwiKX19cmV0dXJuIHBhcnRzfSxub3JtYWxpemU6cGF0aD0+e3ZhciBpc0Fic29sdXRlPVBBVEguaXNBYnMocGF0aCksdHJhaWxpbmdTbGFzaD1wYXRoLnN1YnN0cigtMSk9PT1cIi9cIjtwYXRoPVBBVEgubm9ybWFsaXplQXJyYXkocGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKHA9PiEhcCksIWlzQWJzb2x1dGUpLmpvaW4oXCIvXCIpO2lmKCFwYXRoJiYhaXNBYnNvbHV0ZSl7cGF0aD1cIi5cIn1pZihwYXRoJiZ0cmFpbGluZ1NsYXNoKXtwYXRoKz1cIi9cIn1yZXR1cm4oaXNBYnNvbHV0ZT9cIi9cIjpcIlwiKStwYXRofSxkaXJuYW1lOnBhdGg9Pnt2YXIgcmVzdWx0PVBBVEguc3BsaXRQYXRoKHBhdGgpLHJvb3Q9cmVzdWx0WzBdLGRpcj1yZXN1bHRbMV07aWYoIXJvb3QmJiFkaXIpe3JldHVyblwiLlwifWlmKGRpcil7ZGlyPWRpci5zdWJzdHIoMCxkaXIubGVuZ3RoLTEpfXJldHVybiByb290K2Rpcn0sYmFzZW5hbWU6cGF0aD0+e2lmKHBhdGg9PT1cIi9cIilyZXR1cm5cIi9cIjtwYXRoPVBBVEgubm9ybWFsaXplKHBhdGgpO3BhdGg9cGF0aC5yZXBsYWNlKC9cXC8kLyxcIlwiKTt2YXIgbGFzdFNsYXNoPXBhdGgubGFzdEluZGV4T2YoXCIvXCIpO2lmKGxhc3RTbGFzaD09PS0xKXJldHVybiBwYXRoO3JldHVybiBwYXRoLnN1YnN0cihsYXN0U2xhc2grMSl9LGpvaW46ZnVuY3Rpb24oKXt2YXIgcGF0aHM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtyZXR1cm4gUEFUSC5ub3JtYWxpemUocGF0aHMuam9pbihcIi9cIikpfSxqb2luMjoobCxyKT0+UEFUSC5ub3JtYWxpemUobCtcIi9cIityKX07dmFyIGluaXRSYW5kb21GaWxsPSgpPT57aWYodHlwZW9mIGNyeXB0bz09XCJvYmplY3RcIiYmdHlwZW9mIGNyeXB0b1tcImdldFJhbmRvbVZhbHVlc1wiXT09XCJmdW5jdGlvblwiKXtyZXR1cm4gdmlldz0+Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyh2aWV3KX1lbHNlIGFib3J0KFwiaW5pdFJhbmRvbURldmljZVwiKX07dmFyIHJhbmRvbUZpbGw9dmlldz0+KHJhbmRvbUZpbGw9aW5pdFJhbmRvbUZpbGwoKSkodmlldyk7dmFyIFBBVEhfRlM9e3Jlc29sdmU6ZnVuY3Rpb24oKXt2YXIgcmVzb2x2ZWRQYXRoPVwiXCIscmVzb2x2ZWRBYnNvbHV0ZT1mYWxzZTtmb3IodmFyIGk9YXJndW1lbnRzLmxlbmd0aC0xO2k+PS0xJiYhcmVzb2x2ZWRBYnNvbHV0ZTtpLS0pe3ZhciBwYXRoPWk+PTA/YXJndW1lbnRzW2ldOkZTLmN3ZCgpO2lmKHR5cGVvZiBwYXRoIT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3NcIil9ZWxzZSBpZighcGF0aCl7cmV0dXJuXCJcIn1yZXNvbHZlZFBhdGg9cGF0aCtcIi9cIityZXNvbHZlZFBhdGg7cmVzb2x2ZWRBYnNvbHV0ZT1QQVRILmlzQWJzKHBhdGgpfXJlc29sdmVkUGF0aD1QQVRILm5vcm1hbGl6ZUFycmF5KHJlc29sdmVkUGF0aC5zcGxpdChcIi9cIikuZmlsdGVyKHA9PiEhcCksIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oXCIvXCIpO3JldHVybihyZXNvbHZlZEFic29sdXRlP1wiL1wiOlwiXCIpK3Jlc29sdmVkUGF0aHx8XCIuXCJ9LHJlbGF0aXZlOihmcm9tLHRvKT0+e2Zyb209UEFUSF9GUy5yZXNvbHZlKGZyb20pLnN1YnN0cigxKTt0bz1QQVRIX0ZTLnJlc29sdmUodG8pLnN1YnN0cigxKTtmdW5jdGlvbiB0cmltKGFycil7dmFyIHN0YXJ0PTA7Zm9yKDtzdGFydDxhcnIubGVuZ3RoO3N0YXJ0Kyspe2lmKGFycltzdGFydF0hPT1cIlwiKWJyZWFrfXZhciBlbmQ9YXJyLmxlbmd0aC0xO2Zvcig7ZW5kPj0wO2VuZC0tKXtpZihhcnJbZW5kXSE9PVwiXCIpYnJlYWt9aWYoc3RhcnQ+ZW5kKXJldHVybltdO3JldHVybiBhcnIuc2xpY2Uoc3RhcnQsZW5kLXN0YXJ0KzEpfXZhciBmcm9tUGFydHM9dHJpbShmcm9tLnNwbGl0KFwiL1wiKSk7dmFyIHRvUGFydHM9dHJpbSh0by5zcGxpdChcIi9cIikpO3ZhciBsZW5ndGg9TWF0aC5taW4oZnJvbVBhcnRzLmxlbmd0aCx0b1BhcnRzLmxlbmd0aCk7dmFyIHNhbWVQYXJ0c0xlbmd0aD1sZW5ndGg7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXtpZihmcm9tUGFydHNbaV0hPT10b1BhcnRzW2ldKXtzYW1lUGFydHNMZW5ndGg9aTticmVha319dmFyIG91dHB1dFBhcnRzPVtdO2Zvcih2YXIgaT1zYW1lUGFydHNMZW5ndGg7aTxmcm9tUGFydHMubGVuZ3RoO2krKyl7b3V0cHV0UGFydHMucHVzaChcIi4uXCIpfW91dHB1dFBhcnRzPW91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO3JldHVybiBvdXRwdXRQYXJ0cy5qb2luKFwiL1wiKX19O3ZhciBGU19zdGRpbl9nZXRDaGFyX2J1ZmZlcj1bXTtmdW5jdGlvbiBpbnRBcnJheUZyb21TdHJpbmcoc3RyaW5neSxkb250QWRkTnVsbCxsZW5ndGgpe3ZhciBsZW49bGVuZ3RoPjA/bGVuZ3RoOmxlbmd0aEJ5dGVzVVRGOChzdHJpbmd5KSsxO3ZhciB1OGFycmF5PW5ldyBBcnJheShsZW4pO3ZhciBudW1CeXRlc1dyaXR0ZW49c3RyaW5nVG9VVEY4QXJyYXkoc3RyaW5neSx1OGFycmF5LDAsdThhcnJheS5sZW5ndGgpO2lmKGRvbnRBZGROdWxsKXU4YXJyYXkubGVuZ3RoPW51bUJ5dGVzV3JpdHRlbjtyZXR1cm4gdThhcnJheX12YXIgRlNfc3RkaW5fZ2V0Q2hhcj0oKT0+e2lmKCFGU19zdGRpbl9nZXRDaGFyX2J1ZmZlci5sZW5ndGgpe3ZhciByZXN1bHQ9bnVsbDtpZih0eXBlb2Ygd2luZG93IT1cInVuZGVmaW5lZFwiJiZ0eXBlb2Ygd2luZG93LnByb21wdD09XCJmdW5jdGlvblwiKXtyZXN1bHQ9d2luZG93LnByb21wdChcIklucHV0OiBcIik7aWYocmVzdWx0IT09bnVsbCl7cmVzdWx0Kz1cIlxcblwifX1lbHNlIGlmKHR5cGVvZiByZWFkbGluZT09XCJmdW5jdGlvblwiKXtyZXN1bHQ9cmVhZGxpbmUoKTtpZihyZXN1bHQhPT1udWxsKXtyZXN1bHQrPVwiXFxuXCJ9fWlmKCFyZXN1bHQpe3JldHVybiBudWxsfUZTX3N0ZGluX2dldENoYXJfYnVmZmVyPWludEFycmF5RnJvbVN0cmluZyhyZXN1bHQsdHJ1ZSl9cmV0dXJuIEZTX3N0ZGluX2dldENoYXJfYnVmZmVyLnNoaWZ0KCl9O3ZhciBUVFk9e3R0eXM6W10saW5pdCgpe30sc2h1dGRvd24oKXt9LHJlZ2lzdGVyKGRldixvcHMpe1RUWS50dHlzW2Rldl09e2lucHV0OltdLG91dHB1dDpbXSxvcHM6b3BzfTtGUy5yZWdpc3RlckRldmljZShkZXYsVFRZLnN0cmVhbV9vcHMpfSxzdHJlYW1fb3BzOntvcGVuKHN0cmVhbSl7dmFyIHR0eT1UVFkudHR5c1tzdHJlYW0ubm9kZS5yZGV2XTtpZighdHR5KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myl9c3RyZWFtLnR0eT10dHk7c3RyZWFtLnNlZWthYmxlPWZhbHNlfSxjbG9zZShzdHJlYW0pe3N0cmVhbS50dHkub3BzLmZzeW5jKHN0cmVhbS50dHkpfSxmc3luYyhzdHJlYW0pe3N0cmVhbS50dHkub3BzLmZzeW5jKHN0cmVhbS50dHkpfSxyZWFkKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3Mpe2lmKCFzdHJlYW0udHR5fHwhc3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYwKX12YXIgYnl0ZXNSZWFkPTA7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt2YXIgcmVzdWx0O3RyeXtyZXN1bHQ9c3RyZWFtLnR0eS5vcHMuZ2V0X2NoYXIoc3RyZWFtLnR0eSl9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpfWlmKHJlc3VsdD09PXVuZGVmaW5lZCYmYnl0ZXNSZWFkPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNil9aWYocmVzdWx0PT09bnVsbHx8cmVzdWx0PT09dW5kZWZpbmVkKWJyZWFrO2J5dGVzUmVhZCsrO2J1ZmZlcltvZmZzZXQraV09cmVzdWx0fWlmKGJ5dGVzUmVhZCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCl9cmV0dXJuIGJ5dGVzUmVhZH0sd3JpdGUoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvcyl7aWYoIXN0cmVhbS50dHl8fCFzdHJlYW0udHR5Lm9wcy5wdXRfY2hhcil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjApfXRyeXtmb3IodmFyIGk9MDtpPGxlbmd0aDtpKyspe3N0cmVhbS50dHkub3BzLnB1dF9jaGFyKHN0cmVhbS50dHksYnVmZmVyW29mZnNldCtpXSl9fWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KX1pZihsZW5ndGgpe3N0cmVhbS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpfXJldHVybiBpfX0sZGVmYXVsdF90dHlfb3BzOntnZXRfY2hhcih0dHkpe3JldHVybiBGU19zdGRpbl9nZXRDaGFyKCl9LHB1dF9jaGFyKHR0eSx2YWwpe2lmKHZhbD09PW51bGx8fHZhbD09PTEwKXtvdXQoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwwKSk7dHR5Lm91dHB1dD1bXX1lbHNle2lmKHZhbCE9MCl0dHkub3V0cHV0LnB1c2godmFsKX19LGZzeW5jKHR0eSl7aWYodHR5Lm91dHB1dCYmdHR5Lm91dHB1dC5sZW5ndGg+MCl7b3V0KFVURjhBcnJheVRvU3RyaW5nKHR0eS5vdXRwdXQsMCkpO3R0eS5vdXRwdXQ9W119fSxpb2N0bF90Y2dldHModHR5KXtyZXR1cm57Y19pZmxhZzoyNTg1NixjX29mbGFnOjUsY19jZmxhZzoxOTEsY19sZmxhZzozNTM4NyxjX2NjOlszLDI4LDEyNywyMSw0LDAsMSwwLDE3LDE5LDI2LDAsMTgsMTUsMjMsMjIsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMF19fSxpb2N0bF90Y3NldHModHR5LG9wdGlvbmFsX2FjdGlvbnMsZGF0YSl7cmV0dXJuIDB9LGlvY3RsX3Rpb2Nnd2luc3oodHR5KXtyZXR1cm5bMjQsODBdfX0sZGVmYXVsdF90dHkxX29wczp7cHV0X2NoYXIodHR5LHZhbCl7aWYodmFsPT09bnVsbHx8dmFsPT09MTApe2VycihVVEY4QXJyYXlUb1N0cmluZyh0dHkub3V0cHV0LDApKTt0dHkub3V0cHV0PVtdfWVsc2V7aWYodmFsIT0wKXR0eS5vdXRwdXQucHVzaCh2YWwpfX0sZnN5bmModHR5KXtpZih0dHkub3V0cHV0JiZ0dHkub3V0cHV0Lmxlbmd0aD4wKXtlcnIoVVRGOEFycmF5VG9TdHJpbmcodHR5Lm91dHB1dCwwKSk7dHR5Lm91dHB1dD1bXX19fX07dmFyIG1tYXBBbGxvYz1zaXplPT57YWJvcnQoKX07dmFyIE1FTUZTPXtvcHNfdGFibGU6bnVsbCxtb3VudChtb3VudCl7cmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUobnVsbCxcIi9cIiwxNjM4NHw1MTEsMCl9LGNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxkZXYpe2lmKEZTLmlzQmxrZGV2KG1vZGUpfHxGUy5pc0ZJRk8obW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKX1pZighTUVNRlMub3BzX3RhYmxlKXtNRU1GUy5vcHNfdGFibGU9e2Rpcjp7bm9kZTp7Z2V0YXR0cjpNRU1GUy5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6TUVNRlMubm9kZV9vcHMuc2V0YXR0cixsb29rdXA6TUVNRlMubm9kZV9vcHMubG9va3VwLG1rbm9kOk1FTUZTLm5vZGVfb3BzLm1rbm9kLHJlbmFtZTpNRU1GUy5ub2RlX29wcy5yZW5hbWUsdW5saW5rOk1FTUZTLm5vZGVfb3BzLnVubGluayxybWRpcjpNRU1GUy5ub2RlX29wcy5ybWRpcixyZWFkZGlyOk1FTUZTLm5vZGVfb3BzLnJlYWRkaXIsc3ltbGluazpNRU1GUy5ub2RlX29wcy5zeW1saW5rfSxzdHJlYW06e2xsc2VlazpNRU1GUy5zdHJlYW1fb3BzLmxsc2Vla319LGZpbGU6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTp7bGxzZWVrOk1FTUZTLnN0cmVhbV9vcHMubGxzZWVrLHJlYWQ6TUVNRlMuc3RyZWFtX29wcy5yZWFkLHdyaXRlOk1FTUZTLnN0cmVhbV9vcHMud3JpdGUsYWxsb2NhdGU6TUVNRlMuc3RyZWFtX29wcy5hbGxvY2F0ZSxtbWFwOk1FTUZTLnN0cmVhbV9vcHMubW1hcCxtc3luYzpNRU1GUy5zdHJlYW1fb3BzLm1zeW5jfX0sbGluazp7bm9kZTp7Z2V0YXR0cjpNRU1GUy5ub2RlX29wcy5nZXRhdHRyLHNldGF0dHI6TUVNRlMubm9kZV9vcHMuc2V0YXR0cixyZWFkbGluazpNRU1GUy5ub2RlX29wcy5yZWFkbGlua30sc3RyZWFtOnt9fSxjaHJkZXY6e25vZGU6e2dldGF0dHI6TUVNRlMubm9kZV9vcHMuZ2V0YXR0cixzZXRhdHRyOk1FTUZTLm5vZGVfb3BzLnNldGF0dHJ9LHN0cmVhbTpGUy5jaHJkZXZfc3RyZWFtX29wc319fXZhciBub2RlPUZTLmNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxkZXYpO2lmKEZTLmlzRGlyKG5vZGUubW9kZSkpe25vZGUubm9kZV9vcHM9TUVNRlMub3BzX3RhYmxlLmRpci5ub2RlO25vZGUuc3RyZWFtX29wcz1NRU1GUy5vcHNfdGFibGUuZGlyLnN0cmVhbTtub2RlLmNvbnRlbnRzPXt9fWVsc2UgaWYoRlMuaXNGaWxlKG5vZGUubW9kZSkpe25vZGUubm9kZV9vcHM9TUVNRlMub3BzX3RhYmxlLmZpbGUubm9kZTtub2RlLnN0cmVhbV9vcHM9TUVNRlMub3BzX3RhYmxlLmZpbGUuc3RyZWFtO25vZGUudXNlZEJ5dGVzPTA7bm9kZS5jb250ZW50cz1udWxsfWVsc2UgaWYoRlMuaXNMaW5rKG5vZGUubW9kZSkpe25vZGUubm9kZV9vcHM9TUVNRlMub3BzX3RhYmxlLmxpbmsubm9kZTtub2RlLnN0cmVhbV9vcHM9TUVNRlMub3BzX3RhYmxlLmxpbmsuc3RyZWFtfWVsc2UgaWYoRlMuaXNDaHJkZXYobm9kZS5tb2RlKSl7bm9kZS5ub2RlX29wcz1NRU1GUy5vcHNfdGFibGUuY2hyZGV2Lm5vZGU7bm9kZS5zdHJlYW1fb3BzPU1FTUZTLm9wc190YWJsZS5jaHJkZXYuc3RyZWFtfW5vZGUudGltZXN0YW1wPURhdGUubm93KCk7aWYocGFyZW50KXtwYXJlbnQuY29udGVudHNbbmFtZV09bm9kZTtwYXJlbnQudGltZXN0YW1wPW5vZGUudGltZXN0YW1wfXJldHVybiBub2RlfSxnZXRGaWxlRGF0YUFzVHlwZWRBcnJheShub2RlKXtpZighbm9kZS5jb250ZW50cylyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7aWYobm9kZS5jb250ZW50cy5zdWJhcnJheSlyZXR1cm4gbm9kZS5jb250ZW50cy5zdWJhcnJheSgwLG5vZGUudXNlZEJ5dGVzKTtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkobm9kZS5jb250ZW50cyl9LGV4cGFuZEZpbGVTdG9yYWdlKG5vZGUsbmV3Q2FwYWNpdHkpe3ZhciBwcmV2Q2FwYWNpdHk9bm9kZS5jb250ZW50cz9ub2RlLmNvbnRlbnRzLmxlbmd0aDowO2lmKHByZXZDYXBhY2l0eT49bmV3Q2FwYWNpdHkpcmV0dXJuO3ZhciBDQVBBQ0lUWV9ET1VCTElOR19NQVg9MTAyNCoxMDI0O25ld0NhcGFjaXR5PU1hdGgubWF4KG5ld0NhcGFjaXR5LHByZXZDYXBhY2l0eSoocHJldkNhcGFjaXR5PENBUEFDSVRZX0RPVUJMSU5HX01BWD8yOjEuMTI1KT4+PjApO2lmKHByZXZDYXBhY2l0eSE9MCluZXdDYXBhY2l0eT1NYXRoLm1heChuZXdDYXBhY2l0eSwyNTYpO3ZhciBvbGRDb250ZW50cz1ub2RlLmNvbnRlbnRzO25vZGUuY29udGVudHM9bmV3IFVpbnQ4QXJyYXkobmV3Q2FwYWNpdHkpO2lmKG5vZGUudXNlZEJ5dGVzPjApbm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCxub2RlLnVzZWRCeXRlcyksMCl9LHJlc2l6ZUZpbGVTdG9yYWdlKG5vZGUsbmV3U2l6ZSl7aWYobm9kZS51c2VkQnl0ZXM9PW5ld1NpemUpcmV0dXJuO2lmKG5ld1NpemU9PTApe25vZGUuY29udGVudHM9bnVsbDtub2RlLnVzZWRCeXRlcz0wfWVsc2V7dmFyIG9sZENvbnRlbnRzPW5vZGUuY29udGVudHM7bm9kZS5jb250ZW50cz1uZXcgVWludDhBcnJheShuZXdTaXplKTtpZihvbGRDb250ZW50cyl7bm9kZS5jb250ZW50cy5zZXQob2xkQ29udGVudHMuc3ViYXJyYXkoMCxNYXRoLm1pbihuZXdTaXplLG5vZGUudXNlZEJ5dGVzKSkpfW5vZGUudXNlZEJ5dGVzPW5ld1NpemV9fSxub2RlX29wczp7Z2V0YXR0cihub2RlKXt2YXIgYXR0cj17fTthdHRyLmRldj1GUy5pc0NocmRldihub2RlLm1vZGUpP25vZGUuaWQ6MTthdHRyLmlubz1ub2RlLmlkO2F0dHIubW9kZT1ub2RlLm1vZGU7YXR0ci5ubGluaz0xO2F0dHIudWlkPTA7YXR0ci5naWQ9MDthdHRyLnJkZXY9bm9kZS5yZGV2O2lmKEZTLmlzRGlyKG5vZGUubW9kZSkpe2F0dHIuc2l6ZT00MDk2fWVsc2UgaWYoRlMuaXNGaWxlKG5vZGUubW9kZSkpe2F0dHIuc2l6ZT1ub2RlLnVzZWRCeXRlc31lbHNlIGlmKEZTLmlzTGluayhub2RlLm1vZGUpKXthdHRyLnNpemU9bm9kZS5saW5rLmxlbmd0aH1lbHNle2F0dHIuc2l6ZT0wfWF0dHIuYXRpbWU9bmV3IERhdGUobm9kZS50aW1lc3RhbXApO2F0dHIubXRpbWU9bmV3IERhdGUobm9kZS50aW1lc3RhbXApO2F0dHIuY3RpbWU9bmV3IERhdGUobm9kZS50aW1lc3RhbXApO2F0dHIuYmxrc2l6ZT00MDk2O2F0dHIuYmxvY2tzPU1hdGguY2VpbChhdHRyLnNpemUvYXR0ci5ibGtzaXplKTtyZXR1cm4gYXR0cn0sc2V0YXR0cihub2RlLGF0dHIpe2lmKGF0dHIubW9kZSE9PXVuZGVmaW5lZCl7bm9kZS5tb2RlPWF0dHIubW9kZX1pZihhdHRyLnRpbWVzdGFtcCE9PXVuZGVmaW5lZCl7bm9kZS50aW1lc3RhbXA9YXR0ci50aW1lc3RhbXB9aWYoYXR0ci5zaXplIT09dW5kZWZpbmVkKXtNRU1GUy5yZXNpemVGaWxlU3RvcmFnZShub2RlLGF0dHIuc2l6ZSl9fSxsb29rdXAocGFyZW50LG5hbWUpe3Rocm93IEZTLmdlbmVyaWNFcnJvcnNbNDRdfSxta25vZChwYXJlbnQsbmFtZSxtb2RlLGRldil7cmV0dXJuIE1FTUZTLmNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxkZXYpfSxyZW5hbWUob2xkX25vZGUsbmV3X2RpcixuZXdfbmFtZSl7aWYoRlMuaXNEaXIob2xkX25vZGUubW9kZSkpe3ZhciBuZXdfbm9kZTt0cnl7bmV3X25vZGU9RlMubG9va3VwTm9kZShuZXdfZGlyLG5ld19uYW1lKX1jYXRjaChlKXt9aWYobmV3X25vZGUpe2Zvcih2YXIgaSBpbiBuZXdfbm9kZS5jb250ZW50cyl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTUpfX19ZGVsZXRlIG9sZF9ub2RlLnBhcmVudC5jb250ZW50c1tvbGRfbm9kZS5uYW1lXTtvbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wPURhdGUubm93KCk7b2xkX25vZGUubmFtZT1uZXdfbmFtZTtuZXdfZGlyLmNvbnRlbnRzW25ld19uYW1lXT1vbGRfbm9kZTtuZXdfZGlyLnRpbWVzdGFtcD1vbGRfbm9kZS5wYXJlbnQudGltZXN0YW1wO29sZF9ub2RlLnBhcmVudD1uZXdfZGlyfSx1bmxpbmsocGFyZW50LG5hbWUpe2RlbGV0ZSBwYXJlbnQuY29udGVudHNbbmFtZV07cGFyZW50LnRpbWVzdGFtcD1EYXRlLm5vdygpfSxybWRpcihwYXJlbnQsbmFtZSl7dmFyIG5vZGU9RlMubG9va3VwTm9kZShwYXJlbnQsbmFtZSk7Zm9yKHZhciBpIGluIG5vZGUuY29udGVudHMpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDU1KX1kZWxldGUgcGFyZW50LmNvbnRlbnRzW25hbWVdO3BhcmVudC50aW1lc3RhbXA9RGF0ZS5ub3coKX0scmVhZGRpcihub2RlKXt2YXIgZW50cmllcz1bXCIuXCIsXCIuLlwiXTtmb3IodmFyIGtleSBpbiBub2RlLmNvbnRlbnRzKXtpZighbm9kZS5jb250ZW50cy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtjb250aW51ZX1lbnRyaWVzLnB1c2goa2V5KX1yZXR1cm4gZW50cmllc30sc3ltbGluayhwYXJlbnQsbmV3bmFtZSxvbGRwYXRoKXt2YXIgbm9kZT1NRU1GUy5jcmVhdGVOb2RlKHBhcmVudCxuZXduYW1lLDUxMXw0MDk2MCwwKTtub2RlLmxpbms9b2xkcGF0aDtyZXR1cm4gbm9kZX0scmVhZGxpbmsobm9kZSl7aWYoIUZTLmlzTGluayhub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9cmV0dXJuIG5vZGUubGlua319LHN0cmVhbV9vcHM6e3JlYWQoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXt2YXIgY29udGVudHM9c3RyZWFtLm5vZGUuY29udGVudHM7aWYocG9zaXRpb24+PXN0cmVhbS5ub2RlLnVzZWRCeXRlcylyZXR1cm4gMDt2YXIgc2l6ZT1NYXRoLm1pbihzdHJlYW0ubm9kZS51c2VkQnl0ZXMtcG9zaXRpb24sbGVuZ3RoKTtpZihzaXplPjgmJmNvbnRlbnRzLnN1YmFycmF5KXtidWZmZXIuc2V0KGNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLHBvc2l0aW9uK3NpemUpLG9mZnNldCl9ZWxzZXtmb3IodmFyIGk9MDtpPHNpemU7aSsrKWJ1ZmZlcltvZmZzZXQraV09Y29udGVudHNbcG9zaXRpb24raV19cmV0dXJuIHNpemV9LHdyaXRlKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbixjYW5Pd24pe2lmKGJ1ZmZlci5idWZmZXI9PT1IRUFQOC5idWZmZXIpe2Nhbk93bj1mYWxzZX1pZighbGVuZ3RoKXJldHVybiAwO3ZhciBub2RlPXN0cmVhbS5ub2RlO25vZGUudGltZXN0YW1wPURhdGUubm93KCk7aWYoYnVmZmVyLnN1YmFycmF5JiYoIW5vZGUuY29udGVudHN8fG5vZGUuY29udGVudHMuc3ViYXJyYXkpKXtpZihjYW5Pd24pe25vZGUuY29udGVudHM9YnVmZmVyLnN1YmFycmF5KG9mZnNldCxvZmZzZXQrbGVuZ3RoKTtub2RlLnVzZWRCeXRlcz1sZW5ndGg7cmV0dXJuIGxlbmd0aH1lbHNlIGlmKG5vZGUudXNlZEJ5dGVzPT09MCYmcG9zaXRpb249PT0wKXtub2RlLmNvbnRlbnRzPWJ1ZmZlci5zbGljZShvZmZzZXQsb2Zmc2V0K2xlbmd0aCk7bm9kZS51c2VkQnl0ZXM9bGVuZ3RoO3JldHVybiBsZW5ndGh9ZWxzZSBpZihwb3NpdGlvbitsZW5ndGg8PW5vZGUudXNlZEJ5dGVzKXtub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LG9mZnNldCtsZW5ndGgpLHBvc2l0aW9uKTtyZXR1cm4gbGVuZ3RofX1NRU1GUy5leHBhbmRGaWxlU3RvcmFnZShub2RlLHBvc2l0aW9uK2xlbmd0aCk7aWYobm9kZS5jb250ZW50cy5zdWJhcnJheSYmYnVmZmVyLnN1YmFycmF5KXtub2RlLmNvbnRlbnRzLnNldChidWZmZXIuc3ViYXJyYXkob2Zmc2V0LG9mZnNldCtsZW5ndGgpLHBvc2l0aW9uKX1lbHNle2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7bm9kZS5jb250ZW50c1twb3NpdGlvbitpXT1idWZmZXJbb2Zmc2V0K2ldfX1ub2RlLnVzZWRCeXRlcz1NYXRoLm1heChub2RlLnVzZWRCeXRlcyxwb3NpdGlvbitsZW5ndGgpO3JldHVybiBsZW5ndGh9LGxsc2VlayhzdHJlYW0sb2Zmc2V0LHdoZW5jZSl7dmFyIHBvc2l0aW9uPW9mZnNldDtpZih3aGVuY2U9PT0xKXtwb3NpdGlvbis9c3RyZWFtLnBvc2l0aW9ufWVsc2UgaWYod2hlbmNlPT09Mil7aWYoRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXtwb3NpdGlvbis9c3RyZWFtLm5vZGUudXNlZEJ5dGVzfX1pZihwb3NpdGlvbjwwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9cmV0dXJuIHBvc2l0aW9ufSxhbGxvY2F0ZShzdHJlYW0sb2Zmc2V0LGxlbmd0aCl7TUVNRlMuZXhwYW5kRmlsZVN0b3JhZ2Uoc3RyZWFtLm5vZGUsb2Zmc2V0K2xlbmd0aCk7c3RyZWFtLm5vZGUudXNlZEJ5dGVzPU1hdGgubWF4KHN0cmVhbS5ub2RlLnVzZWRCeXRlcyxvZmZzZXQrbGVuZ3RoKX0sbW1hcChzdHJlYW0sbGVuZ3RoLHBvc2l0aW9uLHByb3QsZmxhZ3Mpe2lmKCFGUy5pc0ZpbGUoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKX12YXIgcHRyO3ZhciBhbGxvY2F0ZWQ7dmFyIGNvbnRlbnRzPXN0cmVhbS5ub2RlLmNvbnRlbnRzO2lmKCEoZmxhZ3MmMikmJmNvbnRlbnRzLmJ1ZmZlcj09PUhFQVA4LmJ1ZmZlcil7YWxsb2NhdGVkPWZhbHNlO3B0cj1jb250ZW50cy5ieXRlT2Zmc2V0fWVsc2V7aWYocG9zaXRpb24+MHx8cG9zaXRpb24rbGVuZ3RoPGNvbnRlbnRzLmxlbmd0aCl7aWYoY29udGVudHMuc3ViYXJyYXkpe2NvbnRlbnRzPWNvbnRlbnRzLnN1YmFycmF5KHBvc2l0aW9uLHBvc2l0aW9uK2xlbmd0aCl9ZWxzZXtjb250ZW50cz1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChjb250ZW50cyxwb3NpdGlvbixwb3NpdGlvbitsZW5ndGgpfX1hbGxvY2F0ZWQ9dHJ1ZTtwdHI9bW1hcEFsbG9jKGxlbmd0aCk7aWYoIXB0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpfUhFQVA4LnNldChjb250ZW50cyxwdHIpfXJldHVybntwdHI6cHRyLGFsbG9jYXRlZDphbGxvY2F0ZWR9fSxtc3luYyhzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgsbW1hcEZsYWdzKXtNRU1GUy5zdHJlYW1fb3BzLndyaXRlKHN0cmVhbSxidWZmZXIsMCxsZW5ndGgsb2Zmc2V0LGZhbHNlKTtyZXR1cm4gMH19fTt2YXIgYXN5bmNMb2FkPSh1cmwsb25sb2FkLG9uZXJyb3Isbm9SdW5EZXApPT57dmFyIGRlcD0hbm9SdW5EZXA/Z2V0VW5pcXVlUnVuRGVwZW5kZW5jeShgYWwgJHt1cmx9YCk6XCJcIjtyZWFkQXN5bmModXJsLGFycmF5QnVmZmVyPT57YXNzZXJ0KGFycmF5QnVmZmVyLGBMb2FkaW5nIGRhdGEgZmlsZSBcIiR7dXJsfVwiIGZhaWxlZCAobm8gYXJyYXlCdWZmZXIpLmApO29ubG9hZChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO2lmKGRlcClyZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCl9LGV2ZW50PT57aWYob25lcnJvcil7b25lcnJvcigpfWVsc2V7dGhyb3dgTG9hZGluZyBkYXRhIGZpbGUgXCIke3VybH1cIiBmYWlsZWQuYH19KTtpZihkZXApYWRkUnVuRGVwZW5kZW5jeShkZXApfTt2YXIgRlNfY3JlYXRlRGF0YUZpbGU9KHBhcmVudCxuYW1lLGZpbGVEYXRhLGNhblJlYWQsY2FuV3JpdGUsY2FuT3duKT0+e0ZTLmNyZWF0ZURhdGFGaWxlKHBhcmVudCxuYW1lLGZpbGVEYXRhLGNhblJlYWQsY2FuV3JpdGUsY2FuT3duKX07dmFyIHByZWxvYWRQbHVnaW5zPU1vZHVsZVtcInByZWxvYWRQbHVnaW5zXCJdfHxbXTt2YXIgRlNfaGFuZGxlZEJ5UHJlbG9hZFBsdWdpbj0oYnl0ZUFycmF5LGZ1bGxuYW1lLGZpbmlzaCxvbmVycm9yKT0+e2lmKHR5cGVvZiBCcm93c2VyIT1cInVuZGVmaW5lZFwiKUJyb3dzZXIuaW5pdCgpO3ZhciBoYW5kbGVkPWZhbHNlO3ByZWxvYWRQbHVnaW5zLmZvckVhY2gocGx1Z2luPT57aWYoaGFuZGxlZClyZXR1cm47aWYocGx1Z2luW1wiY2FuSGFuZGxlXCJdKGZ1bGxuYW1lKSl7cGx1Z2luW1wiaGFuZGxlXCJdKGJ5dGVBcnJheSxmdWxsbmFtZSxmaW5pc2gsb25lcnJvcik7aGFuZGxlZD10cnVlfX0pO3JldHVybiBoYW5kbGVkfTt2YXIgRlNfY3JlYXRlUHJlbG9hZGVkRmlsZT0ocGFyZW50LG5hbWUsdXJsLGNhblJlYWQsY2FuV3JpdGUsb25sb2FkLG9uZXJyb3IsZG9udENyZWF0ZUZpbGUsY2FuT3duLHByZUZpbmlzaCk9Pnt2YXIgZnVsbG5hbWU9bmFtZT9QQVRIX0ZTLnJlc29sdmUoUEFUSC5qb2luMihwYXJlbnQsbmFtZSkpOnBhcmVudDt2YXIgZGVwPWdldFVuaXF1ZVJ1bkRlcGVuZGVuY3koYGNwICR7ZnVsbG5hbWV9YCk7ZnVuY3Rpb24gcHJvY2Vzc0RhdGEoYnl0ZUFycmF5KXtmdW5jdGlvbiBmaW5pc2goYnl0ZUFycmF5KXtpZihwcmVGaW5pc2gpcHJlRmluaXNoKCk7aWYoIWRvbnRDcmVhdGVGaWxlKXtGU19jcmVhdGVEYXRhRmlsZShwYXJlbnQsbmFtZSxieXRlQXJyYXksY2FuUmVhZCxjYW5Xcml0ZSxjYW5Pd24pfWlmKG9ubG9hZClvbmxvYWQoKTtyZW1vdmVSdW5EZXBlbmRlbmN5KGRlcCl9aWYoRlNfaGFuZGxlZEJ5UHJlbG9hZFBsdWdpbihieXRlQXJyYXksZnVsbG5hbWUsZmluaXNoLCgpPT57aWYob25lcnJvcilvbmVycm9yKCk7cmVtb3ZlUnVuRGVwZW5kZW5jeShkZXApfSkpe3JldHVybn1maW5pc2goYnl0ZUFycmF5KX1hZGRSdW5EZXBlbmRlbmN5KGRlcCk7aWYodHlwZW9mIHVybD09XCJzdHJpbmdcIil7YXN5bmNMb2FkKHVybCxieXRlQXJyYXk9PnByb2Nlc3NEYXRhKGJ5dGVBcnJheSksb25lcnJvcil9ZWxzZXtwcm9jZXNzRGF0YSh1cmwpfX07dmFyIEZTX21vZGVTdHJpbmdUb0ZsYWdzPXN0cj0+e3ZhciBmbGFnTW9kZXM9e1wiclwiOjAsXCJyK1wiOjIsXCJ3XCI6NTEyfDY0fDEsXCJ3K1wiOjUxMnw2NHwyLFwiYVwiOjEwMjR8NjR8MSxcImErXCI6MTAyNHw2NHwyfTt2YXIgZmxhZ3M9ZmxhZ01vZGVzW3N0cl07aWYodHlwZW9mIGZsYWdzPT1cInVuZGVmaW5lZFwiKXt0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZmlsZSBvcGVuIG1vZGU6ICR7c3RyfWApfXJldHVybiBmbGFnc307dmFyIEZTX2dldE1vZGU9KGNhblJlYWQsY2FuV3JpdGUpPT57dmFyIG1vZGU9MDtpZihjYW5SZWFkKW1vZGV8PTI5Mnw3MztpZihjYW5Xcml0ZSltb2RlfD0xNDY7cmV0dXJuIG1vZGV9O3ZhciBGUz17cm9vdDpudWxsLG1vdW50czpbXSxkZXZpY2VzOnt9LHN0cmVhbXM6W10sbmV4dElub2RlOjEsbmFtZVRhYmxlOm51bGwsY3VycmVudFBhdGg6XCIvXCIsaW5pdGlhbGl6ZWQ6ZmFsc2UsaWdub3JlUGVybWlzc2lvbnM6dHJ1ZSxFcnJub0Vycm9yOm51bGwsZ2VuZXJpY0Vycm9yczp7fSxmaWxlc3lzdGVtczpudWxsLHN5bmNGU1JlcXVlc3RzOjAsbG9va3VwUGF0aChwYXRoLG9wdHM9e30pe3BhdGg9UEFUSF9GUy5yZXNvbHZlKHBhdGgpO2lmKCFwYXRoKXJldHVybntwYXRoOlwiXCIsbm9kZTpudWxsfTt2YXIgZGVmYXVsdHM9e2ZvbGxvd19tb3VudDp0cnVlLHJlY3Vyc2VfY291bnQ6MH07b3B0cz1PYmplY3QuYXNzaWduKGRlZmF1bHRzLG9wdHMpO2lmKG9wdHMucmVjdXJzZV9jb3VudD44KXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMil9dmFyIHBhcnRzPXBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihwPT4hIXApO3ZhciBjdXJyZW50PUZTLnJvb3Q7dmFyIGN1cnJlbnRfcGF0aD1cIi9cIjtmb3IodmFyIGk9MDtpPHBhcnRzLmxlbmd0aDtpKyspe3ZhciBpc2xhc3Q9aT09PXBhcnRzLmxlbmd0aC0xO2lmKGlzbGFzdCYmb3B0cy5wYXJlbnQpe2JyZWFrfWN1cnJlbnQ9RlMubG9va3VwTm9kZShjdXJyZW50LHBhcnRzW2ldKTtjdXJyZW50X3BhdGg9UEFUSC5qb2luMihjdXJyZW50X3BhdGgscGFydHNbaV0pO2lmKEZTLmlzTW91bnRwb2ludChjdXJyZW50KSl7aWYoIWlzbGFzdHx8aXNsYXN0JiZvcHRzLmZvbGxvd19tb3VudCl7Y3VycmVudD1jdXJyZW50Lm1vdW50ZWQucm9vdH19aWYoIWlzbGFzdHx8b3B0cy5mb2xsb3cpe3ZhciBjb3VudD0wO3doaWxlKEZTLmlzTGluayhjdXJyZW50Lm1vZGUpKXt2YXIgbGluaz1GUy5yZWFkbGluayhjdXJyZW50X3BhdGgpO2N1cnJlbnRfcGF0aD1QQVRIX0ZTLnJlc29sdmUoUEFUSC5kaXJuYW1lKGN1cnJlbnRfcGF0aCksbGluayk7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKGN1cnJlbnRfcGF0aCx7cmVjdXJzZV9jb3VudDpvcHRzLnJlY3Vyc2VfY291bnQrMX0pO2N1cnJlbnQ9bG9va3VwLm5vZGU7aWYoY291bnQrKz40MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzIpfX19fXJldHVybntwYXRoOmN1cnJlbnRfcGF0aCxub2RlOmN1cnJlbnR9fSxnZXRQYXRoKG5vZGUpe3ZhciBwYXRoO3doaWxlKHRydWUpe2lmKEZTLmlzUm9vdChub2RlKSl7dmFyIG1vdW50PW5vZGUubW91bnQubW91bnRwb2ludDtpZighcGF0aClyZXR1cm4gbW91bnQ7cmV0dXJuIG1vdW50W21vdW50Lmxlbmd0aC0xXSE9PVwiL1wiP2Ake21vdW50fS8ke3BhdGh9YDptb3VudCtwYXRofXBhdGg9cGF0aD9gJHtub2RlLm5hbWV9LyR7cGF0aH1gOm5vZGUubmFtZTtub2RlPW5vZGUucGFyZW50fX0saGFzaE5hbWUocGFyZW50aWQsbmFtZSl7dmFyIGhhc2g9MDtmb3IodmFyIGk9MDtpPG5hbWUubGVuZ3RoO2krKyl7aGFzaD0oaGFzaDw8NSktaGFzaCtuYW1lLmNoYXJDb2RlQXQoaSl8MH1yZXR1cm4ocGFyZW50aWQraGFzaD4+PjApJUZTLm5hbWVUYWJsZS5sZW5ndGh9LGhhc2hBZGROb2RlKG5vZGUpe3ZhciBoYXNoPUZTLmhhc2hOYW1lKG5vZGUucGFyZW50LmlkLG5vZGUubmFtZSk7bm9kZS5uYW1lX25leHQ9RlMubmFtZVRhYmxlW2hhc2hdO0ZTLm5hbWVUYWJsZVtoYXNoXT1ub2RlfSxoYXNoUmVtb3ZlTm9kZShub2RlKXt2YXIgaGFzaD1GUy5oYXNoTmFtZShub2RlLnBhcmVudC5pZCxub2RlLm5hbWUpO2lmKEZTLm5hbWVUYWJsZVtoYXNoXT09PW5vZGUpe0ZTLm5hbWVUYWJsZVtoYXNoXT1ub2RlLm5hbWVfbmV4dH1lbHNle3ZhciBjdXJyZW50PUZTLm5hbWVUYWJsZVtoYXNoXTt3aGlsZShjdXJyZW50KXtpZihjdXJyZW50Lm5hbWVfbmV4dD09PW5vZGUpe2N1cnJlbnQubmFtZV9uZXh0PW5vZGUubmFtZV9uZXh0O2JyZWFrfWN1cnJlbnQ9Y3VycmVudC5uYW1lX25leHR9fX0sbG9va3VwTm9kZShwYXJlbnQsbmFtZSl7dmFyIGVyckNvZGU9RlMubWF5TG9va3VwKHBhcmVudCk7aWYoZXJyQ29kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSxwYXJlbnQpfXZhciBoYXNoPUZTLmhhc2hOYW1lKHBhcmVudC5pZCxuYW1lKTtmb3IodmFyIG5vZGU9RlMubmFtZVRhYmxlW2hhc2hdO25vZGU7bm9kZT1ub2RlLm5hbWVfbmV4dCl7dmFyIG5vZGVOYW1lPW5vZGUubmFtZTtpZihub2RlLnBhcmVudC5pZD09PXBhcmVudC5pZCYmbm9kZU5hbWU9PT1uYW1lKXtyZXR1cm4gbm9kZX19cmV0dXJuIEZTLmxvb2t1cChwYXJlbnQsbmFtZSl9LGNyZWF0ZU5vZGUocGFyZW50LG5hbWUsbW9kZSxyZGV2KXt2YXIgbm9kZT1uZXcgRlMuRlNOb2RlKHBhcmVudCxuYW1lLG1vZGUscmRldik7RlMuaGFzaEFkZE5vZGUobm9kZSk7cmV0dXJuIG5vZGV9LGRlc3Ryb3lOb2RlKG5vZGUpe0ZTLmhhc2hSZW1vdmVOb2RlKG5vZGUpfSxpc1Jvb3Qobm9kZSl7cmV0dXJuIG5vZGU9PT1ub2RlLnBhcmVudH0saXNNb3VudHBvaW50KG5vZGUpe3JldHVybiEhbm9kZS5tb3VudGVkfSxpc0ZpbGUobW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09MzI3Njh9LGlzRGlyKG1vZGUpe3JldHVybihtb2RlJjYxNDQwKT09PTE2Mzg0fSxpc0xpbmsobW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09NDA5NjB9LGlzQ2hyZGV2KG1vZGUpe3JldHVybihtb2RlJjYxNDQwKT09PTgxOTJ9LGlzQmxrZGV2KG1vZGUpe3JldHVybihtb2RlJjYxNDQwKT09PTI0NTc2fSxpc0ZJRk8obW9kZSl7cmV0dXJuKG1vZGUmNjE0NDApPT09NDA5Nn0saXNTb2NrZXQobW9kZSl7cmV0dXJuKG1vZGUmNDkxNTIpPT09NDkxNTJ9LGZsYWdzVG9QZXJtaXNzaW9uU3RyaW5nKGZsYWcpe3ZhciBwZXJtcz1bXCJyXCIsXCJ3XCIsXCJyd1wiXVtmbGFnJjNdO2lmKGZsYWcmNTEyKXtwZXJtcys9XCJ3XCJ9cmV0dXJuIHBlcm1zfSxub2RlUGVybWlzc2lvbnMobm9kZSxwZXJtcyl7aWYoRlMuaWdub3JlUGVybWlzc2lvbnMpe3JldHVybiAwfWlmKHBlcm1zLmluY2x1ZGVzKFwiclwiKSYmIShub2RlLm1vZGUmMjkyKSl7cmV0dXJuIDJ9ZWxzZSBpZihwZXJtcy5pbmNsdWRlcyhcIndcIikmJiEobm9kZS5tb2RlJjE0Nikpe3JldHVybiAyfWVsc2UgaWYocGVybXMuaW5jbHVkZXMoXCJ4XCIpJiYhKG5vZGUubW9kZSY3Mykpe3JldHVybiAyfXJldHVybiAwfSxtYXlMb29rdXAoZGlyKXt2YXIgZXJyQ29kZT1GUy5ub2RlUGVybWlzc2lvbnMoZGlyLFwieFwiKTtpZihlcnJDb2RlKXJldHVybiBlcnJDb2RlO2lmKCFkaXIubm9kZV9vcHMubG9va3VwKXJldHVybiAyO3JldHVybiAwfSxtYXlDcmVhdGUoZGlyLG5hbWUpe3RyeXt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKGRpcixuYW1lKTtyZXR1cm4gMjB9Y2F0Y2goZSl7fXJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMoZGlyLFwid3hcIil9LG1heURlbGV0ZShkaXIsbmFtZSxpc2Rpcil7dmFyIG5vZGU7dHJ5e25vZGU9RlMubG9va3VwTm9kZShkaXIsbmFtZSl9Y2F0Y2goZSl7cmV0dXJuIGUuZXJybm99dmFyIGVyckNvZGU9RlMubm9kZVBlcm1pc3Npb25zKGRpcixcInd4XCIpO2lmKGVyckNvZGUpe3JldHVybiBlcnJDb2RlfWlmKGlzZGlyKXtpZighRlMuaXNEaXIobm9kZS5tb2RlKSl7cmV0dXJuIDU0fWlmKEZTLmlzUm9vdChub2RlKXx8RlMuZ2V0UGF0aChub2RlKT09PUZTLmN3ZCgpKXtyZXR1cm4gMTB9fWVsc2V7aWYoRlMuaXNEaXIobm9kZS5tb2RlKSl7cmV0dXJuIDMxfX1yZXR1cm4gMH0sbWF5T3Blbihub2RlLGZsYWdzKXtpZighbm9kZSl7cmV0dXJuIDQ0fWlmKEZTLmlzTGluayhub2RlLm1vZGUpKXtyZXR1cm4gMzJ9ZWxzZSBpZihGUy5pc0Rpcihub2RlLm1vZGUpKXtpZihGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykhPT1cInJcInx8ZmxhZ3MmNTEyKXtyZXR1cm4gMzF9fXJldHVybiBGUy5ub2RlUGVybWlzc2lvbnMobm9kZSxGUy5mbGFnc1RvUGVybWlzc2lvblN0cmluZyhmbGFncykpfSxNQVhfT1BFTl9GRFM6NDA5NixuZXh0ZmQoKXtmb3IodmFyIGZkPTA7ZmQ8PUZTLk1BWF9PUEVOX0ZEUztmZCsrKXtpZighRlMuc3RyZWFtc1tmZF0pe3JldHVybiBmZH19dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzMpfSxnZXRTdHJlYW1DaGVja2VkKGZkKXt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbShmZCk7aWYoIXN0cmVhbSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCl9cmV0dXJuIHN0cmVhbX0sZ2V0U3RyZWFtOmZkPT5GUy5zdHJlYW1zW2ZkXSxjcmVhdGVTdHJlYW0oc3RyZWFtLGZkPS0xKXtpZighRlMuRlNTdHJlYW0pe0ZTLkZTU3RyZWFtPWZ1bmN0aW9uKCl7dGhpcy5zaGFyZWQ9e319O0ZTLkZTU3RyZWFtLnByb3RvdHlwZT17fTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhGUy5GU1N0cmVhbS5wcm90b3R5cGUse29iamVjdDp7Z2V0KCl7cmV0dXJuIHRoaXMubm9kZX0sc2V0KHZhbCl7dGhpcy5ub2RlPXZhbH19LGlzUmVhZDp7Z2V0KCl7cmV0dXJuKHRoaXMuZmxhZ3MmMjA5NzE1NSkhPT0xfX0saXNXcml0ZTp7Z2V0KCl7cmV0dXJuKHRoaXMuZmxhZ3MmMjA5NzE1NSkhPT0wfX0saXNBcHBlbmQ6e2dldCgpe3JldHVybiB0aGlzLmZsYWdzJjEwMjR9fSxmbGFnczp7Z2V0KCl7cmV0dXJuIHRoaXMuc2hhcmVkLmZsYWdzfSxzZXQodmFsKXt0aGlzLnNoYXJlZC5mbGFncz12YWx9fSxwb3NpdGlvbjp7Z2V0KCl7cmV0dXJuIHRoaXMuc2hhcmVkLnBvc2l0aW9ufSxzZXQodmFsKXt0aGlzLnNoYXJlZC5wb3NpdGlvbj12YWx9fX0pfXN0cmVhbT1PYmplY3QuYXNzaWduKG5ldyBGUy5GU1N0cmVhbSxzdHJlYW0pO2lmKGZkPT0tMSl7ZmQ9RlMubmV4dGZkKCl9c3RyZWFtLmZkPWZkO0ZTLnN0cmVhbXNbZmRdPXN0cmVhbTtyZXR1cm4gc3RyZWFtfSxjbG9zZVN0cmVhbShmZCl7RlMuc3RyZWFtc1tmZF09bnVsbH0sY2hyZGV2X3N0cmVhbV9vcHM6e29wZW4oc3RyZWFtKXt2YXIgZGV2aWNlPUZTLmdldERldmljZShzdHJlYW0ubm9kZS5yZGV2KTtzdHJlYW0uc3RyZWFtX29wcz1kZXZpY2Uuc3RyZWFtX29wcztpZihzdHJlYW0uc3RyZWFtX29wcy5vcGVuKXtzdHJlYW0uc3RyZWFtX29wcy5vcGVuKHN0cmVhbSl9fSxsbHNlZWsoKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCl9fSxtYWpvcjpkZXY9PmRldj4+OCxtaW5vcjpkZXY9PmRldiYyNTUsbWFrZWRldjoobWEsbWkpPT5tYTw8OHxtaSxyZWdpc3RlckRldmljZShkZXYsb3BzKXtGUy5kZXZpY2VzW2Rldl09e3N0cmVhbV9vcHM6b3BzfX0sZ2V0RGV2aWNlOmRldj0+RlMuZGV2aWNlc1tkZXZdLGdldE1vdW50cyhtb3VudCl7dmFyIG1vdW50cz1bXTt2YXIgY2hlY2s9W21vdW50XTt3aGlsZShjaGVjay5sZW5ndGgpe3ZhciBtPWNoZWNrLnBvcCgpO21vdW50cy5wdXNoKG0pO2NoZWNrLnB1c2guYXBwbHkoY2hlY2ssbS5tb3VudHMpfXJldHVybiBtb3VudHN9LHN5bmNmcyhwb3B1bGF0ZSxjYWxsYmFjayl7aWYodHlwZW9mIHBvcHVsYXRlPT1cImZ1bmN0aW9uXCIpe2NhbGxiYWNrPXBvcHVsYXRlO3BvcHVsYXRlPWZhbHNlfUZTLnN5bmNGU1JlcXVlc3RzKys7aWYoRlMuc3luY0ZTUmVxdWVzdHM+MSl7ZXJyKGB3YXJuaW5nOiAke0ZTLnN5bmNGU1JlcXVlc3RzfSBGUy5zeW5jZnMgb3BlcmF0aW9ucyBpbiBmbGlnaHQgYXQgb25jZSwgcHJvYmFibHkganVzdCBkb2luZyBleHRyYSB3b3JrYCl9dmFyIG1vdW50cz1GUy5nZXRNb3VudHMoRlMucm9vdC5tb3VudCk7dmFyIGNvbXBsZXRlZD0wO2Z1bmN0aW9uIGRvQ2FsbGJhY2soZXJyQ29kZSl7RlMuc3luY0ZTUmVxdWVzdHMtLTtyZXR1cm4gY2FsbGJhY2soZXJyQ29kZSl9ZnVuY3Rpb24gZG9uZShlcnJDb2RlKXtpZihlcnJDb2RlKXtpZighZG9uZS5lcnJvcmVkKXtkb25lLmVycm9yZWQ9dHJ1ZTtyZXR1cm4gZG9DYWxsYmFjayhlcnJDb2RlKX1yZXR1cm59aWYoKytjb21wbGV0ZWQ+PW1vdW50cy5sZW5ndGgpe2RvQ2FsbGJhY2sobnVsbCl9fW1vdW50cy5mb3JFYWNoKG1vdW50PT57aWYoIW1vdW50LnR5cGUuc3luY2ZzKXtyZXR1cm4gZG9uZShudWxsKX1tb3VudC50eXBlLnN5bmNmcyhtb3VudCxwb3B1bGF0ZSxkb25lKX0pfSxtb3VudCh0eXBlLG9wdHMsbW91bnRwb2ludCl7dmFyIHJvb3Q9bW91bnRwb2ludD09PVwiL1wiO3ZhciBwc2V1ZG89IW1vdW50cG9pbnQ7dmFyIG5vZGU7aWYocm9vdCYmRlMucm9vdCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApfWVsc2UgaWYoIXJvb3QmJiFwc2V1ZG8pe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChtb3VudHBvaW50LHtmb2xsb3dfbW91bnQ6ZmFsc2V9KTttb3VudHBvaW50PWxvb2t1cC5wYXRoO25vZGU9bG9va3VwLm5vZGU7aWYoRlMuaXNNb3VudHBvaW50KG5vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigxMCl9aWYoIUZTLmlzRGlyKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KX19dmFyIG1vdW50PXt0eXBlOnR5cGUsb3B0czpvcHRzLG1vdW50cG9pbnQ6bW91bnRwb2ludCxtb3VudHM6W119O3ZhciBtb3VudFJvb3Q9dHlwZS5tb3VudChtb3VudCk7bW91bnRSb290Lm1vdW50PW1vdW50O21vdW50LnJvb3Q9bW91bnRSb290O2lmKHJvb3Qpe0ZTLnJvb3Q9bW91bnRSb290fWVsc2UgaWYobm9kZSl7bm9kZS5tb3VudGVkPW1vdW50O2lmKG5vZGUubW91bnQpe25vZGUubW91bnQubW91bnRzLnB1c2gobW91bnQpfX1yZXR1cm4gbW91bnRSb290fSx1bm1vdW50KG1vdW50cG9pbnQpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChtb3VudHBvaW50LHtmb2xsb3dfbW91bnQ6ZmFsc2V9KTtpZighRlMuaXNNb3VudHBvaW50KGxvb2t1cC5ub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfXZhciBub2RlPWxvb2t1cC5ub2RlO3ZhciBtb3VudD1ub2RlLm1vdW50ZWQ7dmFyIG1vdW50cz1GUy5nZXRNb3VudHMobW91bnQpO09iamVjdC5rZXlzKEZTLm5hbWVUYWJsZSkuZm9yRWFjaChoYXNoPT57dmFyIGN1cnJlbnQ9RlMubmFtZVRhYmxlW2hhc2hdO3doaWxlKGN1cnJlbnQpe3ZhciBuZXh0PWN1cnJlbnQubmFtZV9uZXh0O2lmKG1vdW50cy5pbmNsdWRlcyhjdXJyZW50Lm1vdW50KSl7RlMuZGVzdHJveU5vZGUoY3VycmVudCl9Y3VycmVudD1uZXh0fX0pO25vZGUubW91bnRlZD1udWxsO3ZhciBpZHg9bm9kZS5tb3VudC5tb3VudHMuaW5kZXhPZihtb3VudCk7bm9kZS5tb3VudC5tb3VudHMuc3BsaWNlKGlkeCwxKX0sbG9va3VwKHBhcmVudCxuYW1lKXtyZXR1cm4gcGFyZW50Lm5vZGVfb3BzLmxvb2t1cChwYXJlbnQsbmFtZSl9LG1rbm9kKHBhdGgsbW9kZSxkZXYpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7dmFyIG5hbWU9UEFUSC5iYXNlbmFtZShwYXRoKTtpZighbmFtZXx8bmFtZT09PVwiLlwifHxuYW1lPT09XCIuLlwiKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9dmFyIGVyckNvZGU9RlMubWF5Q3JlYXRlKHBhcmVudCxuYW1lKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX1pZighcGFyZW50Lm5vZGVfb3BzLm1rbm9kKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myl9cmV0dXJuIHBhcmVudC5ub2RlX29wcy5ta25vZChwYXJlbnQsbmFtZSxtb2RlLGRldil9LGNyZWF0ZShwYXRoLG1vZGUpe21vZGU9bW9kZSE9PXVuZGVmaW5lZD9tb2RlOjQzODttb2RlJj00MDk1O21vZGV8PTMyNzY4O3JldHVybiBGUy5ta25vZChwYXRoLG1vZGUsMCl9LG1rZGlyKHBhdGgsbW9kZSl7bW9kZT1tb2RlIT09dW5kZWZpbmVkP21vZGU6NTExO21vZGUmPTUxMXw1MTI7bW9kZXw9MTYzODQ7cmV0dXJuIEZTLm1rbm9kKHBhdGgsbW9kZSwwKX0sbWtkaXJUcmVlKHBhdGgsbW9kZSl7dmFyIGRpcnM9cGF0aC5zcGxpdChcIi9cIik7dmFyIGQ9XCJcIjtmb3IodmFyIGk9MDtpPGRpcnMubGVuZ3RoOysraSl7aWYoIWRpcnNbaV0pY29udGludWU7ZCs9XCIvXCIrZGlyc1tpXTt0cnl7RlMubWtkaXIoZCxtb2RlKX1jYXRjaChlKXtpZihlLmVycm5vIT0yMCl0aHJvdyBlfX19LG1rZGV2KHBhdGgsbW9kZSxkZXYpe2lmKHR5cGVvZiBkZXY9PVwidW5kZWZpbmVkXCIpe2Rldj1tb2RlO21vZGU9NDM4fW1vZGV8PTgxOTI7cmV0dXJuIEZTLm1rbm9kKHBhdGgsbW9kZSxkZXYpfSxzeW1saW5rKG9sZHBhdGgsbmV3cGF0aCl7aWYoIVBBVEhfRlMucmVzb2x2ZShvbGRwYXRoKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpfXZhciBsb29rdXA9RlMubG9va3VwUGF0aChuZXdwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7aWYoIXBhcmVudCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDQpfXZhciBuZXduYW1lPVBBVEguYmFzZW5hbWUobmV3cGF0aCk7dmFyIGVyckNvZGU9RlMubWF5Q3JlYXRlKHBhcmVudCxuZXduYW1lKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX1pZighcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKX1yZXR1cm4gcGFyZW50Lm5vZGVfb3BzLnN5bWxpbmsocGFyZW50LG5ld25hbWUsb2xkcGF0aCl9LHJlbmFtZShvbGRfcGF0aCxuZXdfcGF0aCl7dmFyIG9sZF9kaXJuYW1lPVBBVEguZGlybmFtZShvbGRfcGF0aCk7dmFyIG5ld19kaXJuYW1lPVBBVEguZGlybmFtZShuZXdfcGF0aCk7dmFyIG9sZF9uYW1lPVBBVEguYmFzZW5hbWUob2xkX3BhdGgpO3ZhciBuZXdfbmFtZT1QQVRILmJhc2VuYW1lKG5ld19wYXRoKTt2YXIgbG9va3VwLG9sZF9kaXIsbmV3X2Rpcjtsb29rdXA9RlMubG9va3VwUGF0aChvbGRfcGF0aCx7cGFyZW50OnRydWV9KTtvbGRfZGlyPWxvb2t1cC5ub2RlO2xvb2t1cD1GUy5sb29rdXBQYXRoKG5ld19wYXRoLHtwYXJlbnQ6dHJ1ZX0pO25ld19kaXI9bG9va3VwLm5vZGU7aWYoIW9sZF9kaXJ8fCFuZXdfZGlyKXRocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KTtpZihvbGRfZGlyLm1vdW50IT09bmV3X2Rpci5tb3VudCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNzUpfXZhciBvbGRfbm9kZT1GUy5sb29rdXBOb2RlKG9sZF9kaXIsb2xkX25hbWUpO3ZhciByZWxhdGl2ZT1QQVRIX0ZTLnJlbGF0aXZlKG9sZF9wYXRoLG5ld19kaXJuYW1lKTtpZihyZWxhdGl2ZS5jaGFyQXQoMCkhPT1cIi5cIil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfXJlbGF0aXZlPVBBVEhfRlMucmVsYXRpdmUobmV3X3BhdGgsb2xkX2Rpcm5hbWUpO2lmKHJlbGF0aXZlLmNoYXJBdCgwKSE9PVwiLlwiKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NSl9dmFyIG5ld19ub2RlO3RyeXtuZXdfbm9kZT1GUy5sb29rdXBOb2RlKG5ld19kaXIsbmV3X25hbWUpfWNhdGNoKGUpe31pZihvbGRfbm9kZT09PW5ld19ub2RlKXtyZXR1cm59dmFyIGlzZGlyPUZTLmlzRGlyKG9sZF9ub2RlLm1vZGUpO3ZhciBlcnJDb2RlPUZTLm1heURlbGV0ZShvbGRfZGlyLG9sZF9uYW1lLGlzZGlyKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX1lcnJDb2RlPW5ld19ub2RlP0ZTLm1heURlbGV0ZShuZXdfZGlyLG5ld19uYW1lLGlzZGlyKTpGUy5tYXlDcmVhdGUobmV3X2RpcixuZXdfbmFtZSk7aWYoZXJyQ29kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSl9aWYoIW9sZF9kaXIubm9kZV9vcHMucmVuYW1lKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myl9aWYoRlMuaXNNb3VudHBvaW50KG9sZF9ub2RlKXx8bmV3X25vZGUmJkZTLmlzTW91bnRwb2ludChuZXdfbm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKX1pZihuZXdfZGlyIT09b2xkX2Rpcil7ZXJyQ29kZT1GUy5ub2RlUGVybWlzc2lvbnMob2xkX2RpcixcIndcIik7aWYoZXJyQ29kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSl9fUZTLmhhc2hSZW1vdmVOb2RlKG9sZF9ub2RlKTt0cnl7b2xkX2Rpci5ub2RlX29wcy5yZW5hbWUob2xkX25vZGUsbmV3X2RpcixuZXdfbmFtZSl9Y2F0Y2goZSl7dGhyb3cgZX1maW5hbGx5e0ZTLmhhc2hBZGROb2RlKG9sZF9ub2RlKX19LHJtZGlyKHBhdGgpe3ZhciBsb29rdXA9RlMubG9va3VwUGF0aChwYXRoLHtwYXJlbnQ6dHJ1ZX0pO3ZhciBwYXJlbnQ9bG9va3VwLm5vZGU7dmFyIG5hbWU9UEFUSC5iYXNlbmFtZShwYXRoKTt2YXIgbm9kZT1GUy5sb29rdXBOb2RlKHBhcmVudCxuYW1lKTt2YXIgZXJyQ29kZT1GUy5tYXlEZWxldGUocGFyZW50LG5hbWUsdHJ1ZSk7aWYoZXJyQ29kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSl9aWYoIXBhcmVudC5ub2RlX29wcy5ybWRpcil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpfWlmKEZTLmlzTW91bnRwb2ludChub2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMTApfXBhcmVudC5ub2RlX29wcy5ybWRpcihwYXJlbnQsbmFtZSk7RlMuZGVzdHJveU5vZGUobm9kZSl9LHJlYWRkaXIocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzp0cnVlfSk7dmFyIG5vZGU9bG9va3VwLm5vZGU7aWYoIW5vZGUubm9kZV9vcHMucmVhZGRpcil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTQpfXJldHVybiBub2RlLm5vZGVfb3BzLnJlYWRkaXIobm9kZSl9LHVubGluayhwYXRoKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7cGFyZW50OnRydWV9KTt2YXIgcGFyZW50PWxvb2t1cC5ub2RlO2lmKCFwYXJlbnQpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KX12YXIgbmFtZT1QQVRILmJhc2VuYW1lKHBhdGgpO3ZhciBub2RlPUZTLmxvb2t1cE5vZGUocGFyZW50LG5hbWUpO3ZhciBlcnJDb2RlPUZTLm1heURlbGV0ZShwYXJlbnQsbmFtZSxmYWxzZSk7aWYoZXJyQ29kZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoZXJyQ29kZSl9aWYoIXBhcmVudC5ub2RlX29wcy51bmxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKX1pZihGUy5pc01vdW50cG9pbnQobm9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDEwKX1wYXJlbnQubm9kZV9vcHMudW5saW5rKHBhcmVudCxuYW1lKTtGUy5kZXN0cm95Tm9kZShub2RlKX0scmVhZGxpbmsocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgpO3ZhciBsaW5rPWxvb2t1cC5ub2RlO2lmKCFsaW5rKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCl9aWYoIWxpbmsubm9kZV9vcHMucmVhZGxpbmspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX1yZXR1cm4gUEFUSF9GUy5yZXNvbHZlKEZTLmdldFBhdGgobGluay5wYXJlbnQpLGxpbmsubm9kZV9vcHMucmVhZGxpbmsobGluaykpfSxzdGF0KHBhdGgsZG9udEZvbGxvdyl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udEZvbGxvd30pO3ZhciBub2RlPWxvb2t1cC5ub2RlO2lmKCFub2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCl9aWYoIW5vZGUubm9kZV9vcHMuZ2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpfXJldHVybiBub2RlLm5vZGVfb3BzLmdldGF0dHIobm9kZSl9LGxzdGF0KHBhdGgpe3JldHVybiBGUy5zdGF0KHBhdGgsdHJ1ZSl9LGNobW9kKHBhdGgsbW9kZSxkb250Rm9sbG93KXt2YXIgbm9kZTtpZih0eXBlb2YgcGF0aD09XCJzdHJpbmdcIil7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udEZvbGxvd30pO25vZGU9bG9va3VwLm5vZGV9ZWxzZXtub2RlPXBhdGh9aWYoIW5vZGUubm9kZV9vcHMuc2V0YXR0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNjMpfW5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLHttb2RlOm1vZGUmNDA5NXxub2RlLm1vZGUmfjQwOTUsdGltZXN0YW1wOkRhdGUubm93KCl9KX0sbGNobW9kKHBhdGgsbW9kZSl7RlMuY2htb2QocGF0aCxtb2RlLHRydWUpfSxmY2htb2QoZmQsbW9kZSl7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW1DaGVja2VkKGZkKTtGUy5jaG1vZChzdHJlYW0ubm9kZSxtb2RlKX0sY2hvd24ocGF0aCx1aWQsZ2lkLGRvbnRGb2xsb3cpe3ZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT1cInN0cmluZ1wiKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OiFkb250Rm9sbG93fSk7bm9kZT1sb29rdXAubm9kZX1lbHNle25vZGU9cGF0aH1pZighbm9kZS5ub2RlX29wcy5zZXRhdHRyKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig2Myl9bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse3RpbWVzdGFtcDpEYXRlLm5vdygpfSl9LGxjaG93bihwYXRoLHVpZCxnaWQpe0ZTLmNob3duKHBhdGgsdWlkLGdpZCx0cnVlKX0sZmNob3duKGZkLHVpZCxnaWQpe3ZhciBzdHJlYW09RlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7RlMuY2hvd24oc3RyZWFtLm5vZGUsdWlkLGdpZCl9LHRydW5jYXRlKHBhdGgsbGVuKXtpZihsZW48MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfXZhciBub2RlO2lmKHR5cGVvZiBwYXRoPT1cInN0cmluZ1wiKXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7Zm9sbG93OnRydWV9KTtub2RlPWxvb2t1cC5ub2RlfWVsc2V7bm9kZT1wYXRofWlmKCFub2RlLm5vZGVfb3BzLnNldGF0dHIpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDYzKX1pZihGUy5pc0Rpcihub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigzMSl9aWYoIUZTLmlzRmlsZShub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9dmFyIGVyckNvZGU9RlMubm9kZVBlcm1pc3Npb25zKG5vZGUsXCJ3XCIpO2lmKGVyckNvZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKGVyckNvZGUpfW5vZGUubm9kZV9vcHMuc2V0YXR0cihub2RlLHtzaXplOmxlbix0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfSxmdHJ1bmNhdGUoZmQsbGVuKXt2YXIgc3RyZWFtPUZTLmdldFN0cmVhbUNoZWNrZWQoZmQpO2lmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9RlMudHJ1bmNhdGUoc3RyZWFtLm5vZGUsbGVuKX0sdXRpbWUocGF0aCxhdGltZSxtdGltZSl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzp0cnVlfSk7dmFyIG5vZGU9bG9va3VwLm5vZGU7bm9kZS5ub2RlX29wcy5zZXRhdHRyKG5vZGUse3RpbWVzdGFtcDpNYXRoLm1heChhdGltZSxtdGltZSl9KX0sb3BlbihwYXRoLGZsYWdzLG1vZGUpe2lmKHBhdGg9PT1cIlwiKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCl9ZmxhZ3M9dHlwZW9mIGZsYWdzPT1cInN0cmluZ1wiP0ZTX21vZGVTdHJpbmdUb0ZsYWdzKGZsYWdzKTpmbGFnczttb2RlPXR5cGVvZiBtb2RlPT1cInVuZGVmaW5lZFwiPzQzODptb2RlO2lmKGZsYWdzJjY0KXttb2RlPW1vZGUmNDA5NXwzMjc2OH1lbHNle21vZGU9MH12YXIgbm9kZTtpZih0eXBlb2YgcGF0aD09XCJvYmplY3RcIil7bm9kZT1wYXRofWVsc2V7cGF0aD1QQVRILm5vcm1hbGl6ZShwYXRoKTt0cnl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohKGZsYWdzJjEzMTA3Mil9KTtub2RlPWxvb2t1cC5ub2RlfWNhdGNoKGUpe319dmFyIGNyZWF0ZWQ9ZmFsc2U7aWYoZmxhZ3MmNjQpe2lmKG5vZGUpe2lmKGZsYWdzJjEyOCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjApfX1lbHNle25vZGU9RlMubWtub2QocGF0aCxtb2RlLDApO2NyZWF0ZWQ9dHJ1ZX19aWYoIW5vZGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KX1pZihGUy5pc0NocmRldihub2RlLm1vZGUpKXtmbGFncyY9fjUxMn1pZihmbGFncyY2NTUzNiYmIUZTLmlzRGlyKG5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDU0KX1pZighY3JlYXRlZCl7dmFyIGVyckNvZGU9RlMubWF5T3Blbihub2RlLGZsYWdzKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX19aWYoZmxhZ3MmNTEyJiYhY3JlYXRlZCl7RlMudHJ1bmNhdGUobm9kZSwwKX1mbGFncyY9figxMjh8NTEyfDEzMTA3Mik7dmFyIHN0cmVhbT1GUy5jcmVhdGVTdHJlYW0oe25vZGU6bm9kZSxwYXRoOkZTLmdldFBhdGgobm9kZSksZmxhZ3M6ZmxhZ3Msc2Vla2FibGU6dHJ1ZSxwb3NpdGlvbjowLHN0cmVhbV9vcHM6bm9kZS5zdHJlYW1fb3BzLHVuZ290dGVuOltdLGVycm9yOmZhbHNlfSk7aWYoc3RyZWFtLnN0cmVhbV9vcHMub3Blbil7c3RyZWFtLnN0cmVhbV9vcHMub3BlbihzdHJlYW0pfWlmKE1vZHVsZVtcImxvZ1JlYWRGaWxlc1wiXSYmIShmbGFncyYxKSl7aWYoIUZTLnJlYWRGaWxlcylGUy5yZWFkRmlsZXM9e307aWYoIShwYXRoIGluIEZTLnJlYWRGaWxlcykpe0ZTLnJlYWRGaWxlc1twYXRoXT0xfX1yZXR1cm4gc3RyZWFtfSxjbG9zZShzdHJlYW0pe2lmKEZTLmlzQ2xvc2VkKHN0cmVhbSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpfWlmKHN0cmVhbS5nZXRkZW50cylzdHJlYW0uZ2V0ZGVudHM9bnVsbDt0cnl7aWYoc3RyZWFtLnN0cmVhbV9vcHMuY2xvc2Upe3N0cmVhbS5zdHJlYW1fb3BzLmNsb3NlKHN0cmVhbSl9fWNhdGNoKGUpe3Rocm93IGV9ZmluYWxseXtGUy5jbG9zZVN0cmVhbShzdHJlYW0uZmQpfXN0cmVhbS5mZD1udWxsfSxpc0Nsb3NlZChzdHJlYW0pe3JldHVybiBzdHJlYW0uZmQ9PT1udWxsfSxsbHNlZWsoc3RyZWFtLG9mZnNldCx3aGVuY2Upe2lmKEZTLmlzQ2xvc2VkKHN0cmVhbSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpfWlmKCFzdHJlYW0uc2Vla2FibGV8fCFzdHJlYW0uc3RyZWFtX29wcy5sbHNlZWspe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDcwKX1pZih3aGVuY2UhPTAmJndoZW5jZSE9MSYmd2hlbmNlIT0yKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9c3RyZWFtLnBvc2l0aW9uPXN0cmVhbS5zdHJlYW1fb3BzLmxsc2VlayhzdHJlYW0sb2Zmc2V0LHdoZW5jZSk7c3RyZWFtLnVuZ290dGVuPVtdO3JldHVybiBzdHJlYW0ucG9zaXRpb259LHJlYWQoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uKXtpZihsZW5ndGg8MHx8cG9zaXRpb248MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfWlmKEZTLmlzQ2xvc2VkKHN0cmVhbSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDgpfWlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0xKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KX1pZihGUy5pc0RpcihzdHJlYW0ubm9kZS5tb2RlKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMzEpfWlmKCFzdHJlYW0uc3RyZWFtX29wcy5yZWFkKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcigyOCl9dmFyIHNlZWtpbmc9dHlwZW9mIHBvc2l0aW9uIT1cInVuZGVmaW5lZFwiO2lmKCFzZWVraW5nKXtwb3NpdGlvbj1zdHJlYW0ucG9zaXRpb259ZWxzZSBpZighc3RyZWFtLnNlZWthYmxlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCl9dmFyIGJ5dGVzUmVhZD1zdHJlYW0uc3RyZWFtX29wcy5yZWFkKHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbik7aWYoIXNlZWtpbmcpc3RyZWFtLnBvc2l0aW9uKz1ieXRlc1JlYWQ7cmV0dXJuIGJ5dGVzUmVhZH0sd3JpdGUoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvc2l0aW9uLGNhbk93bil7aWYobGVuZ3RoPDB8fHBvc2l0aW9uPDApe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX1pZihGUy5pc0Nsb3NlZChzdHJlYW0pKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KX1pZigoc3RyZWFtLmZsYWdzJjIwOTcxNTUpPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCl9aWYoRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDMxKX1pZighc3RyZWFtLnN0cmVhbV9vcHMud3JpdGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI4KX1pZihzdHJlYW0uc2Vla2FibGUmJnN0cmVhbS5mbGFncyYxMDI0KXtGUy5sbHNlZWsoc3RyZWFtLDAsMil9dmFyIHNlZWtpbmc9dHlwZW9mIHBvc2l0aW9uIT1cInVuZGVmaW5lZFwiO2lmKCFzZWVraW5nKXtwb3NpdGlvbj1zdHJlYW0ucG9zaXRpb259ZWxzZSBpZighc3RyZWFtLnNlZWthYmxlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig3MCl9dmFyIGJ5dGVzV3JpdHRlbj1zdHJlYW0uc3RyZWFtX29wcy53cml0ZShzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24sY2FuT3duKTtpZighc2Vla2luZylzdHJlYW0ucG9zaXRpb24rPWJ5dGVzV3JpdHRlbjtyZXR1cm4gYnl0ZXNXcml0dGVufSxhbGxvY2F0ZShzdHJlYW0sb2Zmc2V0LGxlbmd0aCl7aWYoRlMuaXNDbG9zZWQoc3RyZWFtKSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoOCl9aWYob2Zmc2V0PDB8fGxlbmd0aDw9MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjgpfWlmKChzdHJlYW0uZmxhZ3MmMjA5NzE1NSk9PT0wKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig4KX1pZighRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpJiYhRlMuaXNEaXIoc3RyZWFtLm5vZGUubW9kZSkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQzKX1pZighc3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDEzOCl9c3RyZWFtLnN0cmVhbV9vcHMuYWxsb2NhdGUoc3RyZWFtLG9mZnNldCxsZW5ndGgpfSxtbWFwKHN0cmVhbSxsZW5ndGgscG9zaXRpb24scHJvdCxmbGFncyl7aWYoKHByb3QmMikhPT0wJiYoZmxhZ3MmMik9PT0wJiYoc3RyZWFtLmZsYWdzJjIwOTcxNTUpIT09Mil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMil9aWYoKHN0cmVhbS5mbGFncyYyMDk3MTU1KT09PTEpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDIpfWlmKCFzdHJlYW0uc3RyZWFtX29wcy5tbWFwKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myl9cmV0dXJuIHN0cmVhbS5zdHJlYW1fb3BzLm1tYXAoc3RyZWFtLGxlbmd0aCxwb3NpdGlvbixwcm90LGZsYWdzKX0sbXN5bmMoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl7aWYoIXN0cmVhbS5zdHJlYW1fb3BzLm1zeW5jKXtyZXR1cm4gMH1yZXR1cm4gc3RyZWFtLnN0cmVhbV9vcHMubXN5bmMoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLG1tYXBGbGFncyl9LG11bm1hcDpzdHJlYW09PjAsaW9jdGwoc3RyZWFtLGNtZCxhcmcpe2lmKCFzdHJlYW0uc3RyZWFtX29wcy5pb2N0bCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNTkpfXJldHVybiBzdHJlYW0uc3RyZWFtX29wcy5pb2N0bChzdHJlYW0sY21kLGFyZyl9LHJlYWRGaWxlKHBhdGgsb3B0cz17fSl7b3B0cy5mbGFncz1vcHRzLmZsYWdzfHwwO29wdHMuZW5jb2Rpbmc9b3B0cy5lbmNvZGluZ3x8XCJiaW5hcnlcIjtpZihvcHRzLmVuY29kaW5nIT09XCJ1dGY4XCImJm9wdHMuZW5jb2RpbmchPT1cImJpbmFyeVwiKXt0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZW5jb2RpbmcgdHlwZSBcIiR7b3B0cy5lbmNvZGluZ31cImApfXZhciByZXQ7dmFyIHN0cmVhbT1GUy5vcGVuKHBhdGgsb3B0cy5mbGFncyk7dmFyIHN0YXQ9RlMuc3RhdChwYXRoKTt2YXIgbGVuZ3RoPXN0YXQuc2l6ZTt2YXIgYnVmPW5ldyBVaW50OEFycmF5KGxlbmd0aCk7RlMucmVhZChzdHJlYW0sYnVmLDAsbGVuZ3RoLDApO2lmKG9wdHMuZW5jb2Rpbmc9PT1cInV0ZjhcIil7cmV0PVVURjhBcnJheVRvU3RyaW5nKGJ1ZiwwKX1lbHNlIGlmKG9wdHMuZW5jb2Rpbmc9PT1cImJpbmFyeVwiKXtyZXQ9YnVmfUZTLmNsb3NlKHN0cmVhbSk7cmV0dXJuIHJldH0sd3JpdGVGaWxlKHBhdGgsZGF0YSxvcHRzPXt9KXtvcHRzLmZsYWdzPW9wdHMuZmxhZ3N8fDU3Nzt2YXIgc3RyZWFtPUZTLm9wZW4ocGF0aCxvcHRzLmZsYWdzLG9wdHMubW9kZSk7aWYodHlwZW9mIGRhdGE9PVwic3RyaW5nXCIpe3ZhciBidWY9bmV3IFVpbnQ4QXJyYXkobGVuZ3RoQnl0ZXNVVEY4KGRhdGEpKzEpO3ZhciBhY3R1YWxOdW1CeXRlcz1zdHJpbmdUb1VURjhBcnJheShkYXRhLGJ1ZiwwLGJ1Zi5sZW5ndGgpO0ZTLndyaXRlKHN0cmVhbSxidWYsMCxhY3R1YWxOdW1CeXRlcyx1bmRlZmluZWQsb3B0cy5jYW5Pd24pfWVsc2UgaWYoQXJyYXlCdWZmZXIuaXNWaWV3KGRhdGEpKXtGUy53cml0ZShzdHJlYW0sZGF0YSwwLGRhdGEuYnl0ZUxlbmd0aCx1bmRlZmluZWQsb3B0cy5jYW5Pd24pfWVsc2V7dGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlXCIpfUZTLmNsb3NlKHN0cmVhbSl9LGN3ZDooKT0+RlMuY3VycmVudFBhdGgsY2hkaXIocGF0aCl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzp0cnVlfSk7aWYobG9va3VwLm5vZGU9PT1udWxsKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0NCl9aWYoIUZTLmlzRGlyKGxvb2t1cC5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig1NCl9dmFyIGVyckNvZGU9RlMubm9kZVBlcm1pc3Npb25zKGxvb2t1cC5ub2RlLFwieFwiKTtpZihlcnJDb2RlKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcihlcnJDb2RlKX1GUy5jdXJyZW50UGF0aD1sb29rdXAucGF0aH0sY3JlYXRlRGVmYXVsdERpcmVjdG9yaWVzKCl7RlMubWtkaXIoXCIvdG1wXCIpO0ZTLm1rZGlyKFwiL2hvbWVcIik7RlMubWtkaXIoXCIvaG9tZS93ZWJfdXNlclwiKX0sY3JlYXRlRGVmYXVsdERldmljZXMoKXtGUy5ta2RpcihcIi9kZXZcIik7RlMucmVnaXN0ZXJEZXZpY2UoRlMubWFrZWRldigxLDMpLHtyZWFkOigpPT4wLHdyaXRlOihzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zKT0+bGVuZ3RofSk7RlMubWtkZXYoXCIvZGV2L251bGxcIixGUy5tYWtlZGV2KDEsMykpO1RUWS5yZWdpc3RlcihGUy5tYWtlZGV2KDUsMCksVFRZLmRlZmF1bHRfdHR5X29wcyk7VFRZLnJlZ2lzdGVyKEZTLm1ha2VkZXYoNiwwKSxUVFkuZGVmYXVsdF90dHkxX29wcyk7RlMubWtkZXYoXCIvZGV2L3R0eVwiLEZTLm1ha2VkZXYoNSwwKSk7RlMubWtkZXYoXCIvZGV2L3R0eTFcIixGUy5tYWtlZGV2KDYsMCkpO3ZhciByYW5kb21CdWZmZXI9bmV3IFVpbnQ4QXJyYXkoMTAyNCkscmFuZG9tTGVmdD0wO3ZhciByYW5kb21CeXRlPSgpPT57aWYocmFuZG9tTGVmdD09PTApe3JhbmRvbUxlZnQ9cmFuZG9tRmlsbChyYW5kb21CdWZmZXIpLmJ5dGVMZW5ndGh9cmV0dXJuIHJhbmRvbUJ1ZmZlclstLXJhbmRvbUxlZnRdfTtGUy5jcmVhdGVEZXZpY2UoXCIvZGV2XCIsXCJyYW5kb21cIixyYW5kb21CeXRlKTtGUy5jcmVhdGVEZXZpY2UoXCIvZGV2XCIsXCJ1cmFuZG9tXCIscmFuZG9tQnl0ZSk7RlMubWtkaXIoXCIvZGV2L3NobVwiKTtGUy5ta2RpcihcIi9kZXYvc2htL3RtcFwiKX0sY3JlYXRlU3BlY2lhbERpcmVjdG9yaWVzKCl7RlMubWtkaXIoXCIvcHJvY1wiKTt2YXIgcHJvY19zZWxmPUZTLm1rZGlyKFwiL3Byb2Mvc2VsZlwiKTtGUy5ta2RpcihcIi9wcm9jL3NlbGYvZmRcIik7RlMubW91bnQoe21vdW50KCl7dmFyIG5vZGU9RlMuY3JlYXRlTm9kZShwcm9jX3NlbGYsXCJmZFwiLDE2Mzg0fDUxMSw3Myk7bm9kZS5ub2RlX29wcz17bG9va3VwKHBhcmVudCxuYW1lKXt2YXIgZmQ9K25hbWU7dmFyIHN0cmVhbT1GUy5nZXRTdHJlYW1DaGVja2VkKGZkKTt2YXIgcmV0PXtwYXJlbnQ6bnVsbCxtb3VudDp7bW91bnRwb2ludDpcImZha2VcIn0sbm9kZV9vcHM6e3JlYWRsaW5rOigpPT5zdHJlYW0ucGF0aH19O3JldC5wYXJlbnQ9cmV0O3JldHVybiByZXR9fTtyZXR1cm4gbm9kZX19LHt9LFwiL3Byb2Mvc2VsZi9mZFwiKX0sY3JlYXRlU3RhbmRhcmRTdHJlYW1zKCl7aWYoTW9kdWxlW1wic3RkaW5cIl0pe0ZTLmNyZWF0ZURldmljZShcIi9kZXZcIixcInN0ZGluXCIsTW9kdWxlW1wic3RkaW5cIl0pfWVsc2V7RlMuc3ltbGluayhcIi9kZXYvdHR5XCIsXCIvZGV2L3N0ZGluXCIpfWlmKE1vZHVsZVtcInN0ZG91dFwiXSl7RlMuY3JlYXRlRGV2aWNlKFwiL2RldlwiLFwic3Rkb3V0XCIsbnVsbCxNb2R1bGVbXCJzdGRvdXRcIl0pfWVsc2V7RlMuc3ltbGluayhcIi9kZXYvdHR5XCIsXCIvZGV2L3N0ZG91dFwiKX1pZihNb2R1bGVbXCJzdGRlcnJcIl0pe0ZTLmNyZWF0ZURldmljZShcIi9kZXZcIixcInN0ZGVyclwiLG51bGwsTW9kdWxlW1wic3RkZXJyXCJdKX1lbHNle0ZTLnN5bWxpbmsoXCIvZGV2L3R0eTFcIixcIi9kZXYvc3RkZXJyXCIpfXZhciBzdGRpbj1GUy5vcGVuKFwiL2Rldi9zdGRpblwiLDApO3ZhciBzdGRvdXQ9RlMub3BlbihcIi9kZXYvc3Rkb3V0XCIsMSk7dmFyIHN0ZGVycj1GUy5vcGVuKFwiL2Rldi9zdGRlcnJcIiwxKX0sZW5zdXJlRXJybm9FcnJvcigpe2lmKEZTLkVycm5vRXJyb3IpcmV0dXJuO0ZTLkVycm5vRXJyb3I9ZnVuY3Rpb24gRXJybm9FcnJvcihlcnJubyxub2RlKXt0aGlzLm5hbWU9XCJFcnJub0Vycm9yXCI7dGhpcy5ub2RlPW5vZGU7dGhpcy5zZXRFcnJubz1mdW5jdGlvbihlcnJubyl7dGhpcy5lcnJubz1lcnJub307dGhpcy5zZXRFcnJubyhlcnJubyk7dGhpcy5tZXNzYWdlPVwiRlMgZXJyb3JcIn07RlMuRXJybm9FcnJvci5wcm90b3R5cGU9bmV3IEVycm9yO0ZTLkVycm5vRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yPUZTLkVycm5vRXJyb3I7WzQ0XS5mb3JFYWNoKGNvZGU9PntGUy5nZW5lcmljRXJyb3JzW2NvZGVdPW5ldyBGUy5FcnJub0Vycm9yKGNvZGUpO0ZTLmdlbmVyaWNFcnJvcnNbY29kZV0uc3RhY2s9XCI8Z2VuZXJpYyBlcnJvciwgbm8gc3RhY2s+XCJ9KX0sc3RhdGljSW5pdCgpe0ZTLmVuc3VyZUVycm5vRXJyb3IoKTtGUy5uYW1lVGFibGU9bmV3IEFycmF5KDQwOTYpO0ZTLm1vdW50KE1FTUZTLHt9LFwiL1wiKTtGUy5jcmVhdGVEZWZhdWx0RGlyZWN0b3JpZXMoKTtGUy5jcmVhdGVEZWZhdWx0RGV2aWNlcygpO0ZTLmNyZWF0ZVNwZWNpYWxEaXJlY3RvcmllcygpO0ZTLmZpbGVzeXN0ZW1zPXtcIk1FTUZTXCI6TUVNRlN9fSxpbml0KGlucHV0LG91dHB1dCxlcnJvcil7RlMuaW5pdC5pbml0aWFsaXplZD10cnVlO0ZTLmVuc3VyZUVycm5vRXJyb3IoKTtNb2R1bGVbXCJzdGRpblwiXT1pbnB1dHx8TW9kdWxlW1wic3RkaW5cIl07TW9kdWxlW1wic3Rkb3V0XCJdPW91dHB1dHx8TW9kdWxlW1wic3Rkb3V0XCJdO01vZHVsZVtcInN0ZGVyclwiXT1lcnJvcnx8TW9kdWxlW1wic3RkZXJyXCJdO0ZTLmNyZWF0ZVN0YW5kYXJkU3RyZWFtcygpfSxxdWl0KCl7RlMuaW5pdC5pbml0aWFsaXplZD1mYWxzZTtmb3IodmFyIGk9MDtpPEZTLnN0cmVhbXMubGVuZ3RoO2krKyl7dmFyIHN0cmVhbT1GUy5zdHJlYW1zW2ldO2lmKCFzdHJlYW0pe2NvbnRpbnVlfUZTLmNsb3NlKHN0cmVhbSl9fSxmaW5kT2JqZWN0KHBhdGgsZG9udFJlc29sdmVMYXN0TGluayl7dmFyIHJldD1GUy5hbmFseXplUGF0aChwYXRoLGRvbnRSZXNvbHZlTGFzdExpbmspO2lmKCFyZXQuZXhpc3RzKXtyZXR1cm4gbnVsbH1yZXR1cm4gcmV0Lm9iamVjdH0sYW5hbHl6ZVBhdGgocGF0aCxkb250UmVzb2x2ZUxhc3RMaW5rKXt0cnl7dmFyIGxvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udFJlc29sdmVMYXN0TGlua30pO3BhdGg9bG9va3VwLnBhdGh9Y2F0Y2goZSl7fXZhciByZXQ9e2lzUm9vdDpmYWxzZSxleGlzdHM6ZmFsc2UsZXJyb3I6MCxuYW1lOm51bGwscGF0aDpudWxsLG9iamVjdDpudWxsLHBhcmVudEV4aXN0czpmYWxzZSxwYXJlbnRQYXRoOm51bGwscGFyZW50T2JqZWN0Om51bGx9O3RyeXt2YXIgbG9va3VwPUZTLmxvb2t1cFBhdGgocGF0aCx7cGFyZW50OnRydWV9KTtyZXQucGFyZW50RXhpc3RzPXRydWU7cmV0LnBhcmVudFBhdGg9bG9va3VwLnBhdGg7cmV0LnBhcmVudE9iamVjdD1sb29rdXAubm9kZTtyZXQubmFtZT1QQVRILmJhc2VuYW1lKHBhdGgpO2xvb2t1cD1GUy5sb29rdXBQYXRoKHBhdGgse2ZvbGxvdzohZG9udFJlc29sdmVMYXN0TGlua30pO3JldC5leGlzdHM9dHJ1ZTtyZXQucGF0aD1sb29rdXAucGF0aDtyZXQub2JqZWN0PWxvb2t1cC5ub2RlO3JldC5uYW1lPWxvb2t1cC5ub2RlLm5hbWU7cmV0LmlzUm9vdD1sb29rdXAucGF0aD09PVwiL1wifWNhdGNoKGUpe3JldC5lcnJvcj1lLmVycm5vfXJldHVybiByZXR9LGNyZWF0ZVBhdGgocGFyZW50LHBhdGgsY2FuUmVhZCxjYW5Xcml0ZSl7cGFyZW50PXR5cGVvZiBwYXJlbnQ9PVwic3RyaW5nXCI/cGFyZW50OkZTLmdldFBhdGgocGFyZW50KTt2YXIgcGFydHM9cGF0aC5zcGxpdChcIi9cIikucmV2ZXJzZSgpO3doaWxlKHBhcnRzLmxlbmd0aCl7dmFyIHBhcnQ9cGFydHMucG9wKCk7aWYoIXBhcnQpY29udGludWU7dmFyIGN1cnJlbnQ9UEFUSC5qb2luMihwYXJlbnQscGFydCk7dHJ5e0ZTLm1rZGlyKGN1cnJlbnQpfWNhdGNoKGUpe31wYXJlbnQ9Y3VycmVudH1yZXR1cm4gY3VycmVudH0sY3JlYXRlRmlsZShwYXJlbnQsbmFtZSxwcm9wZXJ0aWVzLGNhblJlYWQsY2FuV3JpdGUpe3ZhciBwYXRoPVBBVEguam9pbjIodHlwZW9mIHBhcmVudD09XCJzdHJpbmdcIj9wYXJlbnQ6RlMuZ2V0UGF0aChwYXJlbnQpLG5hbWUpO3ZhciBtb2RlPUZTX2dldE1vZGUoY2FuUmVhZCxjYW5Xcml0ZSk7cmV0dXJuIEZTLmNyZWF0ZShwYXRoLG1vZGUpfSxjcmVhdGVEYXRhRmlsZShwYXJlbnQsbmFtZSxkYXRhLGNhblJlYWQsY2FuV3JpdGUsY2FuT3duKXt2YXIgcGF0aD1uYW1lO2lmKHBhcmVudCl7cGFyZW50PXR5cGVvZiBwYXJlbnQ9PVwic3RyaW5nXCI/cGFyZW50OkZTLmdldFBhdGgocGFyZW50KTtwYXRoPW5hbWU/UEFUSC5qb2luMihwYXJlbnQsbmFtZSk6cGFyZW50fXZhciBtb2RlPUZTX2dldE1vZGUoY2FuUmVhZCxjYW5Xcml0ZSk7dmFyIG5vZGU9RlMuY3JlYXRlKHBhdGgsbW9kZSk7aWYoZGF0YSl7aWYodHlwZW9mIGRhdGE9PVwic3RyaW5nXCIpe3ZhciBhcnI9bmV3IEFycmF5KGRhdGEubGVuZ3RoKTtmb3IodmFyIGk9MCxsZW49ZGF0YS5sZW5ndGg7aTxsZW47KytpKWFycltpXT1kYXRhLmNoYXJDb2RlQXQoaSk7ZGF0YT1hcnJ9RlMuY2htb2Qobm9kZSxtb2RlfDE0Nik7dmFyIHN0cmVhbT1GUy5vcGVuKG5vZGUsNTc3KTtGUy53cml0ZShzdHJlYW0sZGF0YSwwLGRhdGEubGVuZ3RoLDAsY2FuT3duKTtGUy5jbG9zZShzdHJlYW0pO0ZTLmNobW9kKG5vZGUsbW9kZSl9fSxjcmVhdGVEZXZpY2UocGFyZW50LG5hbWUsaW5wdXQsb3V0cHV0KXt2YXIgcGF0aD1QQVRILmpvaW4yKHR5cGVvZiBwYXJlbnQ9PVwic3RyaW5nXCI/cGFyZW50OkZTLmdldFBhdGgocGFyZW50KSxuYW1lKTt2YXIgbW9kZT1GU19nZXRNb2RlKCEhaW5wdXQsISFvdXRwdXQpO2lmKCFGUy5jcmVhdGVEZXZpY2UubWFqb3IpRlMuY3JlYXRlRGV2aWNlLm1ham9yPTY0O3ZhciBkZXY9RlMubWFrZWRldihGUy5jcmVhdGVEZXZpY2UubWFqb3IrKywwKTtGUy5yZWdpc3RlckRldmljZShkZXYse29wZW4oc3RyZWFtKXtzdHJlYW0uc2Vla2FibGU9ZmFsc2V9LGNsb3NlKHN0cmVhbSl7aWYob3V0cHV0JiZvdXRwdXQuYnVmZmVyJiZvdXRwdXQuYnVmZmVyLmxlbmd0aCl7b3V0cHV0KDEwKX19LHJlYWQoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvcyl7dmFyIGJ5dGVzUmVhZD0wO2Zvcih2YXIgaT0wO2k8bGVuZ3RoO2krKyl7dmFyIHJlc3VsdDt0cnl7cmVzdWx0PWlucHV0KCl9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpfWlmKHJlc3VsdD09PXVuZGVmaW5lZCYmYnl0ZXNSZWFkPT09MCl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNil9aWYocmVzdWx0PT09bnVsbHx8cmVzdWx0PT09dW5kZWZpbmVkKWJyZWFrO2J5dGVzUmVhZCsrO2J1ZmZlcltvZmZzZXQraV09cmVzdWx0fWlmKGJ5dGVzUmVhZCl7c3RyZWFtLm5vZGUudGltZXN0YW1wPURhdGUubm93KCl9cmV0dXJuIGJ5dGVzUmVhZH0sd3JpdGUoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuZ3RoLHBvcyl7Zm9yKHZhciBpPTA7aTxsZW5ndGg7aSsrKXt0cnl7b3V0cHV0KGJ1ZmZlcltvZmZzZXQraV0pfWNhdGNoKGUpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDI5KX19aWYobGVuZ3RoKXtzdHJlYW0ubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKX1yZXR1cm4gaX19KTtyZXR1cm4gRlMubWtkZXYocGF0aCxtb2RlLGRldil9LGZvcmNlTG9hZEZpbGUob2JqKXtpZihvYmouaXNEZXZpY2V8fG9iai5pc0ZvbGRlcnx8b2JqLmxpbmt8fG9iai5jb250ZW50cylyZXR1cm4gdHJ1ZTtpZih0eXBlb2YgWE1MSHR0cFJlcXVlc3QhPVwidW5kZWZpbmVkXCIpe3Rocm93IG5ldyBFcnJvcihcIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLlwiKX1lbHNlIGlmKHJlYWRfKXt0cnl7b2JqLmNvbnRlbnRzPWludEFycmF5RnJvbVN0cmluZyhyZWFkXyhvYmoudXJsKSx0cnVlKTtvYmoudXNlZEJ5dGVzPW9iai5jb250ZW50cy5sZW5ndGh9Y2F0Y2goZSl7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoMjkpfX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBsb2FkIHdpdGhvdXQgcmVhZCgpIG9yIFhNTEh0dHBSZXF1ZXN0LlwiKX19LGNyZWF0ZUxhenlGaWxlKHBhcmVudCxuYW1lLHVybCxjYW5SZWFkLGNhbldyaXRlKXtmdW5jdGlvbiBMYXp5VWludDhBcnJheSgpe3RoaXMubGVuZ3RoS25vd249ZmFsc2U7dGhpcy5jaHVua3M9W119TGF6eVVpbnQ4QXJyYXkucHJvdG90eXBlLmdldD1mdW5jdGlvbiBMYXp5VWludDhBcnJheV9nZXQoaWR4KXtpZihpZHg+dGhpcy5sZW5ndGgtMXx8aWR4PDApe3JldHVybiB1bmRlZmluZWR9dmFyIGNodW5rT2Zmc2V0PWlkeCV0aGlzLmNodW5rU2l6ZTt2YXIgY2h1bmtOdW09aWR4L3RoaXMuY2h1bmtTaXplfDA7cmV0dXJuIHRoaXMuZ2V0dGVyKGNodW5rTnVtKVtjaHVua09mZnNldF19O0xhenlVaW50OEFycmF5LnByb3RvdHlwZS5zZXREYXRhR2V0dGVyPWZ1bmN0aW9uIExhenlVaW50OEFycmF5X3NldERhdGFHZXR0ZXIoZ2V0dGVyKXt0aGlzLmdldHRlcj1nZXR0ZXJ9O0xhenlVaW50OEFycmF5LnByb3RvdHlwZS5jYWNoZUxlbmd0aD1mdW5jdGlvbiBMYXp5VWludDhBcnJheV9jYWNoZUxlbmd0aCgpe3ZhciB4aHI9bmV3IFhNTEh0dHBSZXF1ZXN0O3hoci5vcGVuKFwiSEVBRFwiLHVybCxmYWxzZSk7eGhyLnNlbmQobnVsbCk7aWYoISh4aHIuc3RhdHVzPj0yMDAmJnhoci5zdGF0dXM8MzAwfHx4aHIuc3RhdHVzPT09MzA0KSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBsb2FkIFwiK3VybCtcIi4gU3RhdHVzOiBcIit4aHIuc3RhdHVzKTt2YXIgZGF0YWxlbmd0aD1OdW1iZXIoeGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1sZW5ndGhcIikpO3ZhciBoZWFkZXI7dmFyIGhhc0J5dGVTZXJ2aW5nPShoZWFkZXI9eGhyLmdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSkmJmhlYWRlcj09PVwiYnl0ZXNcIjt2YXIgdXNlc0d6aXA9KGhlYWRlcj14aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUVuY29kaW5nXCIpKSYmaGVhZGVyPT09XCJnemlwXCI7dmFyIGNodW5rU2l6ZT0xMDI0KjEwMjQ7aWYoIWhhc0J5dGVTZXJ2aW5nKWNodW5rU2l6ZT1kYXRhbGVuZ3RoO3ZhciBkb1hIUj0oZnJvbSx0byk9PntpZihmcm9tPnRvKXRocm93IG5ldyBFcnJvcihcImludmFsaWQgcmFuZ2UgKFwiK2Zyb20rXCIsIFwiK3RvK1wiKSBvciBubyBieXRlcyByZXF1ZXN0ZWQhXCIpO2lmKHRvPmRhdGFsZW5ndGgtMSl0aHJvdyBuZXcgRXJyb3IoXCJvbmx5IFwiK2RhdGFsZW5ndGgrXCIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yIVwiKTt2YXIgeGhyPW5ldyBYTUxIdHRwUmVxdWVzdDt4aHIub3BlbihcIkdFVFwiLHVybCxmYWxzZSk7aWYoZGF0YWxlbmd0aCE9PWNodW5rU2l6ZSl4aHIuc2V0UmVxdWVzdEhlYWRlcihcIlJhbmdlXCIsXCJieXRlcz1cIitmcm9tK1wiLVwiK3RvKTt4aHIucmVzcG9uc2VUeXBlPVwiYXJyYXlidWZmZXJcIjtpZih4aHIub3ZlcnJpZGVNaW1lVHlwZSl7eGhyLm92ZXJyaWRlTWltZVR5cGUoXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXgtdXNlci1kZWZpbmVkXCIpfXhoci5zZW5kKG51bGwpO2lmKCEoeGhyLnN0YXR1cz49MjAwJiZ4aHIuc3RhdHVzPDMwMHx8eGhyLnN0YXR1cz09PTMwNCkpdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgbG9hZCBcIit1cmwrXCIuIFN0YXR1czogXCIreGhyLnN0YXR1cyk7aWYoeGhyLnJlc3BvbnNlIT09dW5kZWZpbmVkKXtyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlfHxbXSl9cmV0dXJuIGludEFycmF5RnJvbVN0cmluZyh4aHIucmVzcG9uc2VUZXh0fHxcIlwiLHRydWUpfTt2YXIgbGF6eUFycmF5PXRoaXM7bGF6eUFycmF5LnNldERhdGFHZXR0ZXIoY2h1bmtOdW09Pnt2YXIgc3RhcnQ9Y2h1bmtOdW0qY2h1bmtTaXplO3ZhciBlbmQ9KGNodW5rTnVtKzEpKmNodW5rU2l6ZS0xO2VuZD1NYXRoLm1pbihlbmQsZGF0YWxlbmd0aC0xKTtpZih0eXBlb2YgbGF6eUFycmF5LmNodW5rc1tjaHVua051bV09PVwidW5kZWZpbmVkXCIpe2xhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPWRvWEhSKHN0YXJ0LGVuZCl9aWYodHlwZW9mIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dPT1cInVuZGVmaW5lZFwiKXRocm93IG5ldyBFcnJvcihcImRvWEhSIGZhaWxlZCFcIik7cmV0dXJuIGxhenlBcnJheS5jaHVua3NbY2h1bmtOdW1dfSk7aWYodXNlc0d6aXB8fCFkYXRhbGVuZ3RoKXtjaHVua1NpemU9ZGF0YWxlbmd0aD0xO2RhdGFsZW5ndGg9dGhpcy5nZXR0ZXIoMCkubGVuZ3RoO2NodW5rU2l6ZT1kYXRhbGVuZ3RoO291dChcIkxhenlGaWxlcyBvbiBnemlwIGZvcmNlcyBkb3dubG9hZCBvZiB0aGUgd2hvbGUgZmlsZSB3aGVuIGxlbmd0aCBpcyBhY2Nlc3NlZFwiKX10aGlzLl9sZW5ndGg9ZGF0YWxlbmd0aDt0aGlzLl9jaHVua1NpemU9Y2h1bmtTaXplO3RoaXMubGVuZ3RoS25vd249dHJ1ZX07aWYodHlwZW9mIFhNTEh0dHBSZXF1ZXN0IT1cInVuZGVmaW5lZFwiKXtpZighRU5WSVJPTk1FTlRfSVNfV09SS0VSKXRocm93XCJDYW5ub3QgZG8gc3luY2hyb25vdXMgYmluYXJ5IFhIUnMgb3V0c2lkZSB3ZWJ3b3JrZXJzIGluIG1vZGVybiBicm93c2Vycy4gVXNlIC0tZW1iZWQtZmlsZSBvciAtLXByZWxvYWQtZmlsZSBpbiBlbWNjXCI7dmFyIGxhenlBcnJheT1uZXcgTGF6eVVpbnQ4QXJyYXk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMobGF6eUFycmF5LHtsZW5ndGg6e2dldDpmdW5jdGlvbigpe2lmKCF0aGlzLmxlbmd0aEtub3duKXt0aGlzLmNhY2hlTGVuZ3RoKCl9cmV0dXJuIHRoaXMuX2xlbmd0aH19LGNodW5rU2l6ZTp7Z2V0OmZ1bmN0aW9uKCl7aWYoIXRoaXMubGVuZ3RoS25vd24pe3RoaXMuY2FjaGVMZW5ndGgoKX1yZXR1cm4gdGhpcy5fY2h1bmtTaXplfX19KTt2YXIgcHJvcGVydGllcz17aXNEZXZpY2U6ZmFsc2UsY29udGVudHM6bGF6eUFycmF5fX1lbHNle3ZhciBwcm9wZXJ0aWVzPXtpc0RldmljZTpmYWxzZSx1cmw6dXJsfX12YXIgbm9kZT1GUy5jcmVhdGVGaWxlKHBhcmVudCxuYW1lLHByb3BlcnRpZXMsY2FuUmVhZCxjYW5Xcml0ZSk7aWYocHJvcGVydGllcy5jb250ZW50cyl7bm9kZS5jb250ZW50cz1wcm9wZXJ0aWVzLmNvbnRlbnRzfWVsc2UgaWYocHJvcGVydGllcy51cmwpe25vZGUuY29udGVudHM9bnVsbDtub2RlLnVybD1wcm9wZXJ0aWVzLnVybH1PYmplY3QuZGVmaW5lUHJvcGVydGllcyhub2RlLHt1c2VkQnl0ZXM6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRlbnRzLmxlbmd0aH19fSk7dmFyIHN0cmVhbV9vcHM9e307dmFyIGtleXM9T2JqZWN0LmtleXMobm9kZS5zdHJlYW1fb3BzKTtrZXlzLmZvckVhY2goa2V5PT57dmFyIGZuPW5vZGUuc3RyZWFtX29wc1trZXldO3N0cmVhbV9vcHNba2V5XT1mdW5jdGlvbiBmb3JjZUxvYWRMYXp5RmlsZSgpe0ZTLmZvcmNlTG9hZEZpbGUobm9kZSk7cmV0dXJuIGZuLmFwcGx5KG51bGwsYXJndW1lbnRzKX19KTtmdW5jdGlvbiB3cml0ZUNodW5rcyhzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pe3ZhciBjb250ZW50cz1zdHJlYW0ubm9kZS5jb250ZW50cztpZihwb3NpdGlvbj49Y29udGVudHMubGVuZ3RoKXJldHVybiAwO3ZhciBzaXplPU1hdGgubWluKGNvbnRlbnRzLmxlbmd0aC1wb3NpdGlvbixsZW5ndGgpO2lmKGNvbnRlbnRzLnNsaWNlKXtmb3IodmFyIGk9MDtpPHNpemU7aSsrKXtidWZmZXJbb2Zmc2V0K2ldPWNvbnRlbnRzW3Bvc2l0aW9uK2ldfX1lbHNle2Zvcih2YXIgaT0wO2k8c2l6ZTtpKyspe2J1ZmZlcltvZmZzZXQraV09Y29udGVudHMuZ2V0KHBvc2l0aW9uK2kpfX1yZXR1cm4gc2l6ZX1zdHJlYW1fb3BzLnJlYWQ9KHN0cmVhbSxidWZmZXIsb2Zmc2V0LGxlbmd0aCxwb3NpdGlvbik9PntGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO3JldHVybiB3cml0ZUNodW5rcyhzdHJlYW0sYnVmZmVyLG9mZnNldCxsZW5ndGgscG9zaXRpb24pfTtzdHJlYW1fb3BzLm1tYXA9KHN0cmVhbSxsZW5ndGgscG9zaXRpb24scHJvdCxmbGFncyk9PntGUy5mb3JjZUxvYWRGaWxlKG5vZGUpO3ZhciBwdHI9bW1hcEFsbG9jKGxlbmd0aCk7aWYoIXB0cil7dGhyb3cgbmV3IEZTLkVycm5vRXJyb3IoNDgpfXdyaXRlQ2h1bmtzKHN0cmVhbSxIRUFQOCxwdHIsbGVuZ3RoLHBvc2l0aW9uKTtyZXR1cm57cHRyOnB0cixhbGxvY2F0ZWQ6dHJ1ZX19O25vZGUuc3RyZWFtX29wcz1zdHJlYW1fb3BzO3JldHVybiBub2RlfX07dmFyIFNZU0NBTExTPXtERUZBVUxUX1BPTExNQVNLOjUsY2FsY3VsYXRlQXQoZGlyZmQscGF0aCxhbGxvd0VtcHR5KXtpZihQQVRILmlzQWJzKHBhdGgpKXtyZXR1cm4gcGF0aH12YXIgZGlyO2lmKGRpcmZkPT09LTEwMCl7ZGlyPUZTLmN3ZCgpfWVsc2V7dmFyIGRpcnN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZGlyZmQpO2Rpcj1kaXJzdHJlYW0ucGF0aH1pZihwYXRoLmxlbmd0aD09MCl7aWYoIWFsbG93RW1wdHkpe3Rocm93IG5ldyBGUy5FcnJub0Vycm9yKDQ0KX1yZXR1cm4gZGlyfXJldHVybiBQQVRILmpvaW4yKGRpcixwYXRoKX0sZG9TdGF0KGZ1bmMscGF0aCxidWYpe3RyeXt2YXIgc3RhdD1mdW5jKHBhdGgpfWNhdGNoKGUpe2lmKGUmJmUubm9kZSYmUEFUSC5ub3JtYWxpemUocGF0aCkhPT1QQVRILm5vcm1hbGl6ZShGUy5nZXRQYXRoKGUubm9kZSkpKXtyZXR1cm4tNTR9dGhyb3cgZX1IRUFQMzJbYnVmPj4yXT1zdGF0LmRldjtIRUFQMzJbYnVmKzQ+PjJdPXN0YXQubW9kZTtIRUFQVTMyW2J1Zis4Pj4yXT1zdGF0Lm5saW5rO0hFQVAzMltidWYrMTI+PjJdPXN0YXQudWlkO0hFQVAzMltidWYrMTY+PjJdPXN0YXQuZ2lkO0hFQVAzMltidWYrMjA+PjJdPXN0YXQucmRldjt0ZW1wSTY0PVtzdGF0LnNpemU+Pj4wLCh0ZW1wRG91YmxlPXN0YXQuc2l6ZSwrTWF0aC5hYnModGVtcERvdWJsZSk+PTE/dGVtcERvdWJsZT4wPytNYXRoLmZsb29yKHRlbXBEb3VibGUvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgodGVtcERvdWJsZS0rKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltidWYrMjQ+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW2J1ZisyOD4+Ml09dGVtcEk2NFsxXTtIRUFQMzJbYnVmKzMyPj4yXT00MDk2O0hFQVAzMltidWYrMzY+PjJdPXN0YXQuYmxvY2tzO3ZhciBhdGltZT1zdGF0LmF0aW1lLmdldFRpbWUoKTt2YXIgbXRpbWU9c3RhdC5tdGltZS5nZXRUaW1lKCk7dmFyIGN0aW1lPXN0YXQuY3RpbWUuZ2V0VGltZSgpO3RlbXBJNjQ9W01hdGguZmxvb3IoYXRpbWUvMWUzKT4+PjAsKHRlbXBEb3VibGU9TWF0aC5mbG9vcihhdGltZS8xZTMpLCtNYXRoLmFicyh0ZW1wRG91YmxlKT49MT90ZW1wRG91YmxlPjA/K01hdGguZmxvb3IodGVtcERvdWJsZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlLSsofn50ZW1wRG91YmxlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sSEVBUDMyW2J1Zis0MD4+Ml09dGVtcEk2NFswXSxIRUFQMzJbYnVmKzQ0Pj4yXT10ZW1wSTY0WzFdO0hFQVBVMzJbYnVmKzQ4Pj4yXT1hdGltZSUxZTMqMWUzO3RlbXBJNjQ9W01hdGguZmxvb3IobXRpbWUvMWUzKT4+PjAsKHRlbXBEb3VibGU9TWF0aC5mbG9vcihtdGltZS8xZTMpLCtNYXRoLmFicyh0ZW1wRG91YmxlKT49MT90ZW1wRG91YmxlPjA/K01hdGguZmxvb3IodGVtcERvdWJsZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlLSsofn50ZW1wRG91YmxlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sSEVBUDMyW2J1Zis1Nj4+Ml09dGVtcEk2NFswXSxIRUFQMzJbYnVmKzYwPj4yXT10ZW1wSTY0WzFdO0hFQVBVMzJbYnVmKzY0Pj4yXT1tdGltZSUxZTMqMWUzO3RlbXBJNjQ9W01hdGguZmxvb3IoY3RpbWUvMWUzKT4+PjAsKHRlbXBEb3VibGU9TWF0aC5mbG9vcihjdGltZS8xZTMpLCtNYXRoLmFicyh0ZW1wRG91YmxlKT49MT90ZW1wRG91YmxlPjA/K01hdGguZmxvb3IodGVtcERvdWJsZS80Mjk0OTY3Mjk2KT4+PjA6fn4rTWF0aC5jZWlsKCh0ZW1wRG91YmxlLSsofn50ZW1wRG91YmxlPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV0sSEVBUDMyW2J1Zis3Mj4+Ml09dGVtcEk2NFswXSxIRUFQMzJbYnVmKzc2Pj4yXT10ZW1wSTY0WzFdO0hFQVBVMzJbYnVmKzgwPj4yXT1jdGltZSUxZTMqMWUzO3RlbXBJNjQ9W3N0YXQuaW5vPj4+MCwodGVtcERvdWJsZT1zdGF0LmlubywrTWF0aC5hYnModGVtcERvdWJsZSk+PTE/dGVtcERvdWJsZT4wPytNYXRoLmZsb29yKHRlbXBEb3VibGUvNDI5NDk2NzI5Nik+Pj4wOn5+K01hdGguY2VpbCgodGVtcERvdWJsZS0rKH5+dGVtcERvdWJsZT4+PjApKS80Mjk0OTY3Mjk2KT4+PjA6MCldLEhFQVAzMltidWYrODg+PjJdPXRlbXBJNjRbMF0sSEVBUDMyW2J1Zis5Mj4+Ml09dGVtcEk2NFsxXTtyZXR1cm4gMH0sZG9Nc3luYyhhZGRyLHN0cmVhbSxsZW4sZmxhZ3Msb2Zmc2V0KXtpZighRlMuaXNGaWxlKHN0cmVhbS5ub2RlLm1vZGUpKXt0aHJvdyBuZXcgRlMuRXJybm9FcnJvcig0Myl9aWYoZmxhZ3MmMil7cmV0dXJuIDB9dmFyIGJ1ZmZlcj1IRUFQVTguc2xpY2UoYWRkcixhZGRyK2xlbik7RlMubXN5bmMoc3RyZWFtLGJ1ZmZlcixvZmZzZXQsbGVuLGZsYWdzKX0sdmFyYXJnczp1bmRlZmluZWQsZ2V0KCl7dmFyIHJldD1IRUFQMzJbK1NZU0NBTExTLnZhcmFyZ3M+PjJdO1NZU0NBTExTLnZhcmFyZ3MrPTQ7cmV0dXJuIHJldH0sZ2V0cCgpe3JldHVybiBTWVNDQUxMUy5nZXQoKX0sZ2V0U3RyKHB0cil7dmFyIHJldD1VVEY4VG9TdHJpbmcocHRyKTtyZXR1cm4gcmV0fSxnZXRTdHJlYW1Gcm9tRkQoZmQpe3ZhciBzdHJlYW09RlMuZ2V0U3RyZWFtQ2hlY2tlZChmZCk7cmV0dXJuIHN0cmVhbX19O3ZhciBfZW52aXJvbl9nZXQ9KF9fZW52aXJvbixlbnZpcm9uX2J1Zik9Pnt2YXIgYnVmU2l6ZT0wO2dldEVudlN0cmluZ3MoKS5mb3JFYWNoKChzdHJpbmcsaSk9Pnt2YXIgcHRyPWVudmlyb25fYnVmK2J1ZlNpemU7SEVBUFUzMltfX2Vudmlyb24raSo0Pj4yXT1wdHI7c3RyaW5nVG9Bc2NpaShzdHJpbmcscHRyKTtidWZTaXplKz1zdHJpbmcubGVuZ3RoKzF9KTtyZXR1cm4gMH07dmFyIF9lbnZpcm9uX3NpemVzX2dldD0ocGVudmlyb25fY291bnQscGVudmlyb25fYnVmX3NpemUpPT57dmFyIHN0cmluZ3M9Z2V0RW52U3RyaW5ncygpO0hFQVBVMzJbcGVudmlyb25fY291bnQ+PjJdPXN0cmluZ3MubGVuZ3RoO3ZhciBidWZTaXplPTA7c3RyaW5ncy5mb3JFYWNoKHN0cmluZz0+YnVmU2l6ZSs9c3RyaW5nLmxlbmd0aCsxKTtIRUFQVTMyW3BlbnZpcm9uX2J1Zl9zaXplPj4yXT1idWZTaXplO3JldHVybiAwfTtmdW5jdGlvbiBfZmRfY2xvc2UoZmQpe3RyeXt2YXIgc3RyZWFtPVNZU0NBTExTLmdldFN0cmVhbUZyb21GRChmZCk7RlMuY2xvc2Uoc3RyZWFtKTtyZXR1cm4gMH1jYXRjaChlKXtpZih0eXBlb2YgRlM9PVwidW5kZWZpbmVkXCJ8fCEoZS5uYW1lPT09XCJFcnJub0Vycm9yXCIpKXRocm93IGU7cmV0dXJuIGUuZXJybm99fXZhciBkb1JlYWR2PShzdHJlYW0saW92LGlvdmNudCxvZmZzZXQpPT57dmFyIHJldD0wO2Zvcih2YXIgaT0wO2k8aW92Y250O2krKyl7dmFyIHB0cj1IRUFQVTMyW2lvdj4+Ml07dmFyIGxlbj1IRUFQVTMyW2lvdis0Pj4yXTtpb3YrPTg7dmFyIGN1cnI9RlMucmVhZChzdHJlYW0sSEVBUDgscHRyLGxlbixvZmZzZXQpO2lmKGN1cnI8MClyZXR1cm4tMTtyZXQrPWN1cnI7aWYoY3VycjxsZW4pYnJlYWs7aWYodHlwZW9mIG9mZnNldCE9PVwidW5kZWZpbmVkXCIpe29mZnNldCs9Y3Vycn19cmV0dXJuIHJldH07ZnVuY3Rpb24gX2ZkX3JlYWQoZmQsaW92LGlvdmNudCxwbnVtKXt0cnl7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO3ZhciBudW09ZG9SZWFkdihzdHJlYW0saW92LGlvdmNudCk7SEVBUFUzMltwbnVtPj4yXT1udW07cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT1cInVuZGVmaW5lZFwifHwhKGUubmFtZT09PVwiRXJybm9FcnJvclwiKSl0aHJvdyBlO3JldHVybiBlLmVycm5vfX12YXIgY29udmVydEkzMlBhaXJUb0k1M0NoZWNrZWQ9KGxvLGhpKT0+aGkrMjA5NzE1Mj4+PjA8NDE5NDMwNS0hIWxvPyhsbz4+PjApK2hpKjQyOTQ5NjcyOTY6TmFOO2Z1bmN0aW9uIF9mZF9zZWVrKGZkLG9mZnNldF9sb3csb2Zmc2V0X2hpZ2gsd2hlbmNlLG5ld09mZnNldCl7dmFyIG9mZnNldD1jb252ZXJ0STMyUGFpclRvSTUzQ2hlY2tlZChvZmZzZXRfbG93LG9mZnNldF9oaWdoKTt0cnl7aWYoaXNOYU4ob2Zmc2V0KSlyZXR1cm4gNjE7dmFyIHN0cmVhbT1TWVNDQUxMUy5nZXRTdHJlYW1Gcm9tRkQoZmQpO0ZTLmxsc2VlayhzdHJlYW0sb2Zmc2V0LHdoZW5jZSk7dGVtcEk2ND1bc3RyZWFtLnBvc2l0aW9uPj4+MCwodGVtcERvdWJsZT1zdHJlYW0ucG9zaXRpb24sK01hdGguYWJzKHRlbXBEb3VibGUpPj0xP3RlbXBEb3VibGU+MD8rTWF0aC5mbG9vcih0ZW1wRG91YmxlLzQyOTQ5NjcyOTYpPj4+MDp+fitNYXRoLmNlaWwoKHRlbXBEb3VibGUtKyh+fnRlbXBEb3VibGU+Pj4wKSkvNDI5NDk2NzI5Nik+Pj4wOjApXSxIRUFQMzJbbmV3T2Zmc2V0Pj4yXT10ZW1wSTY0WzBdLEhFQVAzMltuZXdPZmZzZXQrND4+Ml09dGVtcEk2NFsxXTtpZihzdHJlYW0uZ2V0ZGVudHMmJm9mZnNldD09PTAmJndoZW5jZT09PTApc3RyZWFtLmdldGRlbnRzPW51bGw7cmV0dXJuIDB9Y2F0Y2goZSl7aWYodHlwZW9mIEZTPT1cInVuZGVmaW5lZFwifHwhKGUubmFtZT09PVwiRXJybm9FcnJvclwiKSl0aHJvdyBlO3JldHVybiBlLmVycm5vfX12YXIgZG9Xcml0ZXY9KHN0cmVhbSxpb3YsaW92Y250LG9mZnNldCk9Pnt2YXIgcmV0PTA7Zm9yKHZhciBpPTA7aTxpb3ZjbnQ7aSsrKXt2YXIgcHRyPUhFQVBVMzJbaW92Pj4yXTt2YXIgbGVuPUhFQVBVMzJbaW92KzQ+PjJdO2lvdis9ODt2YXIgY3Vycj1GUy53cml0ZShzdHJlYW0sSEVBUDgscHRyLGxlbixvZmZzZXQpO2lmKGN1cnI8MClyZXR1cm4tMTtyZXQrPWN1cnI7aWYodHlwZW9mIG9mZnNldCE9PVwidW5kZWZpbmVkXCIpe29mZnNldCs9Y3Vycn19cmV0dXJuIHJldH07ZnVuY3Rpb24gX2ZkX3dyaXRlKGZkLGlvdixpb3ZjbnQscG51bSl7dHJ5e3ZhciBzdHJlYW09U1lTQ0FMTFMuZ2V0U3RyZWFtRnJvbUZEKGZkKTt2YXIgbnVtPWRvV3JpdGV2KHN0cmVhbSxpb3YsaW92Y250KTtIRUFQVTMyW3BudW0+PjJdPW51bTtyZXR1cm4gMH1jYXRjaChlKXtpZih0eXBlb2YgRlM9PVwidW5kZWZpbmVkXCJ8fCEoZS5uYW1lPT09XCJFcnJub0Vycm9yXCIpKXRocm93IGU7cmV0dXJuIGUuZXJybm99fXZhciBpc0xlYXBZZWFyPXllYXI9PnllYXIlND09PTAmJih5ZWFyJTEwMCE9PTB8fHllYXIlNDAwPT09MCk7dmFyIGFycmF5U3VtPShhcnJheSxpbmRleCk9Pnt2YXIgc3VtPTA7Zm9yKHZhciBpPTA7aTw9aW5kZXg7c3VtKz1hcnJheVtpKytdKXt9cmV0dXJuIHN1bX07dmFyIE1PTlRIX0RBWVNfTEVBUD1bMzEsMjksMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdO3ZhciBNT05USF9EQVlTX1JFR1VMQVI9WzMxLDI4LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXTt2YXIgYWRkRGF5cz0oZGF0ZSxkYXlzKT0+e3ZhciBuZXdEYXRlPW5ldyBEYXRlKGRhdGUuZ2V0VGltZSgpKTt3aGlsZShkYXlzPjApe3ZhciBsZWFwPWlzTGVhcFllYXIobmV3RGF0ZS5nZXRGdWxsWWVhcigpKTt2YXIgY3VycmVudE1vbnRoPW5ld0RhdGUuZ2V0TW9udGgoKTt2YXIgZGF5c0luQ3VycmVudE1vbnRoPShsZWFwP01PTlRIX0RBWVNfTEVBUDpNT05USF9EQVlTX1JFR1VMQVIpW2N1cnJlbnRNb250aF07aWYoZGF5cz5kYXlzSW5DdXJyZW50TW9udGgtbmV3RGF0ZS5nZXREYXRlKCkpe2RheXMtPWRheXNJbkN1cnJlbnRNb250aC1uZXdEYXRlLmdldERhdGUoKSsxO25ld0RhdGUuc2V0RGF0ZSgxKTtpZihjdXJyZW50TW9udGg8MTEpe25ld0RhdGUuc2V0TW9udGgoY3VycmVudE1vbnRoKzEpfWVsc2V7bmV3RGF0ZS5zZXRNb250aCgwKTtuZXdEYXRlLnNldEZ1bGxZZWFyKG5ld0RhdGUuZ2V0RnVsbFllYXIoKSsxKX19ZWxzZXtuZXdEYXRlLnNldERhdGUobmV3RGF0ZS5nZXREYXRlKCkrZGF5cyk7cmV0dXJuIG5ld0RhdGV9fXJldHVybiBuZXdEYXRlfTt2YXIgd3JpdGVBcnJheVRvTWVtb3J5PShhcnJheSxidWZmZXIpPT57SEVBUDguc2V0KGFycmF5LGJ1ZmZlcil9O3ZhciBfc3RyZnRpbWU9KHMsbWF4c2l6ZSxmb3JtYXQsdG0pPT57dmFyIHRtX3pvbmU9SEVBUFUzMlt0bSs0MD4+Ml07dmFyIGRhdGU9e3RtX3NlYzpIRUFQMzJbdG0+PjJdLHRtX21pbjpIRUFQMzJbdG0rND4+Ml0sdG1faG91cjpIRUFQMzJbdG0rOD4+Ml0sdG1fbWRheTpIRUFQMzJbdG0rMTI+PjJdLHRtX21vbjpIRUFQMzJbdG0rMTY+PjJdLHRtX3llYXI6SEVBUDMyW3RtKzIwPj4yXSx0bV93ZGF5OkhFQVAzMlt0bSsyND4+Ml0sdG1feWRheTpIRUFQMzJbdG0rMjg+PjJdLHRtX2lzZHN0OkhFQVAzMlt0bSszMj4+Ml0sdG1fZ210b2ZmOkhFQVAzMlt0bSszNj4+Ml0sdG1fem9uZTp0bV96b25lP1VURjhUb1N0cmluZyh0bV96b25lKTpcIlwifTt2YXIgcGF0dGVybj1VVEY4VG9TdHJpbmcoZm9ybWF0KTt2YXIgRVhQQU5TSU9OX1JVTEVTXzE9e1wiJWNcIjpcIiVhICViICVkICVIOiVNOiVTICVZXCIsXCIlRFwiOlwiJW0vJWQvJXlcIixcIiVGXCI6XCIlWS0lbS0lZFwiLFwiJWhcIjpcIiViXCIsXCIlclwiOlwiJUk6JU06JVMgJXBcIixcIiVSXCI6XCIlSDolTVwiLFwiJVRcIjpcIiVIOiVNOiVTXCIsXCIleFwiOlwiJW0vJWQvJXlcIixcIiVYXCI6XCIlSDolTTolU1wiLFwiJUVjXCI6XCIlY1wiLFwiJUVDXCI6XCIlQ1wiLFwiJUV4XCI6XCIlbS8lZC8leVwiLFwiJUVYXCI6XCIlSDolTTolU1wiLFwiJUV5XCI6XCIleVwiLFwiJUVZXCI6XCIlWVwiLFwiJU9kXCI6XCIlZFwiLFwiJU9lXCI6XCIlZVwiLFwiJU9IXCI6XCIlSFwiLFwiJU9JXCI6XCIlSVwiLFwiJU9tXCI6XCIlbVwiLFwiJU9NXCI6XCIlTVwiLFwiJU9TXCI6XCIlU1wiLFwiJU91XCI6XCIldVwiLFwiJU9VXCI6XCIlVVwiLFwiJU9WXCI6XCIlVlwiLFwiJU93XCI6XCIld1wiLFwiJU9XXCI6XCIlV1wiLFwiJU95XCI6XCIleVwifTtmb3IodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzEpe3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSxcImdcIiksRVhQQU5TSU9OX1JVTEVTXzFbcnVsZV0pfXZhciBXRUVLREFZUz1bXCJTdW5kYXlcIixcIk1vbmRheVwiLFwiVHVlc2RheVwiLFwiV2VkbmVzZGF5XCIsXCJUaHVyc2RheVwiLFwiRnJpZGF5XCIsXCJTYXR1cmRheVwiXTt2YXIgTU9OVEhTPVtcIkphbnVhcnlcIixcIkZlYnJ1YXJ5XCIsXCJNYXJjaFwiLFwiQXByaWxcIixcIk1heVwiLFwiSnVuZVwiLFwiSnVseVwiLFwiQXVndXN0XCIsXCJTZXB0ZW1iZXJcIixcIk9jdG9iZXJcIixcIk5vdmVtYmVyXCIsXCJEZWNlbWJlclwiXTtmdW5jdGlvbiBsZWFkaW5nU29tZXRoaW5nKHZhbHVlLGRpZ2l0cyxjaGFyYWN0ZXIpe3ZhciBzdHI9dHlwZW9mIHZhbHVlPT1cIm51bWJlclwiP3ZhbHVlLnRvU3RyaW5nKCk6dmFsdWV8fFwiXCI7d2hpbGUoc3RyLmxlbmd0aDxkaWdpdHMpe3N0cj1jaGFyYWN0ZXJbMF0rc3RyfXJldHVybiBzdHJ9ZnVuY3Rpb24gbGVhZGluZ051bGxzKHZhbHVlLGRpZ2l0cyl7cmV0dXJuIGxlYWRpbmdTb21ldGhpbmcodmFsdWUsZGlnaXRzLFwiMFwiKX1mdW5jdGlvbiBjb21wYXJlQnlEYXkoZGF0ZTEsZGF0ZTIpe2Z1bmN0aW9uIHNnbih2YWx1ZSl7cmV0dXJuIHZhbHVlPDA/LTE6dmFsdWU+MD8xOjB9dmFyIGNvbXBhcmU7aWYoKGNvbXBhcmU9c2duKGRhdGUxLmdldEZ1bGxZZWFyKCktZGF0ZTIuZ2V0RnVsbFllYXIoKSkpPT09MCl7aWYoKGNvbXBhcmU9c2duKGRhdGUxLmdldE1vbnRoKCktZGF0ZTIuZ2V0TW9udGgoKSkpPT09MCl7Y29tcGFyZT1zZ24oZGF0ZTEuZ2V0RGF0ZSgpLWRhdGUyLmdldERhdGUoKSl9fXJldHVybiBjb21wYXJlfWZ1bmN0aW9uIGdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGgpe3N3aXRjaChqYW5Gb3VydGguZ2V0RGF5KCkpe2Nhc2UgMDpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCktMSwxMSwyOSk7Y2FzZSAxOnJldHVybiBqYW5Gb3VydGg7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKSwwLDMpO2Nhc2UgMzpyZXR1cm4gbmV3IERhdGUoamFuRm91cnRoLmdldEZ1bGxZZWFyKCksMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLDAsMSk7Y2FzZSA1OnJldHVybiBuZXcgRGF0ZShqYW5Gb3VydGguZ2V0RnVsbFllYXIoKS0xLDExLDMxKTtjYXNlIDY6cmV0dXJuIG5ldyBEYXRlKGphbkZvdXJ0aC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBnZXRXZWVrQmFzZWRZZWFyKGRhdGUpe3ZhciB0aGlzRGF0ZT1hZGREYXlzKG5ldyBEYXRlKGRhdGUudG1feWVhcisxOTAwLDAsMSksZGF0ZS50bV95ZGF5KTt2YXIgamFuRm91cnRoVGhpc1llYXI9bmV3IERhdGUodGhpc0RhdGUuZ2V0RnVsbFllYXIoKSwwLDQpO3ZhciBqYW5Gb3VydGhOZXh0WWVhcj1uZXcgRGF0ZSh0aGlzRGF0ZS5nZXRGdWxsWWVhcigpKzEsMCw0KTt2YXIgZmlyc3RXZWVrU3RhcnRUaGlzWWVhcj1nZXRGaXJzdFdlZWtTdGFydERhdGUoamFuRm91cnRoVGhpc1llYXIpO3ZhciBmaXJzdFdlZWtTdGFydE5leHRZZWFyPWdldEZpcnN0V2Vla1N0YXJ0RGF0ZShqYW5Gb3VydGhOZXh0WWVhcik7aWYoY29tcGFyZUJ5RGF5KGZpcnN0V2Vla1N0YXJ0VGhpc1llYXIsdGhpc0RhdGUpPD0wKXtpZihjb21wYXJlQnlEYXkoZmlyc3RXZWVrU3RhcnROZXh0WWVhcix0aGlzRGF0ZSk8PTApe3JldHVybiB0aGlzRGF0ZS5nZXRGdWxsWWVhcigpKzF9cmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCl9cmV0dXJuIHRoaXNEYXRlLmdldEZ1bGxZZWFyKCktMX12YXIgRVhQQU5TSU9OX1JVTEVTXzI9e1wiJWFcIjpkYXRlPT5XRUVLREFZU1tkYXRlLnRtX3dkYXldLnN1YnN0cmluZygwLDMpLFwiJUFcIjpkYXRlPT5XRUVLREFZU1tkYXRlLnRtX3dkYXldLFwiJWJcIjpkYXRlPT5NT05USFNbZGF0ZS50bV9tb25dLnN1YnN0cmluZygwLDMpLFwiJUJcIjpkYXRlPT5NT05USFNbZGF0ZS50bV9tb25dLFwiJUNcIjpkYXRlPT57dmFyIHllYXI9ZGF0ZS50bV95ZWFyKzE5MDA7cmV0dXJuIGxlYWRpbmdOdWxscyh5ZWFyLzEwMHwwLDIpfSxcIiVkXCI6ZGF0ZT0+bGVhZGluZ051bGxzKGRhdGUudG1fbWRheSwyKSxcIiVlXCI6ZGF0ZT0+bGVhZGluZ1NvbWV0aGluZyhkYXRlLnRtX21kYXksMixcIiBcIiksXCIlZ1wiOmRhdGU9PmdldFdlZWtCYXNlZFllYXIoZGF0ZSkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlR1wiOmRhdGU9PmdldFdlZWtCYXNlZFllYXIoZGF0ZSksXCIlSFwiOmRhdGU9PmxlYWRpbmdOdWxscyhkYXRlLnRtX2hvdXIsMiksXCIlSVwiOmRhdGU9Pnt2YXIgdHdlbHZlSG91cj1kYXRlLnRtX2hvdXI7aWYodHdlbHZlSG91cj09MCl0d2VsdmVIb3VyPTEyO2Vsc2UgaWYodHdlbHZlSG91cj4xMil0d2VsdmVIb3VyLT0xMjtyZXR1cm4gbGVhZGluZ051bGxzKHR3ZWx2ZUhvdXIsMil9LFwiJWpcIjpkYXRlPT5sZWFkaW5nTnVsbHMoZGF0ZS50bV9tZGF5K2FycmF5U3VtKGlzTGVhcFllYXIoZGF0ZS50bV95ZWFyKzE5MDApP01PTlRIX0RBWVNfTEVBUDpNT05USF9EQVlTX1JFR1VMQVIsZGF0ZS50bV9tb24tMSksMyksXCIlbVwiOmRhdGU9PmxlYWRpbmdOdWxscyhkYXRlLnRtX21vbisxLDIpLFwiJU1cIjpkYXRlPT5sZWFkaW5nTnVsbHMoZGF0ZS50bV9taW4sMiksXCIlblwiOigpPT5cIlxcblwiLFwiJXBcIjpkYXRlPT57aWYoZGF0ZS50bV9ob3VyPj0wJiZkYXRlLnRtX2hvdXI8MTIpe3JldHVyblwiQU1cIn1yZXR1cm5cIlBNXCJ9LFwiJVNcIjpkYXRlPT5sZWFkaW5nTnVsbHMoZGF0ZS50bV9zZWMsMiksXCIldFwiOigpPT5cIlxcdFwiLFwiJXVcIjpkYXRlPT5kYXRlLnRtX3dkYXl8fDcsXCIlVVwiOmRhdGU9Pnt2YXIgZGF5cz1kYXRlLnRtX3lkYXkrNy1kYXRlLnRtX3dkYXk7cmV0dXJuIGxlYWRpbmdOdWxscyhNYXRoLmZsb29yKGRheXMvNyksMil9LFwiJVZcIjpkYXRlPT57dmFyIHZhbD1NYXRoLmZsb29yKChkYXRlLnRtX3lkYXkrNy0oZGF0ZS50bV93ZGF5KzYpJTcpLzcpO2lmKChkYXRlLnRtX3dkYXkrMzcxLWRhdGUudG1feWRheS0yKSU3PD0yKXt2YWwrK31pZighdmFsKXt2YWw9NTI7dmFyIGRlYzMxPShkYXRlLnRtX3dkYXkrNy1kYXRlLnRtX3lkYXktMSklNztpZihkZWMzMT09NHx8ZGVjMzE9PTUmJmlzTGVhcFllYXIoZGF0ZS50bV95ZWFyJTQwMC0xKSl7dmFsKyt9fWVsc2UgaWYodmFsPT01Myl7dmFyIGphbjE9KGRhdGUudG1fd2RheSszNzEtZGF0ZS50bV95ZGF5KSU3O2lmKGphbjEhPTQmJihqYW4xIT0zfHwhaXNMZWFwWWVhcihkYXRlLnRtX3llYXIpKSl2YWw9MX1yZXR1cm4gbGVhZGluZ051bGxzKHZhbCwyKX0sXCIld1wiOmRhdGU9PmRhdGUudG1fd2RheSxcIiVXXCI6ZGF0ZT0+e3ZhciBkYXlzPWRhdGUudG1feWRheSs3LShkYXRlLnRtX3dkYXkrNiklNztyZXR1cm4gbGVhZGluZ051bGxzKE1hdGguZmxvb3IoZGF5cy83KSwyKX0sXCIleVwiOmRhdGU9PihkYXRlLnRtX3llYXIrMTkwMCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoMiksXCIlWVwiOmRhdGU9PmRhdGUudG1feWVhcisxOTAwLFwiJXpcIjpkYXRlPT57dmFyIG9mZj1kYXRlLnRtX2dtdG9mZjt2YXIgYWhlYWQ9b2ZmPj0wO29mZj1NYXRoLmFicyhvZmYpLzYwO29mZj1vZmYvNjAqMTAwK29mZiU2MDtyZXR1cm4oYWhlYWQ/XCIrXCI6XCItXCIpK1N0cmluZyhcIjAwMDBcIitvZmYpLnNsaWNlKC00KX0sXCIlWlwiOmRhdGU9PmRhdGUudG1fem9uZSxcIiUlXCI6KCk9PlwiJVwifTtwYXR0ZXJuPXBhdHRlcm4ucmVwbGFjZSgvJSUvZyxcIlxcMFxcMFwiKTtmb3IodmFyIHJ1bGUgaW4gRVhQQU5TSU9OX1JVTEVTXzIpe2lmKHBhdHRlcm4uaW5jbHVkZXMocnVsZSkpe3BhdHRlcm49cGF0dGVybi5yZXBsYWNlKG5ldyBSZWdFeHAocnVsZSxcImdcIiksRVhQQU5TSU9OX1JVTEVTXzJbcnVsZV0oZGF0ZSkpfX1wYXR0ZXJuPXBhdHRlcm4ucmVwbGFjZSgvXFwwXFwwL2csXCIlXCIpO3ZhciBieXRlcz1pbnRBcnJheUZyb21TdHJpbmcocGF0dGVybixmYWxzZSk7aWYoYnl0ZXMubGVuZ3RoPm1heHNpemUpe3JldHVybiAwfXdyaXRlQXJyYXlUb01lbW9yeShieXRlcyxzKTtyZXR1cm4gYnl0ZXMubGVuZ3RoLTF9O3ZhciBfc3RyZnRpbWVfbD0ocyxtYXhzaXplLGZvcm1hdCx0bSxsb2MpPT5fc3RyZnRpbWUocyxtYXhzaXplLGZvcm1hdCx0bSk7dmFyIGdldENGdW5jPWlkZW50PT57dmFyIGZ1bmM9TW9kdWxlW1wiX1wiK2lkZW50XTtyZXR1cm4gZnVuY307dmFyIHN0cmluZ1RvVVRGOE9uU3RhY2s9c3RyPT57dmFyIHNpemU9bGVuZ3RoQnl0ZXNVVEY4KHN0cikrMTt2YXIgcmV0PXN0YWNrQWxsb2Moc2l6ZSk7c3RyaW5nVG9VVEY4KHN0cixyZXQsc2l6ZSk7cmV0dXJuIHJldH07dmFyIGNjYWxsPShpZGVudCxyZXR1cm5UeXBlLGFyZ1R5cGVzLGFyZ3Msb3B0cyk9Pnt2YXIgdG9DPXtcInN0cmluZ1wiOnN0cj0+e3ZhciByZXQ9MDtpZihzdHIhPT1udWxsJiZzdHIhPT11bmRlZmluZWQmJnN0ciE9PTApe3JldD1zdHJpbmdUb1VURjhPblN0YWNrKHN0cil9cmV0dXJuIHJldH0sXCJhcnJheVwiOmFycj0+e3ZhciByZXQ9c3RhY2tBbGxvYyhhcnIubGVuZ3RoKTt3cml0ZUFycmF5VG9NZW1vcnkoYXJyLHJldCk7cmV0dXJuIHJldH19O2Z1bmN0aW9uIGNvbnZlcnRSZXR1cm5WYWx1ZShyZXQpe2lmKHJldHVyblR5cGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gVVRGOFRvU3RyaW5nKHJldCl9aWYocmV0dXJuVHlwZT09PVwiYm9vbGVhblwiKXJldHVybiBCb29sZWFuKHJldCk7cmV0dXJuIHJldH12YXIgZnVuYz1nZXRDRnVuYyhpZGVudCk7dmFyIGNBcmdzPVtdO3ZhciBzdGFjaz0wO2lmKGFyZ3Mpe2Zvcih2YXIgaT0wO2k8YXJncy5sZW5ndGg7aSsrKXt2YXIgY29udmVydGVyPXRvQ1thcmdUeXBlc1tpXV07aWYoY29udmVydGVyKXtpZihzdGFjaz09PTApc3RhY2s9c3RhY2tTYXZlKCk7Y0FyZ3NbaV09Y29udmVydGVyKGFyZ3NbaV0pfWVsc2V7Y0FyZ3NbaV09YXJnc1tpXX19fXZhciByZXQ9ZnVuYy5hcHBseShudWxsLGNBcmdzKTtmdW5jdGlvbiBvbkRvbmUocmV0KXtpZihzdGFjayE9PTApc3RhY2tSZXN0b3JlKHN0YWNrKTtyZXR1cm4gY29udmVydFJldHVyblZhbHVlKHJldCl9cmV0PW9uRG9uZShyZXQpO3JldHVybiByZXR9O0ludGVybmFsRXJyb3I9TW9kdWxlW1wiSW50ZXJuYWxFcnJvclwiXT1jbGFzcyBJbnRlcm5hbEVycm9yIGV4dGVuZHMgRXJyb3J7Y29uc3RydWN0b3IobWVzc2FnZSl7c3VwZXIobWVzc2FnZSk7dGhpcy5uYW1lPVwiSW50ZXJuYWxFcnJvclwifX07ZW1iaW5kX2luaXRfY2hhckNvZGVzKCk7QmluZGluZ0Vycm9yPU1vZHVsZVtcIkJpbmRpbmdFcnJvclwiXT1jbGFzcyBCaW5kaW5nRXJyb3IgZXh0ZW5kcyBFcnJvcntjb25zdHJ1Y3RvcihtZXNzYWdlKXtzdXBlcihtZXNzYWdlKTt0aGlzLm5hbWU9XCJCaW5kaW5nRXJyb3JcIn19O2hhbmRsZUFsbG9jYXRvckluaXQoKTtpbml0X2VtdmFsKCk7VW5ib3VuZFR5cGVFcnJvcj1Nb2R1bGVbXCJVbmJvdW5kVHlwZUVycm9yXCJdPWV4dGVuZEVycm9yKEVycm9yLFwiVW5ib3VuZFR5cGVFcnJvclwiKTt2YXIgRlNOb2RlPWZ1bmN0aW9uKHBhcmVudCxuYW1lLG1vZGUscmRldil7aWYoIXBhcmVudCl7cGFyZW50PXRoaXN9dGhpcy5wYXJlbnQ9cGFyZW50O3RoaXMubW91bnQ9cGFyZW50Lm1vdW50O3RoaXMubW91bnRlZD1udWxsO3RoaXMuaWQ9RlMubmV4dElub2RlKys7dGhpcy5uYW1lPW5hbWU7dGhpcy5tb2RlPW1vZGU7dGhpcy5ub2RlX29wcz17fTt0aGlzLnN0cmVhbV9vcHM9e307dGhpcy5yZGV2PXJkZXZ9O3ZhciByZWFkTW9kZT0yOTJ8NzM7dmFyIHdyaXRlTW9kZT0xNDY7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRlNOb2RlLnByb3RvdHlwZSx7cmVhZDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubW9kZSZyZWFkTW9kZSk9PT1yZWFkTW9kZX0sc2V0OmZ1bmN0aW9uKHZhbCl7dmFsP3RoaXMubW9kZXw9cmVhZE1vZGU6dGhpcy5tb2RlJj1+cmVhZE1vZGV9fSx3cml0ZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuKHRoaXMubW9kZSZ3cml0ZU1vZGUpPT09d3JpdGVNb2RlfSxzZXQ6ZnVuY3Rpb24odmFsKXt2YWw/dGhpcy5tb2RlfD13cml0ZU1vZGU6dGhpcy5tb2RlJj1+d3JpdGVNb2RlfX0saXNGb2xkZXI6e2dldDpmdW5jdGlvbigpe3JldHVybiBGUy5pc0Rpcih0aGlzLm1vZGUpfX0saXNEZXZpY2U6e2dldDpmdW5jdGlvbigpe3JldHVybiBGUy5pc0NocmRldih0aGlzLm1vZGUpfX19KTtGUy5GU05vZGU9RlNOb2RlO0ZTLmNyZWF0ZVByZWxvYWRlZEZpbGU9RlNfY3JlYXRlUHJlbG9hZGVkRmlsZTtGUy5zdGF0aWNJbml0KCk7dmFyIHdhc21JbXBvcnRzPXthOl9fX2N4YV90aHJvdyxtOl9fZW1iaW5kX2ZpbmFsaXplX3ZhbHVlX2FycmF5LHA6X19lbWJpbmRfcmVnaXN0ZXJfYmlnaW50LGs6X19lbWJpbmRfcmVnaXN0ZXJfYm9vbCx5Ol9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsLHo6X19lbWJpbmRfcmVnaXN0ZXJfZW51bSxmOl9fZW1iaW5kX3JlZ2lzdGVyX2VudW1fdmFsdWUsajpfX2VtYmluZF9yZWdpc3Rlcl9mbG9hdCxkOl9fZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uLGU6X19lbWJpbmRfcmVnaXN0ZXJfaW50ZWdlcixiOl9fZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3LGg6X19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZyxnOl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nLG46X19lbWJpbmRfcmVnaXN0ZXJfdmFsdWVfYXJyYXksYzpfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9hcnJheV9lbGVtZW50LGw6X19lbWJpbmRfcmVnaXN0ZXJfdm9pZCxpOl9hYm9ydCx4Ol9lbXNjcmlwdGVuX21lbWNweV9qcyx1Ol9lbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwLHI6X2Vudmlyb25fZ2V0LHM6X2Vudmlyb25fc2l6ZXNfZ2V0LHc6X2ZkX2Nsb3NlLHQ6X2ZkX3JlYWQsbzpfZmRfc2Vlayx2Ol9mZF93cml0ZSxxOl9zdHJmdGltZV9sfTt2YXIgd2FzbUV4cG9ydHM9Y3JlYXRlV2FzbSgpO3ZhciBfX193YXNtX2NhbGxfY3RvcnM9KCk9PihfX193YXNtX2NhbGxfY3RvcnM9d2FzbUV4cG9ydHNbXCJCXCJdKSgpO3ZhciBfX19nZXRUeXBlTmFtZT1hMD0+KF9fX2dldFR5cGVOYW1lPXdhc21FeHBvcnRzW1wiRFwiXSkoYTApO3ZhciBfX19lcnJub19sb2NhdGlvbj0oKT0+KF9fX2Vycm5vX2xvY2F0aW9uPXdhc21FeHBvcnRzW1wiX19lcnJub19sb2NhdGlvblwiXSkoKTt2YXIgX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPWEwPT4oX21hbGxvYz1Nb2R1bGVbXCJfbWFsbG9jXCJdPXdhc21FeHBvcnRzW1wiRVwiXSkoYTApO3ZhciBfZnJlZT1Nb2R1bGVbXCJfZnJlZVwiXT1hMD0+KF9mcmVlPU1vZHVsZVtcIl9mcmVlXCJdPXdhc21FeHBvcnRzW1wiRlwiXSkoYTApO3ZhciBzdGFja1NhdmU9KCk9PihzdGFja1NhdmU9d2FzbUV4cG9ydHNbXCJHXCJdKSgpO3ZhciBzdGFja1Jlc3RvcmU9YTA9PihzdGFja1Jlc3RvcmU9d2FzbUV4cG9ydHNbXCJIXCJdKShhMCk7dmFyIHN0YWNrQWxsb2M9YTA9PihzdGFja0FsbG9jPXdhc21FeHBvcnRzW1wiSVwiXSkoYTApO3ZhciBfX19jeGFfaW5jcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudD1hMD0+KF9fX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50PXdhc21FeHBvcnRzW1wiX19jeGFfaW5jcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudFwiXSkoYTApO3ZhciBfX19jeGFfaXNfcG9pbnRlcl90eXBlPWEwPT4oX19fY3hhX2lzX3BvaW50ZXJfdHlwZT13YXNtRXhwb3J0c1tcIkpcIl0pKGEwKTt2YXIgZHluQ2FsbF9qaWppPU1vZHVsZVtcImR5bkNhbGxfamlqaVwiXT0oYTAsYTEsYTIsYTMsYTQpPT4oZHluQ2FsbF9qaWppPU1vZHVsZVtcImR5bkNhbGxfamlqaVwiXT13YXNtRXhwb3J0c1tcIktcIl0pKGEwLGExLGEyLGEzLGE0KTt2YXIgZHluQ2FsbF92aWlqaWk9TW9kdWxlW1wiZHluQ2FsbF92aWlqaWlcIl09KGEwLGExLGEyLGEzLGE0LGE1LGE2KT0+KGR5bkNhbGxfdmlpamlpPU1vZHVsZVtcImR5bkNhbGxfdmlpamlpXCJdPXdhc21FeHBvcnRzW1wiTFwiXSkoYTAsYTEsYTIsYTMsYTQsYTUsYTYpO3ZhciBkeW5DYWxsX2lpaWlpaj1Nb2R1bGVbXCJkeW5DYWxsX2lpaWlpalwiXT0oYTAsYTEsYTIsYTMsYTQsYTUsYTYpPT4oZHluQ2FsbF9paWlpaWo9TW9kdWxlW1wiZHluQ2FsbF9paWlpaWpcIl09d2FzbUV4cG9ydHNbXCJNXCJdKShhMCxhMSxhMixhMyxhNCxhNSxhNik7dmFyIGR5bkNhbGxfaWlpaWlqaj1Nb2R1bGVbXCJkeW5DYWxsX2lpaWlpampcIl09KGEwLGExLGEyLGEzLGE0LGE1LGE2LGE3LGE4KT0+KGR5bkNhbGxfaWlpaWlqaj1Nb2R1bGVbXCJkeW5DYWxsX2lpaWlpampcIl09d2FzbUV4cG9ydHNbXCJOXCJdKShhMCxhMSxhMixhMyxhNCxhNSxhNixhNyxhOCk7dmFyIGR5bkNhbGxfaWlpaWlpamo9TW9kdWxlW1wiZHluQ2FsbF9paWlpaWlqalwiXT0oYTAsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpPT4oZHluQ2FsbF9paWlpaWlqaj1Nb2R1bGVbXCJkeW5DYWxsX2lpaWlpaWpqXCJdPXdhc21FeHBvcnRzW1wiT1wiXSkoYTAsYTEsYTIsYTMsYTQsYTUsYTYsYTcsYTgsYTkpO01vZHVsZVtcImNjYWxsXCJdPWNjYWxsO3ZhciBjYWxsZWRSdW47ZGVwZW5kZW5jaWVzRnVsZmlsbGVkPWZ1bmN0aW9uIHJ1bkNhbGxlcigpe2lmKCFjYWxsZWRSdW4pcnVuKCk7aWYoIWNhbGxlZFJ1bilkZXBlbmRlbmNpZXNGdWxmaWxsZWQ9cnVuQ2FsbGVyfTtmdW5jdGlvbiBydW4oKXtpZihydW5EZXBlbmRlbmNpZXM+MCl7cmV0dXJufXByZVJ1bigpO2lmKHJ1bkRlcGVuZGVuY2llcz4wKXtyZXR1cm59ZnVuY3Rpb24gZG9SdW4oKXtpZihjYWxsZWRSdW4pcmV0dXJuO2NhbGxlZFJ1bj10cnVlO01vZHVsZVtcImNhbGxlZFJ1blwiXT10cnVlO2lmKEFCT1JUKXJldHVybjtpbml0UnVudGltZSgpO3JlYWR5UHJvbWlzZVJlc29sdmUoTW9kdWxlKTtpZihNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSlNb2R1bGVbXCJvblJ1bnRpbWVJbml0aWFsaXplZFwiXSgpO3Bvc3RSdW4oKX1pZihNb2R1bGVbXCJzZXRTdGF0dXNcIl0pe01vZHVsZVtcInNldFN0YXR1c1wiXShcIlJ1bm5pbmcuLi5cIik7c2V0VGltZW91dChmdW5jdGlvbigpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtNb2R1bGVbXCJzZXRTdGF0dXNcIl0oXCJcIil9LDEpO2RvUnVuKCl9LDEpfWVsc2V7ZG9SdW4oKX19aWYoTW9kdWxlW1wicHJlSW5pdFwiXSl7aWYodHlwZW9mIE1vZHVsZVtcInByZUluaXRcIl09PVwiZnVuY3Rpb25cIilNb2R1bGVbXCJwcmVJbml0XCJdPVtNb2R1bGVbXCJwcmVJbml0XCJdXTt3aGlsZShNb2R1bGVbXCJwcmVJbml0XCJdLmxlbmd0aD4wKXtNb2R1bGVbXCJwcmVJbml0XCJdLnBvcCgpKCl9fXJ1bigpO1xuXG5cbiAgcmV0dXJuIG1vZHVsZUFyZy5yZWFkeVxufVxuKTtcbn0pKCk7XG47XG5leHBvcnQgZGVmYXVsdCBNb2R1bGU7Il0sIm5hbWVzIjpbIk1vZHVsZSIsIl9zY3JpcHREaXIiLCJkb2N1bWVudCIsImN1cnJlbnRTY3JpcHQiLCJzcmMiLCJ1bmRlZmluZWQiLCJtb2R1bGVBcmciLCJyZWFkeVByb21pc2VSZXNvbHZlIiwicmVhZHlQcm9taXNlUmVqZWN0IiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJtb2R1bGVPdmVycmlkZXMiLCJPYmplY3QiLCJhc3NpZ24iLCJhcmd1bWVudHNfIiwidGhpc1Byb2dyYW0iLCJxdWl0XyIsInN0YXR1cyIsInRvVGhyb3ciLCJFTlZJUk9OTUVOVF9JU19XRUIiLCJFTlZJUk9OTUVOVF9JU19XT1JLRVIiLCJzY3JpcHREaXJlY3RvcnkiLCJsb2NhdGVGaWxlIiwicGF0aCIsInJlYWRfIiwicmVhZEFzeW5jIiwicmVhZEJpbmFyeSIsInNlbGYiLCJsb2NhdGlvbiIsImhyZWYiLCJpbmRleE9mIiwic3Vic3RyIiwicmVwbGFjZSIsImxhc3RJbmRleE9mIiwidXJsIiwieGhyIiwiWE1MSHR0cFJlcXVlc3QiLCJvcGVuIiwic2VuZCIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlVHlwZSIsIlVpbnQ4QXJyYXkiLCJyZXNwb25zZSIsIm9ubG9hZCIsIm9uZXJyb3IiLCJvdXQiLCJjb25zb2xlIiwibG9nIiwiYmluZCIsImVyciIsImVycm9yIiwid2FzbUJpbmFyeSIsIldlYkFzc2VtYmx5IiwiYWJvcnQiLCJ3YXNtTWVtb3J5IiwiQUJPUlQiLCJFWElUU1RBVFVTIiwiYXNzZXJ0IiwiY29uZGl0aW9uIiwidGV4dCIsIkhFQVA4IiwiSEVBUFU4IiwiSEVBUDE2IiwiSEVBUFUxNiIsIkhFQVAzMiIsIkhFQVBVMzIiLCJIRUFQRjMyIiwiSEVBUEY2NCIsInVwZGF0ZU1lbW9yeVZpZXdzIiwiYiIsImJ1ZmZlciIsIkludDhBcnJheSIsIkludDE2QXJyYXkiLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsIkZsb2F0MzJBcnJheSIsIkZsb2F0NjRBcnJheSIsIl9fQVRQUkVSVU5fXyIsIl9fQVRJTklUX18iLCJfX0FUUE9TVFJVTl9fIiwicnVudGltZUluaXRpYWxpemVkIiwicHJlUnVuIiwibGVuZ3RoIiwiYWRkT25QcmVSdW4iLCJzaGlmdCIsImNhbGxSdW50aW1lQ2FsbGJhY2tzIiwiaW5pdFJ1bnRpbWUiLCJGUyIsImluaXQiLCJpbml0aWFsaXplZCIsImlnbm9yZVBlcm1pc3Npb25zIiwiVFRZIiwicG9zdFJ1biIsImFkZE9uUG9zdFJ1biIsImNiIiwidW5zaGlmdCIsImFkZE9uSW5pdCIsInJ1bkRlcGVuZGVuY2llcyIsInJ1bkRlcGVuZGVuY3lXYXRjaGVyIiwiZGVwZW5kZW5jaWVzRnVsZmlsbGVkIiwiZ2V0VW5pcXVlUnVuRGVwZW5kZW5jeSIsImlkIiwiYWRkUnVuRGVwZW5kZW5jeSIsInJlbW92ZVJ1bkRlcGVuZGVuY3kiLCJjbGVhckludGVydmFsIiwiY2FsbGJhY2siLCJ3aGF0IiwiZSIsIlJ1bnRpbWVFcnJvciIsImRhdGFVUklQcmVmaXgiLCJpc0RhdGFVUkkiLCJmaWxlbmFtZSIsInN0YXJ0c1dpdGgiLCJ3YXNtQmluYXJ5RmlsZSIsImdldEJpbmFyeVN5bmMiLCJmaWxlIiwiZ2V0QmluYXJ5UHJvbWlzZSIsImJpbmFyeUZpbGUiLCJmZXRjaCIsImNyZWRlbnRpYWxzIiwidGhlbiIsImNhdGNoIiwiaW5zdGFudGlhdGVBcnJheUJ1ZmZlciIsImltcG9ydHMiLCJyZWNlaXZlciIsImJpbmFyeSIsImluc3RhbnRpYXRlIiwiaW5zdGFuY2UiLCJyZWFzb24iLCJpbnN0YW50aWF0ZUFzeW5jIiwiaW5zdGFudGlhdGVTdHJlYW1pbmciLCJyZXN1bHQiLCJjcmVhdGVXYXNtIiwiaW5mbyIsIndhc21JbXBvcnRzIiwicmVjZWl2ZUluc3RhbmNlIiwibW9kdWxlIiwid2FzbUV4cG9ydHMiLCJleHBvcnRzIiwid2FzbVRhYmxlIiwicmVjZWl2ZUluc3RhbnRpYXRpb25SZXN1bHQiLCJ0ZW1wRG91YmxlIiwidGVtcEk2NCIsImNhbGxiYWNrcyIsIm5vRXhpdFJ1bnRpbWUiLCJFeGNlcHRpb25JbmZvIiwiZXhjUHRyIiwicHRyIiwic2V0X3R5cGUiLCJ0eXBlIiwiZ2V0X3R5cGUiLCJzZXRfZGVzdHJ1Y3RvciIsImRlc3RydWN0b3IiLCJnZXRfZGVzdHJ1Y3RvciIsInNldF9jYXVnaHQiLCJjYXVnaHQiLCJnZXRfY2F1Z2h0Iiwic2V0X3JldGhyb3duIiwicmV0aHJvd24iLCJnZXRfcmV0aHJvd24iLCJzZXRfYWRqdXN0ZWRfcHRyIiwiYWRqdXN0ZWRQdHIiLCJnZXRfYWRqdXN0ZWRfcHRyIiwiZ2V0X2V4Y2VwdGlvbl9wdHIiLCJpc1BvaW50ZXIiLCJfX19jeGFfaXNfcG9pbnRlcl90eXBlIiwiYWRqdXN0ZWQiLCJleGNlcHRpb25MYXN0IiwidW5jYXVnaHRFeGNlcHRpb25Db3VudCIsIl9fX2N4YV90aHJvdyIsInR1cGxlUmVnaXN0cmF0aW9ucyIsInJ1bkRlc3RydWN0b3JzIiwiZGVzdHJ1Y3RvcnMiLCJwb3AiLCJkZWwiLCJzaW1wbGVSZWFkVmFsdWVGcm9tUG9pbnRlciIsInBvaW50ZXIiLCJhd2FpdGluZ0RlcGVuZGVuY2llcyIsInJlZ2lzdGVyZWRUeXBlcyIsInR5cGVEZXBlbmRlbmNpZXMiLCJJbnRlcm5hbEVycm9yIiwidGhyb3dJbnRlcm5hbEVycm9yIiwibWVzc2FnZSIsIndoZW5EZXBlbmRlbnRUeXBlc0FyZVJlc29sdmVkIiwibXlUeXBlcyIsImRlcGVuZGVudFR5cGVzIiwiZ2V0VHlwZUNvbnZlcnRlcnMiLCJmb3JFYWNoIiwib25Db21wbGV0ZSIsInR5cGVDb252ZXJ0ZXJzIiwibXlUeXBlQ29udmVydGVycyIsImkiLCJyZWdpc3RlclR5cGUiLCJBcnJheSIsInVucmVnaXN0ZXJlZFR5cGVzIiwicmVnaXN0ZXJlZCIsImR0IiwiaGFzT3duUHJvcGVydHkiLCJwdXNoIiwiX19lbWJpbmRfZmluYWxpemVfdmFsdWVfYXJyYXkiLCJyYXdUdXBsZVR5cGUiLCJyZWciLCJlbGVtZW50cyIsImVsZW1lbnRzTGVuZ3RoIiwiZWxlbWVudFR5cGVzIiwibWFwIiwiZWx0IiwiZ2V0dGVyUmV0dXJuVHlwZSIsImNvbmNhdCIsInNldHRlckFyZ3VtZW50VHlwZSIsInJhd0NvbnN0cnVjdG9yIiwicmF3RGVzdHJ1Y3RvciIsImdldHRlciIsImdldHRlckNvbnRleHQiLCJzZXR0ZXIiLCJzZXR0ZXJDb250ZXh0IiwicmVhZCIsIndyaXRlIiwibyIsIm5hbWUiLCJydiIsIlR5cGVFcnJvciIsIkdlbmVyaWNXaXJlVHlwZVNpemUiLCJkZXN0cnVjdG9yRnVuY3Rpb24iLCJfX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQiLCJwcmltaXRpdmVUeXBlIiwic2l6ZSIsIm1pblJhbmdlIiwibWF4UmFuZ2UiLCJlbWJpbmRfaW5pdF9jaGFyQ29kZXMiLCJjb2RlcyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsImVtYmluZF9jaGFyQ29kZXMiLCJyZWFkTGF0aW4xU3RyaW5nIiwicmV0IiwiYyIsIkJpbmRpbmdFcnJvciIsInRocm93QmluZGluZ0Vycm9yIiwic2hhcmVkUmVnaXN0ZXJUeXBlIiwicmF3VHlwZSIsInJlZ2lzdGVyZWRJbnN0YW5jZSIsIm9wdGlvbnMiLCJpZ25vcmVEdXBsaWNhdGVSZWdpc3RyYXRpb25zIiwiX19lbWJpbmRfcmVnaXN0ZXJfYm9vbCIsInRydWVWYWx1ZSIsImZhbHNlVmFsdWUiLCJ3dCIsImhhbmRsZUFsbG9jYXRvckluaXQiLCJIYW5kbGVBbGxvY2F0b3IiLCJwcm90b3R5cGUiLCJnZXQiLCJhbGxvY2F0ZWQiLCJoYXMiLCJhbGxvY2F0ZSIsImhhbmRsZSIsImZyZWVsaXN0IiwiZnJlZSIsImVtdmFsX2hhbmRsZXMiLCJfX2VtdmFsX2RlY3JlZiIsInJlc2VydmVkIiwicmVmY291bnQiLCJjb3VudF9lbXZhbF9oYW5kbGVzIiwiY291bnQiLCJpbml0X2VtdmFsIiwidmFsdWUiLCJFbXZhbCIsInRvVmFsdWUiLCJ0b0hhbmRsZSIsIl9fZW1iaW5kX3JlZ2lzdGVyX2VtdmFsIiwiZW5zdXJlT3ZlcmxvYWRUYWJsZSIsInByb3RvIiwibWV0aG9kTmFtZSIsImh1bWFuTmFtZSIsIm92ZXJsb2FkVGFibGUiLCJwcmV2RnVuYyIsImFyZ3VtZW50cyIsImFwcGx5IiwiYXJnQ291bnQiLCJleHBvc2VQdWJsaWNTeW1ib2wiLCJudW1Bcmd1bWVudHMiLCJlbnVtUmVhZFZhbHVlRnJvbVBvaW50ZXIiLCJ3aWR0aCIsInNpZ25lZCIsIl9fZW1iaW5kX3JlZ2lzdGVyX2VudW0iLCJpc1NpZ25lZCIsImN0b3IiLCJ2YWx1ZXMiLCJjb25zdHJ1Y3RvciIsImNyZWF0ZU5hbWVkRnVuY3Rpb24iLCJib2R5IiwiZGVmaW5lUHJvcGVydHkiLCJnZXRUeXBlTmFtZSIsIl9fX2dldFR5cGVOYW1lIiwiX2ZyZWUiLCJyZXF1aXJlUmVnaXN0ZXJlZFR5cGUiLCJpbXBsIiwiX19lbWJpbmRfcmVnaXN0ZXJfZW51bV92YWx1ZSIsInJhd0VudW1UeXBlIiwiZW51bVZhbHVlIiwiZW51bVR5cGUiLCJFbnVtIiwiVmFsdWUiLCJjcmVhdGUiLCJmbG9hdFJlYWRWYWx1ZUZyb21Qb2ludGVyIiwiX19lbWJpbmRfcmVnaXN0ZXJfZmxvYXQiLCJuZXdGdW5jIiwiYXJndW1lbnRMaXN0IiwiRnVuY3Rpb24iLCJkdW1teSIsIm9iaiIsInIiLCJjcmFmdEludm9rZXJGdW5jdGlvbiIsImFyZ1R5cGVzIiwiY2xhc3NUeXBlIiwiY3BwSW52b2tlckZ1bmMiLCJjcHBUYXJnZXRGdW5jIiwiaXNBc3luYyIsImlzQ2xhc3NNZXRob2RGdW5jIiwibmVlZHNEZXN0cnVjdG9yU3RhY2siLCJyZXR1cm5zIiwiYXJnc0xpc3QiLCJhcmdzTGlzdFdpcmVkIiwiaW52b2tlckZuQm9keSIsImR0b3JTdGFjayIsImFyZ3MxIiwiYXJnczIiLCJwYXJhbU5hbWUiLCJpbnZva2VyRm4iLCJoZWFwMzJWZWN0b3JUb0FycmF5IiwiZmlyc3RFbGVtZW50IiwiYXJyYXkiLCJyZXBsYWNlUHVibGljU3ltYm9sIiwiZHluQ2FsbExlZ2FjeSIsInNpZyIsImFyZ3MiLCJmIiwiY2FsbCIsIndhc21UYWJsZU1pcnJvciIsImdldFdhc21UYWJsZUVudHJ5IiwiZnVuY1B0ciIsImZ1bmMiLCJkeW5DYWxsIiwiaW5jbHVkZXMiLCJydG4iLCJnZXREeW5DYWxsZXIiLCJhcmdDYWNoZSIsImVtYmluZF9fcmVxdWlyZUZ1bmN0aW9uIiwic2lnbmF0dXJlIiwicmF3RnVuY3Rpb24iLCJtYWtlRHluQ2FsbGVyIiwiZnAiLCJleHRlbmRFcnJvciIsImJhc2VFcnJvclR5cGUiLCJlcnJvck5hbWUiLCJlcnJvckNsYXNzIiwic3RhY2siLCJFcnJvciIsInRvU3RyaW5nIiwiVW5ib3VuZFR5cGVFcnJvciIsInRocm93VW5ib3VuZFR5cGVFcnJvciIsInR5cGVzIiwidW5ib3VuZFR5cGVzIiwic2VlbiIsInZpc2l0Iiwiam9pbiIsImdldEZ1bmN0aW9uTmFtZSIsInRyaW0iLCJhcmdzSW5kZXgiLCJfX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbiIsInJhd0FyZ1R5cGVzQWRkciIsInJhd0ludm9rZXIiLCJmbiIsImludm9rZXJBcmdzQXJyYXkiLCJzbGljZSIsImludGVnZXJSZWFkVmFsdWVGcm9tUG9pbnRlciIsIl9fZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIiLCJmcm9tV2lyZVR5cGUiLCJiaXRzaGlmdCIsImlzVW5zaWduZWRUeXBlIiwiY2hlY2tBc3NlcnRpb25zIiwidG9UeXBlTmFtZSIsInRvV2lyZVR5cGUiLCJfX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldyIsImRhdGFUeXBlSW5kZXgiLCJ0eXBlTWFwcGluZyIsIlRBIiwiZGVjb2RlTWVtb3J5VmlldyIsImRhdGEiLCJyZWFkUG9pbnRlciIsInN0cmluZ1RvVVRGOEFycmF5Iiwic3RyIiwiaGVhcCIsIm91dElkeCIsIm1heEJ5dGVzVG9Xcml0ZSIsInN0YXJ0SWR4IiwiZW5kSWR4IiwidSIsImNoYXJDb2RlQXQiLCJ1MSIsInN0cmluZ1RvVVRGOCIsIm91dFB0ciIsImxlbmd0aEJ5dGVzVVRGOCIsImxlbiIsIlVURjhEZWNvZGVyIiwiVGV4dERlY29kZXIiLCJVVEY4QXJyYXlUb1N0cmluZyIsImhlYXBPckFycmF5IiwiaWR4IiwibWF4Qnl0ZXNUb1JlYWQiLCJlbmRQdHIiLCJkZWNvZGUiLCJzdWJhcnJheSIsInUwIiwidTIiLCJjaCIsIlVURjhUb1N0cmluZyIsIl9fZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmciLCJzdGRTdHJpbmdJc1VURjgiLCJwYXlsb2FkIiwiZGVjb2RlU3RhcnRQdHIiLCJjdXJyZW50Qnl0ZVB0ciIsIm1heFJlYWQiLCJzdHJpbmdTZWdtZW50IiwiYSIsIkFycmF5QnVmZmVyIiwidmFsdWVJc09mVHlwZVN0cmluZyIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiYmFzZSIsIl9tYWxsb2MiLCJjaGFyQ29kZSIsIlVURjE2RGVjb2RlciIsIlVURjE2VG9TdHJpbmciLCJtYXhJZHgiLCJjb2RlVW5pdCIsInN0cmluZ1RvVVRGMTYiLCJzdGFydFB0ciIsIm51bUNoYXJzVG9Xcml0ZSIsImxlbmd0aEJ5dGVzVVRGMTYiLCJVVEYzMlRvU3RyaW5nIiwidXRmMzIiLCJzdHJpbmdUb1VURjMyIiwidHJhaWxTdXJyb2dhdGUiLCJsZW5ndGhCeXRlc1VURjMyIiwiX19lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmciLCJjaGFyU2l6ZSIsImRlY29kZVN0cmluZyIsImVuY29kZVN0cmluZyIsImdldEhlYXAiLCJsZW5ndGhCeXRlc1VURiIsIkhFQVAiLCJtYXhSZWFkQnl0ZXMiLCJfX2VtYmluZF9yZWdpc3Rlcl92YWx1ZV9hcnJheSIsImNvbnN0cnVjdG9yU2lnbmF0dXJlIiwiZGVzdHJ1Y3RvclNpZ25hdHVyZSIsIl9fZW1iaW5kX3JlZ2lzdGVyX3ZhbHVlX2FycmF5X2VsZW1lbnQiLCJnZXR0ZXJTaWduYXR1cmUiLCJzZXR0ZXJTaWduYXR1cmUiLCJfX2VtYmluZF9yZWdpc3Rlcl92b2lkIiwiaXNWb2lkIiwiX2Fib3J0IiwiX2Vtc2NyaXB0ZW5fbWVtY3B5X2pzIiwiZGVzdCIsIm51bSIsImNvcHlXaXRoaW4iLCJnZXRIZWFwTWF4IiwiZ3Jvd01lbW9yeSIsInBhZ2VzIiwiYnl0ZUxlbmd0aCIsImdyb3ciLCJfZW1zY3JpcHRlbl9yZXNpemVfaGVhcCIsInJlcXVlc3RlZFNpemUiLCJvbGRTaXplIiwibWF4SGVhcFNpemUiLCJhbGlnblVwIiwieCIsIm11bHRpcGxlIiwiY3V0RG93biIsIm92ZXJHcm93bkhlYXBTaXplIiwiTWF0aCIsIm1pbiIsIm5ld1NpemUiLCJtYXgiLCJyZXBsYWNlbWVudCIsIkVOViIsImdldEV4ZWN1dGFibGVOYW1lIiwiZ2V0RW52U3RyaW5ncyIsInN0cmluZ3MiLCJsYW5nIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2VzIiwiZW52Iiwic3RyaW5nVG9Bc2NpaSIsIlBBVEgiLCJpc0FicyIsImNoYXJBdCIsInNwbGl0UGF0aCIsInNwbGl0UGF0aFJlIiwiZXhlYyIsIm5vcm1hbGl6ZUFycmF5IiwicGFydHMiLCJhbGxvd0Fib3ZlUm9vdCIsInVwIiwibGFzdCIsInNwbGljZSIsIm5vcm1hbGl6ZSIsImlzQWJzb2x1dGUiLCJ0cmFpbGluZ1NsYXNoIiwic3BsaXQiLCJmaWx0ZXIiLCJwIiwiZGlybmFtZSIsInJvb3QiLCJkaXIiLCJiYXNlbmFtZSIsImxhc3RTbGFzaCIsInBhdGhzIiwiam9pbjIiLCJsIiwiaW5pdFJhbmRvbUZpbGwiLCJjcnlwdG8iLCJ2aWV3IiwiZ2V0UmFuZG9tVmFsdWVzIiwicmFuZG9tRmlsbCIsIlBBVEhfRlMiLCJyZXNvbHZlZFBhdGgiLCJyZXNvbHZlZEFic29sdXRlIiwiY3dkIiwicmVsYXRpdmUiLCJmcm9tIiwidG8iLCJhcnIiLCJzdGFydCIsImVuZCIsImZyb21QYXJ0cyIsInRvUGFydHMiLCJzYW1lUGFydHNMZW5ndGgiLCJvdXRwdXRQYXJ0cyIsIkZTX3N0ZGluX2dldENoYXJfYnVmZmVyIiwiaW50QXJyYXlGcm9tU3RyaW5nIiwic3RyaW5neSIsImRvbnRBZGROdWxsIiwidThhcnJheSIsIm51bUJ5dGVzV3JpdHRlbiIsIkZTX3N0ZGluX2dldENoYXIiLCJ3aW5kb3ciLCJwcm9tcHQiLCJyZWFkbGluZSIsInR0eXMiLCJzaHV0ZG93biIsInJlZ2lzdGVyIiwiZGV2Iiwib3BzIiwiaW5wdXQiLCJvdXRwdXQiLCJyZWdpc3RlckRldmljZSIsInN0cmVhbV9vcHMiLCJzdHJlYW0iLCJ0dHkiLCJub2RlIiwicmRldiIsIkVycm5vRXJyb3IiLCJzZWVrYWJsZSIsImNsb3NlIiwiZnN5bmMiLCJvZmZzZXQiLCJwb3MiLCJnZXRfY2hhciIsImJ5dGVzUmVhZCIsInRpbWVzdGFtcCIsIkRhdGUiLCJub3ciLCJwdXRfY2hhciIsImRlZmF1bHRfdHR5X29wcyIsInZhbCIsImlvY3RsX3RjZ2V0cyIsImNfaWZsYWciLCJjX29mbGFnIiwiY19jZmxhZyIsImNfbGZsYWciLCJjX2NjIiwiaW9jdGxfdGNzZXRzIiwib3B0aW9uYWxfYWN0aW9ucyIsImlvY3RsX3Rpb2Nnd2luc3oiLCJkZWZhdWx0X3R0eTFfb3BzIiwibW1hcEFsbG9jIiwiTUVNRlMiLCJvcHNfdGFibGUiLCJtb3VudCIsImNyZWF0ZU5vZGUiLCJwYXJlbnQiLCJtb2RlIiwiaXNCbGtkZXYiLCJpc0ZJRk8iLCJnZXRhdHRyIiwibm9kZV9vcHMiLCJzZXRhdHRyIiwibG9va3VwIiwibWtub2QiLCJyZW5hbWUiLCJ1bmxpbmsiLCJybWRpciIsInJlYWRkaXIiLCJzeW1saW5rIiwibGxzZWVrIiwibW1hcCIsIm1zeW5jIiwibGluayIsInJlYWRsaW5rIiwiY2hyZGV2IiwiY2hyZGV2X3N0cmVhbV9vcHMiLCJpc0RpciIsImNvbnRlbnRzIiwiaXNGaWxlIiwidXNlZEJ5dGVzIiwiaXNMaW5rIiwiaXNDaHJkZXYiLCJnZXRGaWxlRGF0YUFzVHlwZWRBcnJheSIsImV4cGFuZEZpbGVTdG9yYWdlIiwibmV3Q2FwYWNpdHkiLCJwcmV2Q2FwYWNpdHkiLCJDQVBBQ0lUWV9ET1VCTElOR19NQVgiLCJvbGRDb250ZW50cyIsInNldCIsInJlc2l6ZUZpbGVTdG9yYWdlIiwiYXR0ciIsImlubyIsIm5saW5rIiwidWlkIiwiZ2lkIiwiYXRpbWUiLCJtdGltZSIsImN0aW1lIiwiYmxrc2l6ZSIsImJsb2NrcyIsImNlaWwiLCJnZW5lcmljRXJyb3JzIiwib2xkX25vZGUiLCJuZXdfZGlyIiwibmV3X25hbWUiLCJuZXdfbm9kZSIsImxvb2t1cE5vZGUiLCJlbnRyaWVzIiwia2V5IiwibmV3bmFtZSIsIm9sZHBhdGgiLCJwb3NpdGlvbiIsImNhbk93biIsIndoZW5jZSIsInByb3QiLCJmbGFncyIsImJ5dGVPZmZzZXQiLCJtbWFwRmxhZ3MiLCJhc3luY0xvYWQiLCJub1J1bkRlcCIsImRlcCIsImFycmF5QnVmZmVyIiwiZXZlbnQiLCJGU19jcmVhdGVEYXRhRmlsZSIsImZpbGVEYXRhIiwiY2FuUmVhZCIsImNhbldyaXRlIiwiY3JlYXRlRGF0YUZpbGUiLCJwcmVsb2FkUGx1Z2lucyIsIkZTX2hhbmRsZWRCeVByZWxvYWRQbHVnaW4iLCJieXRlQXJyYXkiLCJmdWxsbmFtZSIsImZpbmlzaCIsIkJyb3dzZXIiLCJoYW5kbGVkIiwicGx1Z2luIiwiRlNfY3JlYXRlUHJlbG9hZGVkRmlsZSIsImRvbnRDcmVhdGVGaWxlIiwicHJlRmluaXNoIiwicHJvY2Vzc0RhdGEiLCJGU19tb2RlU3RyaW5nVG9GbGFncyIsImZsYWdNb2RlcyIsIkZTX2dldE1vZGUiLCJtb3VudHMiLCJkZXZpY2VzIiwic3RyZWFtcyIsIm5leHRJbm9kZSIsIm5hbWVUYWJsZSIsImN1cnJlbnRQYXRoIiwiZmlsZXN5c3RlbXMiLCJzeW5jRlNSZXF1ZXN0cyIsImxvb2t1cFBhdGgiLCJvcHRzIiwiZGVmYXVsdHMiLCJmb2xsb3dfbW91bnQiLCJyZWN1cnNlX2NvdW50IiwiY3VycmVudCIsImN1cnJlbnRfcGF0aCIsImlzbGFzdCIsImlzTW91bnRwb2ludCIsIm1vdW50ZWQiLCJmb2xsb3ciLCJnZXRQYXRoIiwiaXNSb290IiwibW91bnRwb2ludCIsImhhc2hOYW1lIiwicGFyZW50aWQiLCJoYXNoIiwiaGFzaEFkZE5vZGUiLCJuYW1lX25leHQiLCJoYXNoUmVtb3ZlTm9kZSIsImVyckNvZGUiLCJtYXlMb29rdXAiLCJub2RlTmFtZSIsIkZTTm9kZSIsImRlc3Ryb3lOb2RlIiwiaXNTb2NrZXQiLCJmbGFnc1RvUGVybWlzc2lvblN0cmluZyIsImZsYWciLCJwZXJtcyIsIm5vZGVQZXJtaXNzaW9ucyIsIm1heUNyZWF0ZSIsIm1heURlbGV0ZSIsImlzZGlyIiwiZXJybm8iLCJtYXlPcGVuIiwiTUFYX09QRU5fRkRTIiwibmV4dGZkIiwiZmQiLCJnZXRTdHJlYW1DaGVja2VkIiwiZ2V0U3RyZWFtIiwiY3JlYXRlU3RyZWFtIiwiRlNTdHJlYW0iLCJzaGFyZWQiLCJkZWZpbmVQcm9wZXJ0aWVzIiwib2JqZWN0IiwiaXNSZWFkIiwiaXNXcml0ZSIsImlzQXBwZW5kIiwiY2xvc2VTdHJlYW0iLCJkZXZpY2UiLCJnZXREZXZpY2UiLCJtYWpvciIsIm1pbm9yIiwibWFrZWRldiIsIm1hIiwibWkiLCJnZXRNb3VudHMiLCJjaGVjayIsIm0iLCJzeW5jZnMiLCJwb3B1bGF0ZSIsImNvbXBsZXRlZCIsImRvQ2FsbGJhY2siLCJkb25lIiwiZXJyb3JlZCIsInBzZXVkbyIsIm1vdW50Um9vdCIsInVubW91bnQiLCJrZXlzIiwibmV4dCIsIm1rZGlyIiwibWtkaXJUcmVlIiwiZGlycyIsImQiLCJta2RldiIsIm5ld3BhdGgiLCJvbGRfcGF0aCIsIm5ld19wYXRoIiwib2xkX2Rpcm5hbWUiLCJuZXdfZGlybmFtZSIsIm9sZF9uYW1lIiwib2xkX2RpciIsInN0YXQiLCJkb250Rm9sbG93IiwibHN0YXQiLCJjaG1vZCIsImxjaG1vZCIsImZjaG1vZCIsImNob3duIiwibGNob3duIiwiZmNob3duIiwidHJ1bmNhdGUiLCJmdHJ1bmNhdGUiLCJ1dGltZSIsImNyZWF0ZWQiLCJ1bmdvdHRlbiIsInJlYWRGaWxlcyIsImlzQ2xvc2VkIiwiZ2V0ZGVudHMiLCJzZWVraW5nIiwiYnl0ZXNXcml0dGVuIiwibXVubWFwIiwiaW9jdGwiLCJjbWQiLCJhcmciLCJyZWFkRmlsZSIsImVuY29kaW5nIiwiYnVmIiwid3JpdGVGaWxlIiwiYWN0dWFsTnVtQnl0ZXMiLCJpc1ZpZXciLCJjaGRpciIsImNyZWF0ZURlZmF1bHREaXJlY3RvcmllcyIsImNyZWF0ZURlZmF1bHREZXZpY2VzIiwicmFuZG9tQnVmZmVyIiwicmFuZG9tTGVmdCIsInJhbmRvbUJ5dGUiLCJjcmVhdGVEZXZpY2UiLCJjcmVhdGVTcGVjaWFsRGlyZWN0b3JpZXMiLCJwcm9jX3NlbGYiLCJjcmVhdGVTdGFuZGFyZFN0cmVhbXMiLCJzdGRpbiIsInN0ZG91dCIsInN0ZGVyciIsImVuc3VyZUVycm5vRXJyb3IiLCJzZXRFcnJubyIsImNvZGUiLCJzdGF0aWNJbml0IiwicXVpdCIsImZpbmRPYmplY3QiLCJkb250UmVzb2x2ZUxhc3RMaW5rIiwiYW5hbHl6ZVBhdGgiLCJleGlzdHMiLCJwYXJlbnRFeGlzdHMiLCJwYXJlbnRQYXRoIiwicGFyZW50T2JqZWN0IiwiY3JlYXRlUGF0aCIsInJldmVyc2UiLCJwYXJ0IiwiY3JlYXRlRmlsZSIsInByb3BlcnRpZXMiLCJmb3JjZUxvYWRGaWxlIiwiaXNEZXZpY2UiLCJpc0ZvbGRlciIsImNyZWF0ZUxhenlGaWxlIiwiTGF6eVVpbnQ4QXJyYXkiLCJsZW5ndGhLbm93biIsImNodW5rcyIsIkxhenlVaW50OEFycmF5X2dldCIsImNodW5rT2Zmc2V0IiwiY2h1bmtTaXplIiwiY2h1bmtOdW0iLCJzZXREYXRhR2V0dGVyIiwiTGF6eVVpbnQ4QXJyYXlfc2V0RGF0YUdldHRlciIsImNhY2hlTGVuZ3RoIiwiTGF6eVVpbnQ4QXJyYXlfY2FjaGVMZW5ndGgiLCJkYXRhbGVuZ3RoIiwiTnVtYmVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJoZWFkZXIiLCJoYXNCeXRlU2VydmluZyIsInVzZXNHemlwIiwiZG9YSFIiLCJzZXRSZXF1ZXN0SGVhZGVyIiwib3ZlcnJpZGVNaW1lVHlwZSIsImxhenlBcnJheSIsIl9sZW5ndGgiLCJfY2h1bmtTaXplIiwiZm9yY2VMb2FkTGF6eUZpbGUiLCJ3cml0ZUNodW5rcyIsIlNZU0NBTExTIiwiREVGQVVMVF9QT0xMTUFTSyIsImNhbGN1bGF0ZUF0IiwiZGlyZmQiLCJhbGxvd0VtcHR5IiwiZGlyc3RyZWFtIiwiZ2V0U3RyZWFtRnJvbUZEIiwiZG9TdGF0IiwiYWJzIiwiZmxvb3IiLCJnZXRUaW1lIiwiZG9Nc3luYyIsImFkZHIiLCJ2YXJhcmdzIiwiZ2V0cCIsImdldFN0ciIsIl9lbnZpcm9uX2dldCIsIl9fZW52aXJvbiIsImVudmlyb25fYnVmIiwiYnVmU2l6ZSIsInN0cmluZyIsIl9lbnZpcm9uX3NpemVzX2dldCIsInBlbnZpcm9uX2NvdW50IiwicGVudmlyb25fYnVmX3NpemUiLCJfZmRfY2xvc2UiLCJkb1JlYWR2IiwiaW92IiwiaW92Y250IiwiY3VyciIsIl9mZF9yZWFkIiwicG51bSIsImNvbnZlcnRJMzJQYWlyVG9JNTNDaGVja2VkIiwibG8iLCJoaSIsIk5hTiIsIl9mZF9zZWVrIiwib2Zmc2V0X2xvdyIsIm9mZnNldF9oaWdoIiwibmV3T2Zmc2V0IiwiaXNOYU4iLCJkb1dyaXRldiIsIl9mZF93cml0ZSIsImlzTGVhcFllYXIiLCJ5ZWFyIiwiYXJyYXlTdW0iLCJpbmRleCIsInN1bSIsIk1PTlRIX0RBWVNfTEVBUCIsIk1PTlRIX0RBWVNfUkVHVUxBUiIsImFkZERheXMiLCJkYXRlIiwiZGF5cyIsIm5ld0RhdGUiLCJsZWFwIiwiZ2V0RnVsbFllYXIiLCJjdXJyZW50TW9udGgiLCJnZXRNb250aCIsImRheXNJbkN1cnJlbnRNb250aCIsImdldERhdGUiLCJzZXREYXRlIiwic2V0TW9udGgiLCJzZXRGdWxsWWVhciIsIndyaXRlQXJyYXlUb01lbW9yeSIsIl9zdHJmdGltZSIsInMiLCJtYXhzaXplIiwiZm9ybWF0IiwidG0iLCJ0bV96b25lIiwidG1fc2VjIiwidG1fbWluIiwidG1faG91ciIsInRtX21kYXkiLCJ0bV9tb24iLCJ0bV95ZWFyIiwidG1fd2RheSIsInRtX3lkYXkiLCJ0bV9pc2RzdCIsInRtX2dtdG9mZiIsInBhdHRlcm4iLCJFWFBBTlNJT05fUlVMRVNfMSIsInJ1bGUiLCJSZWdFeHAiLCJXRUVLREFZUyIsIk1PTlRIUyIsImxlYWRpbmdTb21ldGhpbmciLCJkaWdpdHMiLCJjaGFyYWN0ZXIiLCJsZWFkaW5nTnVsbHMiLCJjb21wYXJlQnlEYXkiLCJkYXRlMSIsImRhdGUyIiwic2duIiwiY29tcGFyZSIsImdldEZpcnN0V2Vla1N0YXJ0RGF0ZSIsImphbkZvdXJ0aCIsImdldERheSIsImdldFdlZWtCYXNlZFllYXIiLCJ0aGlzRGF0ZSIsImphbkZvdXJ0aFRoaXNZZWFyIiwiamFuRm91cnRoTmV4dFllYXIiLCJmaXJzdFdlZWtTdGFydFRoaXNZZWFyIiwiZmlyc3RXZWVrU3RhcnROZXh0WWVhciIsIkVYUEFOU0lPTl9SVUxFU18yIiwic3Vic3RyaW5nIiwidHdlbHZlSG91ciIsImRlYzMxIiwiamFuMSIsIm9mZiIsImFoZWFkIiwiYnl0ZXMiLCJfc3RyZnRpbWVfbCIsImxvYyIsImdldENGdW5jIiwiaWRlbnQiLCJzdHJpbmdUb1VURjhPblN0YWNrIiwic3RhY2tBbGxvYyIsImNjYWxsIiwicmV0dXJuVHlwZSIsInRvQyIsImNvbnZlcnRSZXR1cm5WYWx1ZSIsIkJvb2xlYW4iLCJjQXJncyIsImNvbnZlcnRlciIsInN0YWNrU2F2ZSIsIm9uRG9uZSIsInN0YWNrUmVzdG9yZSIsInJlYWRNb2RlIiwid3JpdGVNb2RlIiwiY3JlYXRlUHJlbG9hZGVkRmlsZSIsImsiLCJ5IiwieiIsImoiLCJoIiwiZyIsIm4iLCJ3IiwidCIsInYiLCJxIiwiX19fd2FzbV9jYWxsX2N0b3JzIiwiYTAiLCJfX19lcnJub19sb2NhdGlvbiIsIl9fX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50IiwiZHluQ2FsbF9qaWppIiwiYTEiLCJhMiIsImEzIiwiYTQiLCJkeW5DYWxsX3ZpaWppaSIsImE1IiwiYTYiLCJkeW5DYWxsX2lpaWlpaiIsImR5bkNhbGxfaWlpaWlqaiIsImE3IiwiYTgiLCJkeW5DYWxsX2lpaWlpaWpqIiwiYTkiLCJjYWxsZWRSdW4iLCJydW5DYWxsZXIiLCJydW4iLCJkb1J1biIsInNldFRpbWVvdXQiLCJyZWFkeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@splinetool/runtime/build/boolean.js\n"));

/***/ })

}]);